0000              1   
0000              2   
0000              3   
0000              4   ; Main file. FSM implementing the following sequence:
0000              5   ;       State 0: Power = 0% (default state)
0000              6   ;               if start = NO, self loop; if start = YES, next state
0000              7   ;       State 1: Power = 100%; Sec = 0
0000              8   ;               if temp <= 150, self loop; temp > 150, next
0000              9   ;       State 2: Power = 20%
0000             10   ;               if sec <= 60s, self loop; sec>60s, next
0000             11   ;       State 3: Power = 100%; Sec = 0
0000             12   ;               if temp <= 220, self loop; temp>220, next
0000             13   ;       State 4: Power = 20%
0000             14   ;               if sec <= 45s, self loop; sec >45, next
0000             15   ;       State 5: Power = 0%
0000             16   ;               if temp >=60, self loop; temp <60, next
0000             17   ;       return to state 0
0000             18   
0000             19   
0000             20   ; MACROS ;
                 21   CLJNE mac  
                 22       cjne %0, %1, $+3+2 ; Jump if no equal 2 bytes ahead since sjmp is a 2 byte instruction  
                 23       sjmp $+2+3 ; Jump 3 bytes after this instruction as ljmp takes 3 bytes to encode
                 24       ljmp %2 ; ljmp can access any part of the code space
                 25   endmac
0000             26   
0000             27   ; check_Push_Button(variable_flag, dest_label)
0000             28   ; Params
0000             29   ; variable_flag - variable we are checking in place of the pin e.g. PB_START_PIN
0000             30   ; dest_label - where to jump if a push button is not pressed
                 31   check_Push_Button MAC ; new one with multiplexed buttons
                 32           setb PB_START_PIN
                 33           setb PB_CHANGE_MENU_PIN
                 34           setb PB_INC_TEMP_PIN
                 35           setb PB_INC_TIME_PIN
                 36           setb PB_STOP_PIN
                 37           
                 38           setb SHARED_PIN
                 39           ; check if any push buttons are pressed
                 40           clr START_PIN             
                 41           clr CHANGE_MENU_PIN       
                 42           clr INC_TEMP_PIN          
                 43           clr INC_TIME_PIN          
                 44           clr STOP_PIN
                 45   
                 46           ; debounce
                 47           jb SHARED_PIN, $+2+3 ; use helper label to jump to the end
                 48           sjmp $+2+3
                 49           ljmp %1
                 50           Wait_Milli_Seconds(#50)
                 51           jb SHARED_PIN, $+2+3
                 52           sjmp $+2+3
                 53           ljmp %1
                 54   
                 55           ; Set the LCD data pins to logic 1
                 56           setb START_PIN
                 57           setb CHANGE_MENU_PIN
                 58           setb INC_TEMP_PIN
                 59           setb INC_TIME_PIN
                 60           setb STOP_PIN
                 61   
                 62           ; check push buttons 1 by one
                 63           clr START_PIN
                 64           mov c, SHARED_PIN
                 65           mov PB_START_PIN, c
                 66           setb START_PIN
                 67   
                 68           clr CHANGE_MENU_PIN
                 69           mov c, SHARED_PIN
                 70           mov PB_CHANGE_MENU_PIN, c
                 71           setb CHANGE_MENU_PIN
                 72   
                 73           clr INC_TEMP_PIN
                 74           mov c, SHARED_PIN
                 75           mov PB_INC_TEMP_PIN, c
                 76           setb INC_TEMP_PIN
                 77   
                 78           clr INC_TIME_PIN
                 79           mov c, SHARED_PIN
                 80           mov PB_INC_TIME_PIN, c
                 81           setb INC_TIME_PIN
                 82   
                 83           clr STOP_PIN
                 84           mov c, SHARED_PIN
                 85           mov PB_STOP_PIN, c
                 86           setb STOP_PIN
                 87   
                 88           ; jb %0, %1 ; check that the variable flag is not 1, otherwise jmp
                 89   
                 90           jb %0, $+2+3 ; check that the variable flag is not 1, otherwise jmp
                 91           sjmp $+2+3
                 92           ljmp %1     ; can access anypart of the code
                 93   
                 94   ENDMAC
0000             95   
0000             96   ; temp_gt_threshold(threshold_temp, new_oven_state)
0000             97   ; assumes that x has current temp value
0000             98   ; new_oven_state is a constant
                 99   temp_gt_threshold MAC
                100           load_y(%0 * 10000)
                101   
                102           lcall x_gt_y
                103           jnb mf, $+3+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
                104           mov OVEN_STATE, %1 
                105           mov seconds_elapsed, #0
                106           ljmp oven_FSM_done
                107   
                108   ENDMAC
0000            109   
                110   temp_lt_threshold MAC
                111           load_y(%0 * 10000)
                112   
                113           lcall x_lt_y
                114           jnb mf, $+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
                115           mov OVEN_STATE, %1 
                116           ljmp oven_FSM_done
                117   
                118   ENDMAC
0000            119   
                121   $LIST
0000            123   
0000            124   ;  N76E003 pinout:
0000            125   ;                               -------
0000            126   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000            127   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000            128   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000            129   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000            130   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000            131   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000            132   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000            133   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000            134   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000            135   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000            136   ;                               -------
0000            137   
0000            138   
0000            139   
0000            140   ;-------------------------------------------------------------------------------------------------------------------------------------
0000            141   
0000            142   ;                                                              STYLE GUIDE
0000            143   
0000            144   ; End flag names with _FLAG
0000            145   ; Use all upper case for constants (anything defined in equ or pin definitions), as it makes it easier to read quickly
0000            146   ; Before any jump or logic block comment purpose and try to comment throughout - code should be self explanatory, comment "why" it was implemented this way
0000            147   ; Before any block of code also comment who wrote it 
0000            148   ; Aim for variable names with 8-20 characters
0000            149   
0000            150   ; --------------------------------------------------------------------------------------------------------------------------
0000            151   
0000            152   
0000            153   ; Timer constants
0000            154   CLK                   EQU 16600000 ; Microcontroller system frequency in Hz
0000            155   BAUD                  EQU 115200   ; Baud rate of UART in bps 
0000            156   TIMER1_RELOAD         EQU (0x100-(CLK/(16*BAUD))) ; Serial ISR
0000            157   TIMER2_RELOAD         EQU (65536-(CLK/1000))      ; 1ms Delay ISR
0000            158   TIMER0_RELOAD         EQU (0x10000-(CLK/4096))    ; Sound ISR For 2kHz square wave
0000            159   
0000            160   ; Pin definitions + Hardware Wiring 
0000            161   ; Layout
0000            162   ; {Start} {Stop} {Change Menu} {Inc Temp} {Inc Time}
0000            163   START_PIN             EQU P1.3 
0000            164   CHANGE_MENU_PIN       EQU P0.1 
0000            165   INC_TEMP_PIN          EQU P0.2  
0000            166   INC_TIME_PIN          EQU P0.3  
0000            167   STOP_PIN              EQU P0.0  
0000            168   SHARED_PIN            EQU P1.5 
0000            169   
0000            170   PWM_OUT               EQU P1.2 ; Pin 13
0000            171   DEFAULT_REFLOW_SETTING      EQU P1.6 ; change to correct pin later if necessary 
0000            172   
0000            173   ; FSM uses integer state encodings
0000            174   ; Menu states
0000            175   MENU_STATE_SOAK       EQU 0
0000            176   MENU_STATE_REFLOW     EQU 1
0000            177   MENU_STATE_TEST       EQU 2
0000            178   
0000            179   ; oven states
0000            180   OVEN_STATE_PREHEAT    EQU 0
0000            181   OVEN_STATE_SOAK       EQU 1
0000            182   OVEN_STATE_RAMP2PEAK  EQU 2
0000            183   OVEN_STATE_REFLOW     EQU 3
0000            184   OVEN_STATE_COOLING    EQU 4
0000            185   OVEN_STATE_FINISHED   EQU 5
0000            186   
0000            187   ; things to keep track of
0000            188   COOLED_TEMP           EQU 50 ; once cooled to this temperature, the reflow is now "finished"
0000            189   COOLED_TEMP_LOAD_MATH EQU COOLED_TEMP*10000 ; use to load up the math
0000            190   FINISHED_SECONDS      EQU 5
0000            191   MAX_SOAK_TIME         EQU 120
0000            192   MAX_REFLOW_TIME       EQU 45
0000            193   MIN_TIME              EQU 15
0000            194   MAX_TEMP              EQU 240
0000            195   MIN_TEMP              EQU 80
0000            196   
0000            197   ; For non-volatile memory
0000            198   PAGE_ERASE_AP         EQU 00100010b
0000            199   BYTE_PROGRAM_AP       EQU 00100001b
0000            200   
0000            201   ; define vectors
0000            202   ORG 0x0000 ; Reset vector
0000 02112E     203           ljmp main_program
0003            204   ORG 0x0003 ; External interrupt 0 vector
0003 32         205           reti
000B            206   ORG 0x000B ; Timer/Counter 0 overflow interrupt vector
000B 020714     207            ljmp Timer0_ISR
0013            208   ORG 0x0013 ; External interrupt 1 vector
0013 32         209            reti
001B            210   ORG 0x001B ; Timer/Counter 1 overflow interrupt vector 
001B 32         211            reti
0023            212   ORG 0x0023 ; Serial port receive/transmit interrupt vector 
0023 32         213            reti
002B            214   ORG 0x002B ; Timer/Counter 2 overflow interrupt vector
002B 020724     215            ljmp Timer2_ISR
002E            216   
002E            217   
002E            218   ; register definitions previously needed by 'math32.inc' - currently commented out for future changes
0030            219   DSEG at 0x30
0030            220   x               : ds 4
0034            221   y               : ds 4
0038            222   z               : ds 4
003C            223   bcd             : ds 5
0041            224   bcdf            : ds 5
0046            225   VLED_ADC        : ds 2
0048            226   
0048            227   OVEN_STATE      : ds 1 ; stores oven FSM state
0049            228   MENU_STATE      : ds 1 ; stores menu FSM state
004A            229   DEFAULT_STATE   : ds 1
004B            230   temp_soak       : ds 1 
004C            231   time_soak       : ds 1
004D            232   temp_refl       : ds 1
004E            233   time_refl       : ds 1
004F            234   ; pwm             : ds 1 ; controls output power to SSR
004F            235   ; pwm_counter     : ds 1 
004F            236   
004F            237   Count1ms        : ds 2 ; determines the number of 1ms increments that have passed 
0051            238   Count1ms0       : ds 2
0053            239   Count1ms_PWM    : ds 1
0054            240   seconds_elapsed  : ds 1
0055            241   exit_seconds    : ds 1 ; if we dont reach 50 c before 60 S terminate
0056            242   total_seconds   : ds 1 ; total runtime
0057            243   
0057            244   pwm_counter: ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0058            245   pwm: ds 1 ; pwm percentage
0059            246   
0059            247   
002E            248   CSEG ;starts the absolute segment from that address
002E            249   ; These 'EQU' must match the hardware wiring
002E            250   LCD_RS          EQU P1.3
002E            251   ;LCD_RW         EQU PX.X ; Not used in this code, connect the pin to GND
002E            252   LCD_E           EQU P1.4
002E            253   LCD_D4          EQU P0.0
002E            254   LCD_D5          EQU P0.1
002E            255   LCD_D6          EQU P0.2
002E            256   LCD_D7          EQU P0.3
002E            257   
002E            258   SOUND_OUT       EQU P0.4
                260   	$LIST
00E2            262   
00E2            263   ; Flags that are used to control events 
0000            264   BSEG 
0000            265   mf                  : dbit 1
0001            266   IN_MENU_FLAG        : dbit 1
0002            267   IN_OVEN_FLAG        : dbit 1
0003            268   REFLOW_FLAG         : dbit 1
0004            269   ENABLE_SEC_INC_FLAG : dbit 1 ; used to control whether seconds incrementing is enabled 
0005            270   TIME_TO_BEEP_FLAG   : dbit 1 ; state transition flag; set to high whenever entering a new state 
0006            271   SYSTEM_DONE_FLAG    : dbit 1 ; used for controlling the final beeping routine
0007            272   BEEP_SECOND_FLAG    : dbit 1
0008            273   
0008            274   ; Variables used for push button mux
0008            275   PB_START_PIN        : dbit 1
0009            276   PB_CHANGE_MENU_PIN  : dbit 1
000A            277   PB_INC_TEMP_PIN     : dbit 1
000B            278   PB_INC_TIME_PIN     : dbit 1
000C            279   PB_STOP_PIN         : dbit 1
000D            280   
                822   $LIST
                282   $LIST
04AD            284   
04AD            285   ; Messages to display on LCD when in Menu FSM
04AD 5265666C   286   LCD_defaultTop  : db 'Reflow Oven:    ', 0
     6F77204F
     76656E3A
     20202020
     00
04BE 53746172   287   LCD_defaultBot  : db 'Start/Configure?', 0
     742F436F
     6E666967
     7572653F
     00
04CF 536F616B   288   LCD_soakTime    : db 'Soak Time: ', 0
     2054696D
     653A2000
04DB 536F616B   289   LCD_soakTemp    : db 'Soak Temp: ', 0
     2054656D
     703A2000
04E7 5265666C   290   LCD_reflowTime  : db 'Refl Time: ', 0
     2054696D
     653A2000
04F3 5265666C   291   LCD_reflowTemp  : db 'Refl Temp: ', 0
     2054656D
     703A2000
04FF 54455354   292   LCD_TEST        : db 'TEST MESSAGE ', 0
     204D4553
     53414745
     2000
050D 20202020   293   LCD_clearLine   : db '                ', 0 ; put at end to clear line
     20202020
     20202020
     20202020
     00
051E            294   
051E 50726568   295   preheatMessage  : db 'Preheat', 0
     65617400
0526 536F616B   296   soakMessage     : db 'Soak', 0
     00
052B 52616D70   297   ramp2peakMessage: db 'Ramp to Peak', 0
     20746F20
     5065616B
     00
0538 5265666C   298   reflowMessage   : db 'Reflow', 0
     6F7700
053F 436F6F6C   299   coolingMessage  : db 'Cooling', 0
     696E6700
0547 46696E69   300   FinishedMessage : db 'Finished!', 0
     73686564
     2100
0551 454D4552   301   stopMessage     : db 'EMERGENCY STOP', 0
     47454E43
     59205354
     4F5000
0560            302   
0560            303   ; -- Debug messages
0560            304   ; seonds_passed   : db 'Seconds: ', 0
0560            305   ; temp            : db 'Temp: ', 0
0560            306   ; ovenState       : db 'State: ', 0
0560            307   ; errorMessage    : db '** ERROR **', 0
0560            308   
0560            309   emergency:
0560 456D6572   310       DB  'Emergency Stop!', '\r', '\n', 0
     67656E63
     79205374
     6F70210D
     0A00
0572            311   
0572            312   soak:
0572 79207661   313       DB  'y val from soak temp: ', 0
     6C206672
     6F6D2073
     6F616B20
     74656D70
     3A2000
0589            314   
0589            315   reflow:
0589 79207661   316       DB  'y val from reflow temp: ',0
     6C206672
     6F6D2072
     65666C6F
     77207465
     6D703A20
     00
05A2            317   
05A2            318   soakTempLog:
05A2 536F616B   319       DB 'Soak Temp: ', 0
     2054656D
     703A2000
05AE            320   
05AE            321   reflowTempLog:
05AE 5265666C   322       DB 'Reflow Temp: ', 0
     6F772054
     656D703A
     2000
05BC            323   
05BC            324   debug:
05BC 21212121   325       DB '!!!!!!!!!', 0
     21212121
     2100
05C6            326   
05C6            327   ;---------------------------------;
05C6            328   ;  Function for saving variables  ;
05C6            329   ;  for non-volatile flash memory  ;
05C6            330   ;---------------------------------;
05C6            331   Save_Variables:
05C6 C2AF       332           CLR EA ; MUST disable interrupts for this to work!
05C8            333           
05C8 75C7AA     334           MOV TA, #0aah ; CHPCON is TA protected
05CB 75C755     335           MOV TA, #55h
05CE 439F01     336           ORL CHPCON, #00000001b ; IAPEN = 1, enable IAP mode
05D1            337           
05D1 75C7AA     338           MOV TA, #0aah ; IAPUEN is TA protected
05D4 75C755     339           MOV TA, #55h
05D7 43A501     340           ORL IAPUEN, #00000001b ; APUEN = 1, enable APROM update
05DA            341           
05DA 75AF22     342           MOV IAPCN, #PAGE_ERASE_AP ; Erase page 3f80h~3f7Fh
05DD 75A73F     343           MOV IAPAH, #3fh
05E0 75A680     344           MOV IAPAL, #80h
05E3 75AEFF     345           MOV IAPFD, #0FFh
05E6 75C7AA     346           MOV TA, #0aah ; IAPTRG is TA protected
05E9 75C755     347           MOV TA, #55h
05EC 43A401     348           ORL IAPTRG, #00000001b ; write 1 to IAPGO to trigger IAP process
05EF            349           
05EF 75AF21     350           MOV IAPCN, #BYTE_PROGRAM_AP
05F2 75A73F     351           MOV IAPAH, #3fh
05F5            352   
05F5            353           ;Load 3f80h with temp_soak
05F5 75A680     354           MOV IAPAL, #80h
05F8 854BAE     355           MOV IAPFD, temp_soak
05FB 75C7AA     356           MOV TA, #0aah
05FE 75C755     357           MOV TA, #55h
0601 43A401     358           ORL IAPTRG,#00000001b
0604            359   
0604            360           ;Load 3f81h with time_soak
0604 75A681     361           MOV IAPAL, #81h
0607 854CAE     362           MOV IAPFD, time_soak
060A 75C7AA     363           MOV TA, #0aah
060D 75C755     364           MOV TA, #55h
0610 43A401     365           ORL IAPTRG,#00000001b
0613            366   
0613            367           ;Load 3f82h with temp_refl
0613 75A682     368           MOV IAPAL, #82h
0616 854DAE     369           MOV IAPFD, temp_refl
0619 75C7AA     370           MOV TA, #0aah
061C 75C755     371           MOV TA, #55h
061F 43A401     372           ORL IAPTRG,#00000001b
0622            373   
0622            374           ;Load 3f82h with time_refl
0622 75A683     375           MOV IAPAL, #83h
0625 854EAE     376           MOV IAPFD, time_refl
0628 75C7AA     377           MOV TA, #0aah
062B 75C755     378           MOV TA, #55h
062E 43A401     379           ORL IAPTRG,#00000001b
0631            380           
0631            381           ;Load 3f84h with 55h
0631 75A684     382           MOV IAPAL,#84h
0634 75AE55     383           MOV IAPFD, #55h
0637 75C7AA     384           MOV TA, #0aah
063A 75C755     385           MOV TA, #55h
063D 43A401     386           ORL IAPTRG, #00000001b
0640            387           
0640            388           ;Load 3f85h with aah
0640 75A685     389           MOV IAPAL, #85h
0643 75AEAA     390           MOV IAPFD, #0aah
0646 75C7AA     391           MOV TA, #0aah
0649 75C755     392           MOV TA, #55h
064C 43A401     393           ORL IAPTRG, #00000001b
064F 75C7AA     394           MOV TA, #0aah
0652 75C755     395           MOV TA, #55h
0655 53A5FE     396           ANL IAPUEN, #11111110b ; APUEN = 0, disable APROM update
0658 75C7AA     397           MOV TA, #0aah
065B 75C755     398           MOV TA, #55h
065E 539FFE     399           ANL CHPCON, #11111110b ; IAPEN = 0, disable IAP mode
0661            400           
0661 D2AF       401           setb EA ; Re-enable interrupts
0663            402           
0663 22         403           ret
0664            404   
0664            405   
0664            406   ;-----------------------;
0664            407   ; Function for loading  ;
0664            408   ;       variables       ;
0664            409   ;-----------------------;
0664            410   Load_Variables:
0664 903F84     411           mov dptr, #0x3f84 ; First key value location. Must be 0x55
0667 E4         412           clr a
0668 93         413           movc a, @a+dptr
0669 B4551D     414           cjne a, #0x55, Load_Defaults
066C A3         415           inc dptr ; Second key value location. Must be 0xaa
066D E4         416           clr a
066E 93         417           movc a, @a+dptr
066F B4AA17     418           cjne a, #0xaa, Load_Defaults
0672            419           
0672 903F80     420           mov dptr, #0x3f80
0675 E4         421           clr a
0676 93         422           movc a, @a+dptr
0677 F54B       423           mov temp_soak, a
0679            424           
0679 A3         425           inc dptr
067A E4         426           clr a
067B 93         427           movc a, @a+dptr
067C F54C       428           mov time_soak, a
067E            429           
067E A3         430           inc dptr
067F E4         431           clr a
0680 93         432           movc a, @a+dptr
0681 F54D       433           mov temp_refl, a
0683            434           
0683 A3         435           inc dptr
0684 E4         436           clr a
0685 93         437           movc a, @a+dptr
0686 F54E       438           mov time_refl, a
0688            439           
0688 22         440           ret
0689            441   
0689            442   Load_Defaults:
0689 754B50     443           mov temp_soak, #MIN_TEMP ; change to correct default later
068C 754C0F     444           mov time_soak, #MIN_TIME ; change to correct default later
068F 754D78     445           mov temp_refl, #120      ; change to correct default later
0692 754E0F     446           mov time_refl, #MIN_TIME ; change to correct default later
0695            447           
0695 22         448           ret
0696            449   
0696            450   
0696            451   ; Messages to display on LCD when in Oven Controller FSM
0696            452   
0696            453   ; Send a character using the serial port
0696            454   putchar:
0696 3099FD     455           jnb     TI, putchar
0699 C299       456           clr     TI
069B F599       457           mov     SBUF, a
069D 22         458           ret
069E            459   
069E            460   ; Send a constant-zero-terminated string using the serial port
069E            461   SendString:
069E E4         462           clr     A
069F 93         463           movc    A, @A+DPTR
06A0 6006       464           jz      SendStringDone
06A2 120696     465           lcall   putchar
06A5 A3         466           inc     DPTR
06A6 80F6       467           sjmp    SendString
06A8            468   SendStringDone:
06A8 22         469           ret
06A9            470   
06A9            471   ; Eight bit number to display passed in ï¿½aï¿½.
06A9            472   SendToLCD:
06A9 75F064     473           mov     b, #100
06AC 84         474           div     ab
06AD 4430       475           orl     a, #0x30 ; Convert hundreds to ASCII
06AF 12007D     476           lcall   ?WriteData ; Send to LCD
06B2 E5F0       477           mov     a, b ; Remainder is in register b
06B4 75F00A     478           mov     b, #10
06B7 84         479           div     ab
06B8 4430       480           orl     a, #0x30 ; Convert tens to ASCII
06BA 12007D     481           lcall   ?WriteData; Send to LCD
06BD E5F0       482           mov     a, b
06BF 4430       483           orl     a, #0x30 ; Convert units to ASCII
06C1 12007D     484           lcall   ?WriteData; Send to LCD
06C4 22         485           ret
06C5            486   
06C5            487   ; Eight bit number to display passed in ï¿½aï¿½.
06C5            488   SendToSerialPort:
06C5 75F064     489           mov     b, #100
06C8 84         490           div     ab
06C9 4430       491           orl     a, #0x30 ; Convert hundreds to ASCII
06CB 120696     492           lcall   putchar ; Send to PuTTY/Python/Matlab
06CE E5F0       493           mov     a, b ; Remainder is in register b
06D0 75F00A     494           mov     b, #10
06D3 84         495           div     ab
06D4 4430       496           orl     a, #0x30 ; Convert tens to ASCII
06D6 120696     497           lcall   putchar ; Send to PuTTY/Python/Matlab
06D9 E5F0       498           mov     a, b
06DB 4430       499           orl     a, #0x30 ; Convert units to ASCII
06DD 120696     500           lcall   putchar ; Send to PuTTY/Python/Matlab
06E0 22         501           ret
06E1            502   
06E1            503   ;---------------------------------;
06E1            504   ; Routine to initialize the ISR   ;
06E1            505   ; for timer 0                     ;
06E1            506   ;---------------------------------;
06E1            507   Timer0_Init:
06E1 438E08     508            orl     CKCON, #0b00001000 ; Input for timer 0 is sysclk/1 ; performs bit masking on CKON - Clock Control ; T0M = 1, timer 0 uses the system clock directly
06E4 E589       509            mov     a, TMOD
06E6 54F0       510            anl     a, #0xf0 ; 11110000 Clear the bits for timer 0
06E8 4401       511            orl     a, #0x01 ; 00000001 Configure timer 0 as 16-timer (M1M0 = 01 -> Mode 1: 16-bit Timer/Counter)
06EA F589       512            mov     TMOD, a
06EC 758CF0     513            mov     TH0, #high(TIMER0_RELOAD) ; 8051 works with 8 bits so the oepration T0 = TIMER0_RELOAD  (16 bits) is done by setting high byte then low byte (8x2)
06EF 758A2C     514            mov     TL0, #low (TIMER0_RELOAD)
06F2            515            ; Enable the timer and interrupts
06F2 D2A9       516           setb    ET0  ; Enable timer 0 interrupt
06F4 D28C       517           setb    TR0  ; Start timer 0
06F6 22         518            ret
06F7            519   
06F7            520   ;---------------------------------;
06F7            521   ; Routine to initialize the ISR   ;
06F7            522   ; for timer 2                     ;
06F7            523   ;---------------------------------;
06F7            524   Timer2_Init:
06F7 75C800     525            mov     T2CON, #0 ; Stop timer/counter.  Autoreload mode.
06FA 75CDBF     526            mov     TH2, #high(TIMER2_RELOAD)
06FD 75CC28     527            mov     TL2, #low(TIMER2_RELOAD)
0700            528            ; Set the reload value
0700 43C980     529            orl     T2MOD, #0x80 ; Enable timer 2 autoreload
0703 75CBBF     530            mov     RCMP2H, #high(TIMER2_RELOAD)
0706 75CA28     531            mov     RCMP2L, #low(TIMER2_RELOAD)
0709            532            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0709 E4         533            clr     a
070A F54F       534            mov     Count1ms+0, a
070C F550       535            mov     Count1ms+1, a
070E            536            ; Enable the timer and interrupts
070E 439B80     537            orl     EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0711 D2CA       538           setb    TR2  ; Enable timer 2
0713 22         539            ret
0714            540   
0714            541   Timer0_ISR: 
0714            542           ;clr TF0  ; According to the data sheet this is done for us already.
0714            543            ; Timer 0 doesn't have 16-bit auto-reload, so
0714 C28C       544            clr TR0
0716            545           
0716 758CF0     546            mov TH0, #high(TIMER0_RELOAD)
0719 758A2C     547            mov TL0, #low(TIMER0_RELOAD)
071C D28C       548            setb TR0
071E            549   
071E            550   
071E 300502     551           jnb TIME_TO_BEEP_FLAG, Early_Exit
0721 B284       552            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0723            553   
0723            554       Early_Exit:
0723            555    
0723 32         556           reti
0724            557   
0724            558   ;---------------------------------;
0724            559   ; ISR for timer 2                 ;
0724            560   ;---------------------------------;
0724            561   Timer2_ISR:
0724 C2CF       562           clr     TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0726            563           ; cpl     P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0726            564   
0726            565           ; The two registers used in the ISR must be saved in the stack
0726 C0E0       566           push    acc
0728 C0D0       567           push    psw
072A            568   
072A 0553       569           inc     Count1ms_PWM   ; variable used to count every 10ms used for the PWM
072C            570   
072C            571           ; Increment the 16-bit one mili second counter
072C 054F       572           inc     Count1ms+0    ; Increment the low 8-bits first
072E E54F       573           mov     a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0730 7002       574           jnz     Inc_done
0732 0550       575           inc     Count1ms+1    
0734            576   
0734            577   
0734            578   
0734            579           Inc_done:
0734            580           ; If not in oven, skip PWM
0734 30021D     581           jnb    IN_OVEN_FLAG, skipPWM
0737 E553       582           mov    a, Count1ms_PWM ; 
0739            583   
0739            584   
0739            585           ; This check is done so that this subroutine executes every 10ms 
0739 B40A18     586           cjne    a, #10, check10msPassed 
073C 755300     587                   mov Count1ms_PWM, #0
073F            588                   ;GL PWM code that Jesus gave
073F            589                   ;RK working on PWM
073F 0557       590                   inc     pwm_counter
0741 C3         591                   clr     c
0742 E558       592                   mov     a, pwm
0744 9557       593                   subb    a, pwm_counter ; If pwm_counter <= pwm then c=1
0746 B3         594                   cpl     c
0747 9292       595                   mov     PWM_OUT, c 
0749 E557       596                   mov     a, pwm_counter
074B            597                   ; cjne    a, #100, Timer2_ISR_done ; why does this go to Timer2_ISR_done? - GL
074B B46406     598                   cjne    a, #100, check10msPassed ; changed label from `Timer2_ISR_done` to `check10msPassed`
074E 755700     599                   mov     pwm_counter, #0
0751            600   
0751 E4         601                   clr     a
0752 F553       602                   mov     Count1ms_PWM, a ; reset the 1ms for PWM counter
0754            603           
0754            604                   
0754            605           check10msPassed:
0754            606           skipPWM:
0754            607           ; Check if one second has passed
0754 E54F       608            mov     a, Count1ms+0
0756 B4E82D     609            cjne    a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0759 E550       610            mov     a, Count1ms+1
075B B40328     611            cjne    a, #high(1000), Timer2_ISR_done         
075E            612   
075E            613           ; ---  1s has passed ----
075E C205       614           clr   TIME_TO_BEEP_FLAG
0760 120847     615           lcall DO_TEMP_READ
0763 1200E2     616           lcall hex2bcd ; puts value of x into BCD
0766 1208BA     617           lcall send_temp_to_serial ; puts BCD values onto serial
0769            618           
0769 E4         619           clr     a
076A F54F       620           mov     Count1ms+0, a
076C F550       621           mov     Count1ms+1, a
076E            622           
076E            623           ; -------- Log File -------
076E            624           ;mov a,  PWM
076E            625           ;lcall   SendToSerialPort
076E            626           ;mov a,  #'\r' ; Return character
076E            627           ;lcall   putchar
076E            628           ;mov a,  #'\n' ; New-line character
076E            629           ;lcall   putchar
076E            630   
076E            631           ; mov a,  seconds_elapsed
076E            632           ; lcall   SendToSerialPort
076E            633           ; mov a,  #'\r' ; Return character
076E            634           ; lcall   putchar
076E            635           ; mov a,  #'\n' ; New-line character
076E            636           ; lcall   putchar
076E            637   
076E            638           ; mov a, OVEN_STATE
076E            639           ; add A, #1
076E            640           ; mov OVEN_STATE, a
076E            641   
076E            642           ; mov DPTR, #soakTempLog
076E            643           ; lcall SendString
076E            644           ; mov a, temp_soak
076E            645           ; lcall SendToSerialPort
076E            646           ; mov a,  #'\r' ; Return character
076E            647           ; lcall   putchar
076E            648           ; mov a,  #'\n' ; New-line character
076E            649           ; lcall   putchar
076E            650   
076E            651           ; mov DPTR, #reflowTempLog
076E            652           ; lcall SendString
076E            653           ; mov a, temp_refl
076E            654           ; lcall SendToSerialPort
076E            655           ; mov a,  #'\r' ; Return character
076E            656           ; lcall   putchar
076E            657           ; mov a,  #'\n' ; New-line character
076E            658           ; lcall   putchar
076E            659   
076E 300306     660           jnb     REFLOW_FLAG,  not_in_reflow ;Checks if we are in reflow state
0771 E555       661           mov     a, exit_seconds             ;Increments the early exit seconds counter
0773 2401       662           add     a, #1
0775 F555       663           mov     exit_seconds, a
0777            664           
0777            665    not_in_reflow:
0777            666           ; Check a flag for inc. seconds, otherwise go to end of timer, Timer2_ISR_done label used to save a line
0777 30040C     667           jnb     ENABLE_SEC_INC_FLAG, Timer2_ISR_done
077A E554       668           mov     a, seconds_elapsed
077C 2401       669           add     A, #1
077E F554       670           mov     seconds_elapsed, a
0780 E556       671           mov     a, total_seconds
0782 2401       672           add     a, #1
0784 F556       673           mov     total_seconds, a
0786            674           
0786            675           Timer2_ISR_done:
0786            676           ; reset seconds ms counter
0786            677           
0786 D0D0       678           pop     psw
0788 D0E0       679            pop     acc
078A 32         680           reti
078B            681   
078B            682   
078B            683   Display_formated_BCD:
078B C0E0       684            push acc
078D 7401       684            mov a, #1
078F 14         684            dec a
0790 1200C5     684            lcall ?Set_Cursor_2 ; Select column and row
0793 D0E0       684            pop acc
0795 C000       685            push ar0
0797 A83F       685            mov r0, bcd+3
0799 1200CC     685            lcall ?Display_BCD
079C D000       685            pop ar0
079E C000       686            push ar0
07A0 A83E       686            mov r0, bcd+2
07A2 1200CC     686            lcall ?Display_BCD
07A5 D000       686            pop ar0
07A7 C0E0       687            push acc
07A9 742E       687            mov a, #'.'
07AB 12007D     687            lcall ?WriteData
07AE D0E0       687            pop acc
07B0 C000       688            push ar0
07B2 A83D       688            mov r0, bcd+1
07B4 1200CC     688            lcall ?Display_BCD
07B7 D000       688            pop ar0
07B9 C000       689            push ar0
07BB A83C       689            mov r0, bcd+0
07BD 1200CC     689            lcall ?Display_BCD
07C0 D000       689            pop ar0
07C2 22         690   ret
07C3            691   
07C3            692   
07C3            693   InitSerialPort:
07C3            694       ; Since the reset button bounces, we need to wait a bit before
07C3            695       ; sending messages, otherwise we risk displaying gibberish!
07C3 79C8       696       mov R1, #200
07C5 7868       697       mov R0, #104
07C7 D8FE       698       djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
07C9 D9FA       699       djnz R1, $-4 ; 25us*200=5.0ms
07CB            700   
07CB            701       ; Now we can proceed with the configuration of the serial port
07CB 438E10     702            orl     CKCON, #0x10 ; CLK is the input for timer 1
07CE 438780     703            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
07D1 759852     704            mov     SCON, #0x52
07D4 53C4DF     705            anl     T3CON, #0b11011111
07D7 53890F     706            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
07DA 438920     707            orl     TMOD, #0x20 ; Timer 1 Mode 2
07DD 758DF7     708            mov     TH1, #TIMER1_RELOAD
07E0 D28E       709            setb    TR1
07E2 22         710           ret
07E3            711           
07E3            712   ;jesus' beautiful averaging code, can be used in place of Read_ADC in place where we read
07E3            713   Average_ADC:
07E3 753000     714            mov x+0, #low (0 % 0x10000) 
07E6 753100     714            mov x+1, #high(0 % 0x10000) 
07E9 753200     714            mov x+2, #low (0 / 0x10000) 
07EC 753300     714            mov x+3, #high(0 / 0x10000) 
07EF 7D64       715           mov R5, #100
07F1 7E64       716           mov R6, #100
07F3            717   
07F3            718           Sum_loop0:
07F3 12082C     719           lcall Read_ADC
07F6 753700     720           mov y+3, #0
07F9 753600     721           mov y+2, #0
07FC 8935       722           mov y+1, R1
07FE 8834       723           mov y+0, R0
0800            724   
0800 C030       725           push x
0802 7530FC     726            mov x+0, #low (34300 % 0x10000) 
0805 753185     726            mov x+1, #high(34300 % 0x10000) 
0808 753200     726            mov x+2, #low (34300 / 0x10000) 
080B 753300     726            mov x+3, #high(34300 / 0x10000) 
080E 1202B7     727           lcall x_lteq_y
0811 200007     728           jb mf, skipval
0814 D030       729           pop x
0816            730   
0816 1201A7     731           lcall add32
0819 DDD8       732           djnz R5, Sum_loop0
081B            733   
081B            734           skipval:
081B DED6       735                  djnz R6, Sum_loop0
081D            736   
081D            737           ;load_y(100)
081D 753700     738           mov y+3, #0
0820 753600     739           mov y+2, #0
0823 753500     740           mov y+1, #0
0826 8E34       741           mov y+0, R6
0828 1203DB     742           lcall div32
082B 22         743           ret
082C            744   
082C            745   
082C            746   Read_ADC:
082C C2EF       747           clr ADCF
082E D2EE       748           setb ADCS ;  ADC start trigger signal
0830 30EFFD     749           jnb ADCF, $ ; Wait for conversion complete
0833            750           
0833            751           ; Read the ADC result and store in [R1, R0]
0833 E5C2       752           mov a, ADCRL
0835 540F       753           anl a, #0x0f
0837 F8         754           mov R0, a
0838 E5C3       755           mov a, ADCRH  
083A C4         756           swap a
083B C0E0       757           push acc
083D 540F       758           anl a, #0x0f
083F F9         759           mov R1, a
0840 D0E0       760           pop acc
0842 54F0       761           anl a, #0xf0
0844 48         762           orl a, R0
0845 F8         763           mov R0, A
0846 22         764   ret
0847            765   
0847            766   DO_TEMP_READ:
0847            767           ;push x
0847            768           ; Read the 2.08V LED voltage connected to AIN0 on pin 6
0847 53E8F0     769           anl ADCCON0, #0xF0
084A 43E800     770           orl ADCCON0, #0x00 ; Select channel 0
084D            771   
084D 12082C     772           lcall Read_ADC
0850            773           ; Save result for later use
0850 8846       774           mov VLED_ADC+0, R0
0852 8947       775           mov VLED_ADC+1, R1
0854            776   
0854            777           ; Read the signal connected to AIN7
0854 53E8F0     778           anl ADCCON0, #0xF0
0857 43E807     779           orl ADCCON0, #0x07 ; Select channel 7
085A            780           ;lcall Read_ADC
085A 1207E3     781           lcall Average_ADC ;using in place of Read_ADC function, takes 100 measurements and averages
085D            782                             ;fairly instantaneous reading 
085D            783   
085D            784           ; Convert to voltage
085D 8830       785           mov x+0, R0
085F 8931       786           mov x+1, R1
0861            787           ; Pad other bits with zero
0861 753200     788           mov x+2, #0
0864 753300     789           mov x+3, #0
0867 753414     790            mov y+0, #low (20500 % 0x10000) 
086A 753550     790            mov y+1, #high(20500 % 0x10000) 
086D 753600     790            mov y+2, #low (20500 / 0x10000) 
0870 753700     790            mov y+3, #high(20500 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
0873 1202C1     791           lcall mul32
0876            792           ; Retrive the ADC LED value
0876 854634     793           mov y+0, VLED_ADC+0
0879 854735     794           mov y+1, VLED_ADC+1
087C            795           ; Pad other bits with zero
087C 753600     796           mov y+2, #0
087F 753700     797           mov y+3, #0
0882 1203DB     798           lcall div32 ; x stores thermocouple voltage
0885            799   
0885 753450     800            mov y+0, #low (80 % 0x10000) 
0888 753500     800            mov y+1, #high(80 % 0x10000) 
088B 753600     800            mov y+2, #low (80 / 0x10000) 
088E 753700     800            mov y+3, #high(80 / 0x10000)  ; shouldn't this be 27300 and a subtraction
0891 1202C1     801           lcall mul32
0894            802   
0894            803   ;         ; code to use temp sensor for amb temp
0894            804   ;         ;push x
0894            805   ; ;
0894            806   ;         anl ADCCON0, #0xF0
0894            807   ;         orl ADCCON0, #0x01 ; Select channel 1, pin 5
0894            808   ;         lcall READ_ADC 
0894            809   ; ;
0894            810   ;         mov z+0, R0
0894            811   ;         mov z+1, R1
0894            812   ;         ;; Pad other bits with zero
0894            813   ;         mov z+2, #0
0894            814   ;         mov z+3, #0
0894            815   ;         Load_y(20500) ; The MEASURED LED voltage: 2.074V, with 4 decimal places
0894            816   ;         lcall mul32z  ;
0894            817   ;         ;; Retrive the ADC LED value
0894            818   ;         mov y+0, VLED_ADC+0
0894            819   ;         mov y+1, VLED_ADC+1
0894            820   ;         ;; Pad other bits with zero
0894            821   ;         mov y+2, #0
0894            822   ;         mov y+3, #0
0894            823   ;         lcall div32z ; new func
0894            824   ; ;
0894            825   ;         ;load_y(100)
0894            826   ;         ;lcall mul32z
0894            827   ;         ;
0894            828   ;         ;
0894            829   ;         load_y(27300)
0894            830   ;         lcall sub32z  
0894            831   ; ;
0894            832   ;         mov y+0, z+0
0894            833   ;         mov y+1, z+1
0894            834   ;         mov y+2, z+2
0894            835   ;         mov y+3, z+3
0894            836   ;
0894            837           ;lcall hex2bcd
0894            838           ;lcall send_temp_to_serial
0894            839   ;
0894            840           ;pop x
0894            841           
0894 753460     842            mov y+0, #low (220000 % 0x10000) 
0897 75355B     842            mov y+1, #high(220000 % 0x10000) 
089A 753603     842            mov y+2, #low (220000 / 0x10000) 
089D 753700     842            mov y+3, #high(220000 / 0x10000)  ;adding 22, will change to ambient later
08A0 1201A7     843           lcall add32
08A3            844   
08A3 22         845           ret
08A4            846   
08A4            847   ;---------------------------------;
08A4            848   ;  Send a BCD number to PuTTY     ;
08A4            849   ;---------------------------------;
                850   Send_BCD mac
                851   	push    ar0
                852   	mov     r0, %0
                853   	lcall   ?Send_BCD
                854   	pop     ar0
                855   	endmac
08A4            856            ?Send_BCD:
08A4 C0E0       857                   push    acc
08A6            858                   ; Write most significant digit
08A6 E8         859                   mov     a, r0
08A7 C4         860                   swap    a
08A8 540F       861                   anl     a, #0fh
08AA 4430       862                   orl     a, #30h
08AC 120696     863                   lcall   putchar
08AF            864                   ; write least significant digit
08AF E8         865                   mov     a, r0
08B0 540F       866                   anl     a, #0fh
08B2 4430       867                   orl     a, #30h
08B4 120696     868                   lcall   putchar
08B7 D0E0       869                   pop     acc
08B9 22         870   ret
08BA            871   
08BA            872   ; oven_FSM_LCD_DISPLAY (message)
08BA            873   ; Params
08BA            874   ;       message - constant string dataByte
                875   oven_FSM_LCD_DISPLAY MAC
                876           ; Display mode and temperature on line 1
                877           Set_Cursor(1,1)
                878           Send_Constant_String(%0)
                879           Send_Constant_String(#LCD_clearLine)
                880   
                881           ; display seconds on line 2
                882           Set_Cursor(2, 1)
                883           mov     a, seconds_elapsed
                884   ENDMAC
08BA            885   
08BA            886   ; Sends the BCD value
08BA            887   send_temp_to_serial:
08BA            888           ; Sends temperature
08BA C000       889            push    ar0
08BC A83F       889            mov     r0, bcd+3
08BE 1208A4     889            lcall   ?Send_BCD
08C1 D000       889            pop     ar0
08C3 C000       890            push    ar0
08C5 A83E       890            mov     r0, bcd+2
08C7 1208A4     890            lcall   ?Send_BCD
08CA D000       890            pop     ar0
08CC 742E       891           mov a, #'.'
08CE 120696     892           lcall putchar
08D1 C000       893            push    ar0
08D3 A83D       893            mov     r0, bcd+1
08D5 1208A4     893            lcall   ?Send_BCD
08D8 D000       893            pop     ar0
08DA C000       894            push    ar0
08DC A83C       894            mov     r0, bcd+0
08DE 1208A4     894            lcall   ?Send_BCD
08E1 D000       894            pop     ar0
08E3            895   
08E3            896           ; Sends soak time, soak temp, reflow time, reflow temp
08E3 E54C       897           mov a, time_soak
08E5 1206C5     898           lcall SendToSerialPort 
08E8 E54B       899           mov a, temp_soak
08EA 1206C5     900           lcall SendToSerialPort 
08ED E54E       901           mov a, time_refl
08EF 1206C5     902           lcall SendToSerialPort 
08F2 E54D       903           mov a, temp_refl
08F4 1206C5     904           lcall SendToSerialPort 
08F7            905   
08F7 740D       906           mov a,  #'\r' ; Return character
08F9 120696     907           lcall   putchar
08FC 740A       908           mov a,  #'\n' ; New-line character
08FE 120696     909           lcall   putchar
0901            910   
0901 22         911           ret 
0902            912   
0902            913   INIT_ALL:
0902            914           ; Configure pins to be bi-directional
0902 75AC00     915           mov      P3M1,#0x00
0905 75AD00     916            mov     P3M2,#0x00
0908 75B300     917            mov     P1M1,#0x00
090B 75B400     918            mov     P1M2,#0x00
090E 75B100     919            mov     P0M1,#0x00
0911 75B200     920            mov     P0M2,#0x00
0914            921   
0914 D281       922           setb    CHANGE_MENU_PIN
0916 D293       923           setb    START_PIN
0918            924   
0918 D2AF       925           setb    EA   ; Enable Global interrupts
091A 1206E1     926           lcall   Timer0_Init
091D 1206F7     927           lcall   Timer2_Init
0920            928   
0920            929           ; Since the reset button bounces, we need to wait a bit before
0920            930           ; sending messages, otherwise we risk displaying gibberish!
0920 C002       931            push AR2
0922 7A32       931            mov R2, #50
0924 120038     931            lcall ?Wait_Milli_Seconds
0927 D002       931            pop AR2
0929            932   
0929            933           ; Now we can proceed with the configuration of the serial port
0929 438E10     934           orl      CKCON, #0x10 ; CLK is the input for timer 1
092C 438780     935           orl      PCON, #0x80  ; Bit SMOD=1, double baud rate
092F 759852     936           mov      SCON, #0x52
0932 53C4DF     937           anl      T3CON, #0b11011111
0935 53890F     938           anl      TMOD, #0x0F ; Clear the configuration bits for timer 1
0938 438920     939           orl      TMOD, #0x20 ; Timer 1 Mode 2
093B 758DF7     940           mov      TH1, #TIMER1_RELOAD
093E D28E       941           setb    TR1
0940            942   
0940            943           ; ? ? ? ? ? ? ? ? ? ? ? SUS  ? ? ? ? ? ? ? ? ? ? ? ? ?   
0940            944           ; works on its own from lab3, might interfere with other stuff though       ; NOTE TIMER ZERO HAS NOT YET BEEN TESTED       
0940            945           ; Using timer 0 for delay functions.  Initialize here:
0940            946            ;clr    TR0         ; Stop timer 0
0940            947            ;orl    CKCON,#0x08 ; CLK is the input for timer 0
0940            948            ;anl    TMOD,#0xF0  ; Clear the configuration bits for timer 0
0940            949            ;orl    TMOD,#0x01  ; Timer 0 in Mode 1: 16-bit timer
0940            950           ; ^ ^ ^ ^ ^ ^ ^ ^^ ^ ^ ^ ^ ^^ ^ ^ ^ ^^ ^ ^ ^   
0940            951            
0940            952            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
0940 43B382     953            orl     P1M1, #0b10000010
0943 53B47D     954            anl     P1M2, #0b01111101
0946            955            
0946            956            ; Initialize and start the ADC:
0946 53E8F0     957            anl     ADCCON0, #0xF0
0949 43E807     958            orl     ADCCON0, #0x07 ; Select channel 7
094C            959            
094C            960           ; AINDIDS select if some pins are analog inputs or digital I/O:
094C 75F600     961            mov     AINDIDS, #0x00 ; Disable all analog inputs
094F 43F681     962            orl     AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
0952 43E101     963            orl     ADCCON1, #0x01 ; Enable ADC
0955            964   
0955            965           ; Menu Configuration
0955 C201       966           clr     IN_MENU_FLAG
0957 C202       967           clr     IN_OVEN_FLAG
0959 7400       968           mov     a, #0
095B F549       969           mov     MENU_STATE, a ; set menu state to 0 
095D            970   
095D            971           ; mov     temp_soak, #0x250
095D 754B50     972           mov     temp_soak, #MIN_TEMP ; 80
0960 754C0F     973           mov     time_soak, #MIN_TIME
0963 754D78     974           mov     temp_refl, #120
0966 754E0F     975           mov     time_refl, #MIN_TIME
0969            976           
0969            977           ; Oven configuration
0969 754800     978           mov     OVEN_STATE, #OVEN_STATE_PREHEAT
096C 755400     979           mov     seconds_elapsed, #0
096F 755800     980           mov     PWM, #0
0972 755300     981           mov     Count1ms_PWM, #0
0975 755500     982           mov     exit_seconds, #0
0978 755600     983           mov     total_seconds, #0
097B C203       984           clr     REFLOW_FLAG
097D C204       985           clr     ENABLE_SEC_INC_FLAG ; flag is set to zero so that seconds won't increment
097F C205       986           clr     TIME_TO_BEEP_FLAG   ; flag is one when we switch states (i.e will beep)
0981            987   
0981 D2CA       988           setb    TR2
0983            989   
0983            990           ; clear x
0983 753000     991           mov x+0, #0
0986 753100     992           mov x+1, #0
0989 753200     993           mov x+2, #0
098C 753300     994           mov x+3, #0
098F            995   
098F            996           
098F 22         997           ret
0990            998   
0990            999   STOP_PROCESS:
0990           1000           ; Turn everything off
0990           1001          
0990 C292      1002           clr     PWM_OUT
0992 C203      1003           clr     REFLOW_FLAG
0994 C202      1004           clr     IN_OVEN_FLAG
0996 C201      1005           clr     IN_MENU_FLAG
0998 754800    1006           MOV     OVEN_STATE, #OVEN_STATE_PREHEAT
099B 755400    1007           MOV     seconds_elapsed, #0
099E 755300    1008           mov     Count1ms_PWM, #0
09A1 755500    1009           mov     exit_seconds, #0
09A4 755600    1010           mov     total_seconds, #0
09A7 755800    1011           MOV     pwm, #0
09AA 755700    1012           MOV     pwm_counter, #0
09AD 753000    1013           mov x+0, #0
09B0 753100    1014           mov x+1, #0
09B3 753200    1015           mov x+2, #0
09B6 753300    1016           mov x+3, #0
09B9           1017   
09B9           1018           ; Do not disable TR2, otherwise temperature will no longer be sent to serial
09B9           1019           ; clr     TR2 ; disable timer 2 so that it doesn't count up in background ; 
09B9 C204      1020           clr     ENABLE_SEC_INC_FLAG ; 
09BB 021139    1021           ljmp    PROGRAM_ENTRY
09BE           1022   
09BE           1023   ; Precondition: Has temperature stored in BCD
09BE           1024   ; States
09BE           1025   ;       Preheat --> Soak --> Ramp to Peak --> Reflow --> Cooling --> Finished ----> EXIT
09BE           1026   ;
09BE           1027   ; Exit conditions
09BE           1028   ;       1. Early exit  - Stop button pressed
09BE           1029   ;       2. Early exit  - Temp threshold not reached after 60s
09BE           1030   ;       3. Normal exit - End of FSM reached 
09BE           1031   ;
09BE           1032   ; State Layout
09BE           1033   ;    state_label
09BE           1034   ;       if OVEN_STATE != state,  jmp
09BE           1035   ;       display on time and temp LCD
09BE           1036   OVEN_FSM:
09BE C002      1037            push AR2
09C0 7A32      1037            mov R2, #50
09C2 120038    1037            lcall ?Wait_Milli_Seconds
09C5 D002      1037            pop AR2                                 
09C7           1038   
09C7 D208      1039           setb PB_START_PIN
09C9 D209      1039           setb PB_CHANGE_MENU_PIN
09CB D20A      1039           setb PB_INC_TEMP_PIN
09CD D20B      1039           setb PB_INC_TIME_PIN
09CF D20C      1039           setb PB_STOP_PIN
09D1           1039           
09D1 D295      1039           setb SHARED_PIN
09D3           1039           ; check if any push buttons are pressed
09D3 C293      1039           clr START_PIN             
09D5 C281      1039           clr CHANGE_MENU_PIN       
09D7 C282      1039           clr INC_TEMP_PIN          
09D9 C283      1039           clr INC_TIME_PIN          
09DB C280      1039           clr STOP_PIN
09DD           1039   
09DD           1039           ; debounce
09DD 209502    1039           jb SHARED_PIN, $+2+3 ; use helper label to jump to the end
09E0 8003      1039           sjmp $+2+3
09E2 020A35    1039           ljmp enterOvenStateCheck
09E5 C002      1039            push AR2
09E7 7A32      1039            mov R2, #50
09E9 120038    1039            lcall ?Wait_Milli_Seconds
09EC D002      1039            pop AR2
09EE 209502    1039           jb SHARED_PIN, $+2+3
09F1 8003      1039           sjmp $+2+3
09F3 020A35    1039           ljmp enterOvenStateCheck
09F6           1039   
09F6           1039           ; Set the LCD data pins to logic 1
09F6 D293      1039           setb START_PIN
09F8 D281      1039           setb CHANGE_MENU_PIN
09FA D282      1039           setb INC_TEMP_PIN
09FC D283      1039           setb INC_TIME_PIN
09FE D280      1039           setb STOP_PIN
0A00           1039   
0A00           1039           ; check push buttons 1 by one
0A00 C293      1039           clr START_PIN
0A02 A295      1039           mov c, SHARED_PIN
0A04 9208      1039           mov PB_START_PIN, c
0A06 D293      1039           setb START_PIN
0A08           1039   
0A08 C281      1039           clr CHANGE_MENU_PIN
0A0A A295      1039           mov c, SHARED_PIN
0A0C 9209      1039           mov PB_CHANGE_MENU_PIN, c
0A0E D281      1039           setb CHANGE_MENU_PIN
0A10           1039   
0A10 C282      1039           clr INC_TEMP_PIN
0A12 A295      1039           mov c, SHARED_PIN
0A14 920A      1039           mov PB_INC_TEMP_PIN, c
0A16 D282      1039           setb INC_TEMP_PIN
0A18           1039   
0A18 C283      1039           clr INC_TIME_PIN
0A1A A295      1039           mov c, SHARED_PIN
0A1C 920B      1039           mov PB_INC_TIME_PIN, c
0A1E D283      1039           setb INC_TIME_PIN
0A20           1039   
0A20 C280      1039           clr STOP_PIN
0A22 A295      1039           mov c, SHARED_PIN
0A24 920C      1039           mov PB_STOP_PIN, c
0A26 D280      1039           setb STOP_PIN
0A28           1039   
0A28           1039           ; jb PB_STOP_PIN, enterOvenStateCheck ; check that the variable flag is not 1, otherwise jmp
0A28           1039   
0A28 200C02    1039           jb PB_STOP_PIN, $+2+3 ; check that the variable flag is not 1, otherwise jmp
0A2B 8003      1039           sjmp $+2+3
0A2D 020A35    1039           ljmp enterOvenStateCheck     ; can access anypart of the code
0A30           1039       
0A30 D205      1040           setb    TIME_TO_BEEP_FLAG
0A32 120990    1041           lcall   STOP_PROCESS
0A35           1042   
0A35           1043           ; check oven state if stop button is not pressed
0A35           1044           enterOvenStateCheck:
0A35 E548      1045                   mov  a, OVEN_STATE
0A37           1046                           
0A37           1047                   ; emergency exit if temperature > 240 degrees
0A37           1048                   ; checks if temp is valid first (< 300 degrees)
0A37 7534C0    1049            mov y+0, #low (3000000 % 0x10000) 
0A3A 7535C6    1049            mov y+1, #high(3000000 % 0x10000) 
0A3D 75362D    1049            mov y+2, #low (3000000 / 0x10000) 
0A40 753700    1049            mov y+3, #high(3000000 / 0x10000) 
0A43 12026B    1050                   lcall x_gt_y               ; sets mf to 1 if x > 300 degrees
0A46 200074    1051                   jb mf, ovenFSM_preheat ; jmp to state check if temperature is invalid
0A49           1052   
0A49           1053                   ; Valid temperature
0A49 753400    1054            mov y+0, #low (2400000 % 0x10000) 
0A4C 75359F    1054            mov y+1, #high(2400000 % 0x10000) 
0A4F 753624    1054            mov y+2, #low (2400000 / 0x10000) 
0A52 753700    1054            mov y+3, #high(2400000 / 0x10000)            ; change this value to configure emergency temp
0A55 12026B    1055                   lcall x_gt_y
0A58 300062    1056                   jnb mf, ovenFSM_preheat   ; skip if x < 240 degrees 
0A5B 755400    1057                   mov seconds_elapsed, #0 ; reset
0A5E           1058                   emergencyStop_tempTooHigh:
0A5E D205      1059                           setb TIME_TO_BEEP_FLAG  ; beep once, move to inside for continuous?
0A60 755800    1060                           mov pwm, #0
0A63 C0E0      1061            push acc
0A65 7401      1061            mov a, #1
0A67 14        1061            dec a
0A68 1200C7    1061            lcall ?Set_Cursor_1 ; Select column and row
0A6B D0E0      1061            pop acc
0A6D C083      1062            push dph
0A6F C082      1062            push dpl
0A71 C0E0      1062            push acc
0A73 900551    1062            mov dptr, #stopMessage
0A76 1200BA    1062            lcall ?Send_Constant_String
0A79 D0E0      1062            pop acc
0A7B D082      1062            pop dpl
0A7D D083      1062            pop dph
0A7F C083      1063            push dph
0A81 C082      1063            push dpl
0A83 C0E0      1063            push acc
0A85 90050D    1063            mov dptr, #LCD_clearLine
0A88 1200BA    1063            lcall ?Send_Constant_String
0A8B D0E0      1063            pop acc
0A8D D082      1063            pop dpl
0A8F D083      1063            pop dph
0A91 C0E0      1064            push acc
0A93 740E      1064            mov a, #14
0A95 14        1064            dec a
0A96 1200C5    1064            lcall ?Set_Cursor_2 ; Select column and row
0A99 D0E0      1064            pop acc
0A9B E554      1065                           mov     a, seconds_elapsed
0A9D 1206A9    1066                           lcall   SendToLCD ; send seconds to LCD
0AA0 E556      1067                           mov     a, total_seconds
0AA2 C0E0      1068            push acc
0AA4 740E      1068            mov a, #14
0AA6 14        1068            dec a
0AA7 1200C7    1068            lcall ?Set_Cursor_1 ; Select column and row
0AAA D0E0      1068            pop acc
0AAC 1206A9    1069                           lcall   SendToLCD
0AAF 1200E2    1070                           lcall   hex2bcd
0AB2 12078B    1071                           lcall   Display_formated_BCD
0AB5           1072   
0AB5           1073                           ; check if seconds > 10
0AB5 E554      1074                           mov     a, seconds_elapsed
0AB7 B40AA4    1075                           cjne    a, #10, emergencyStop_tempTooHigh ; loop back to start until seconds_elapsed = 10
0ABA           1076                           ; number of seconds elapsed is enough, exit
0ABA 120990    1077                           lcall STOP_PROCESS
0ABD           1078                 
0ABD           1079           ovenFSM_preheat:
0ABD           1080   
0ABD           1081                   ; long jump for relative offset
0ABD B40002    1082                   cjne    a, #OVEN_STATE_PREHEAT, ovenFSM_soak_jmp
0AC0 8003      1083                   sjmp    oven_state_preheat_tasks
0AC2           1084                   ovenFSM_soak_jmp:
0AC2 020BBF    1085                           ljmp    ovenFSM_soak
0AC5           1086                   oven_state_preheat_tasks:
0AC5 75585A    1087                           mov     pwm, #90
0AC8 C0E0      1088            push acc
0ACA 7401      1088            mov a, #1
0ACC 14        1088            dec a
0ACD 1200C7    1088            lcall ?Set_Cursor_1 ; Select column and row
0AD0 D0E0      1088            pop acc
0AD2 C083      1089            push dph
0AD4 C082      1089            push dpl
0AD6 C0E0      1089            push acc
0AD8 90051E    1089            mov dptr, #preheatMessage
0ADB 1200BA    1089            lcall ?Send_Constant_String
0ADE D0E0      1089            pop acc
0AE0 D082      1089            pop dpl
0AE2 D083      1089            pop dph
0AE4 C083      1090            push dph
0AE6 C082      1090            push dpl
0AE8 C0E0      1090            push acc
0AEA 90050D    1090            mov dptr, #LCD_clearLine
0AED 1200BA    1090            lcall ?Send_Constant_String
0AF0 D0E0      1090            pop acc
0AF2 D082      1090            pop dpl
0AF4 D083      1090            pop dph
0AF6 C0E0      1091            push acc
0AF8 740E      1091            mov a, #14
0AFA 14        1091            dec a
0AFB 1200C5    1091            lcall ?Set_Cursor_2 ; Select column and row
0AFE D0E0      1091            pop acc
0B00 E554      1092                           mov     a, seconds_elapsed
0B02 1206A9    1093                           lcall   SendToLCD ; send seconds to LCD
0B05 E556      1094                           mov     a, total_seconds
0B07 C0E0      1095            push acc
0B09 740E      1095            mov a, #14
0B0B 14        1095            dec a
0B0C 1200C7    1095            lcall ?Set_Cursor_1 ; Select column and row
0B0F D0E0      1095            pop acc
0B11 1206A9    1096                           lcall   SendToLCD
0B14 1200E2    1097                           lcall   hex2bcd
0B17 12078B    1098                           lcall   Display_formated_BCD
0B1A           1099   
0B1A           1100                   ;Emergency exit process; tested, works
0B1A D203      1101                   setb    REFLOW_FLAG
0B1C E555      1102                   mov     a, exit_seconds
0B1E B43C15    1103                   cjne    a, #60, Skip_Emergency_exit
0B21 753420    1104            mov y+0, #low (50*10000 % 0x10000) 
0B24 7535A1    1104            mov y+1, #high(50*10000 % 0x10000) 
0B27 753607    1104            mov y+2, #low (50*10000 / 0x10000) 
0B2A 753700    1104            mov y+3, #high(50*10000 / 0x10000) 
0B2D 1202AD    1105                   lcall   x_gteq_y
0B30 200003    1106                   jb      mf, Skip_Emergency_exit ; if x > y, don't exit
0B33           1107                   
0B33           1108                   ; mov a, temp
0B33           1109                   ; lcall ;send temperature value to serial
0B33 020990    1110                   ljmp    STOP_PROCESS ; more then 60 seconds has elapsed and we are below 50C ESCAPE
0B36           1111                   
0B36           1112           Skip_Emergency_exit:       
0B36           1113                   ; This is to prevent overshoot
0B36           1114                   ; State transition check ; if x > temp_soak, next state ; else, self loop
0B36 854B34    1115                   mov y+0, temp_soak
0B39 753500    1116                   mov y+1, #0
0B3C 753600    1117                   mov y+2, #0
0B3F 753700    1118                   mov y+3, #0        
0B42 753810    1119            mov z+0, #low (10000 % 0x10000) 
0B45 753927    1119            mov z+1, #high(10000 % 0x10000) 
0B48 753A00    1119            mov z+2, #low (10000 / 0x10000) 
0B4B 753B00    1119            mov z+3, #high(10000 / 0x10000) 
0B4E 12034E    1120                   lcall mul32z      ; z = temp_soak * 10000
0B51 853834    1121                   mov y+0, z+0
0B54 853935    1122                   mov y+1, z+1
0B57 853A36    1123                   mov y+2, z+2
0B5A 853B37    1124                   mov y+3, z+3      ; y = temp_soak * 10000
0B5D 753890    1125            mov z+0, #low (250000 % 0x10000) 
0B60 7539D0    1125            mov z+1, #high(250000 % 0x10000) 
0B63 753A03    1125            mov z+2, #low (250000 / 0x10000) 
0B66 753B00    1125            mov z+3, #high(250000 / 0x10000) 
0B69 12022D    1126                   lcall sub32yyz    ; y = y - 25
0B6C           1127   
0B6C 12026B    1128                   lcall x_gt_y      ; if x > y-30, set PWM
0B6F 300003    1129                   jnb mf, $+3+3
0B72 75580F    1130                   mov PWM, #15 ; turn PWM off - commented out bc temp cant get above 70
0B75           1131   
0B75           1132                   ; Checking that temperature < 300
0B75 7534C0    1133            mov y+0, #low (3000000 % 0x10000) 
0B78 7535C6    1133            mov y+1, #high(3000000 % 0x10000) 
0B7B 75362D    1133            mov y+2, #low (3000000 / 0x10000) 
0B7E 753700    1133            mov y+3, #high(3000000 / 0x10000) 
0B81 12026B    1134                   lcall x_gt_y                    ; if x > 240, mf = 1
0B84 200035    1135                   jb mf, noChange_preHeat         
0B87           1136   
0B87 854B34    1137                   mov y+0, temp_soak
0B8A 753500    1138                   mov y+1, #0
0B8D 753600    1139                   mov y+2, #0
0B90 753700    1140                   mov y+3, #0        
0B93 753810    1141            mov z+0, #low (10000 % 0x10000) 
0B96 753927    1141            mov z+1, #high(10000 % 0x10000) 
0B99 753A00    1141            mov z+2, #low (10000 / 0x10000) 
0B9C 753B00    1141            mov z+3, #high(10000 / 0x10000) 
0B9F 12034E    1142                   lcall mul32z
0BA2 853834    1143                   mov y+0, z+0
0BA5 853935    1144                   mov y+1, z+1
0BA8 853A36    1145                   mov y+2, z+2
0BAB 853B37    1146                   mov y+3, z+3                        
0BAE           1147   
0BAE 12026B    1148                   lcall x_gt_y
0BB1 300008    1149                   jnb mf, noChange_preHeat ; jump past the jnb and mov instructions which are both 3 bytes
0BB4 754801    1150                   mov OVEN_STATE, #OVEN_STATE_SOAK
0BB7 755400    1151                   mov seconds_elapsed, #0
0BBA D205      1152                   setb TIME_TO_BEEP_FLAG
0BBC           1153                   
0BBC           1154           noChange_preHeat:
0BBC 020E5F    1155                   ljmp oven_FSM_done
0BBF           1156           
0BBF           1157           ovenFSM_soak:
0BBF B40165    1158                   cjne    a, #OVEN_STATE_SOAK, ovenFSM_Ramp2Peak
0BC2 755801    1159                   mov     pwm, #1
0BC5 C0E0      1160            push acc
0BC7 7401      1160            mov a, #1
0BC9 14        1160            dec a
0BCA 1200C7    1160            lcall ?Set_Cursor_1 ; Select column and row
0BCD D0E0      1160            pop acc
0BCF C083      1161            push dph
0BD1 C082      1161            push dpl
0BD3 C0E0      1161            push acc
0BD5 900526    1161            mov dptr, #soakMessage
0BD8 1200BA    1161            lcall ?Send_Constant_String
0BDB D0E0      1161            pop acc
0BDD D082      1161            pop dpl
0BDF D083      1161            pop dph
0BE1 C083      1162            push dph
0BE3 C082      1162            push dpl
0BE5 C0E0      1162            push acc
0BE7 90050D    1162            mov dptr, #LCD_clearLine
0BEA 1200BA    1162            lcall ?Send_Constant_String
0BED D0E0      1162            pop acc
0BEF D082      1162            pop dpl
0BF1 D083      1162            pop dph
0BF3 C0E0      1163            push acc
0BF5 740E      1163            mov a, #14
0BF7 14        1163            dec a
0BF8 1200C5    1163            lcall ?Set_Cursor_2 ; Select column and row
0BFB D0E0      1163            pop acc
0BFD E554      1164                   mov     a, seconds_elapsed
0BFF 1206A9    1165                   lcall   SendToLCD
0C02 E556      1166                   mov     a, total_seconds
0C04 C0E0      1167            push acc
0C06 740E      1167            mov a, #14
0C08 14        1167            dec a
0C09 1200C7    1167            lcall ?Set_Cursor_1 ; Select column and row
0C0C D0E0      1167            pop acc
0C0E 1206A9    1168                   lcall   SendToLCD
0C11 1200E2    1169                   lcall   hex2bcd
0C14 12078B    1170                   lcall   Display_formated_BCD
0C17           1171   
0C17           1172                   ; check if seconds elapsed > soak time
0C17 E554      1173                   mov     a, seconds_elapsed
0C19 B54C08    1174                   cjne    a, time_soak, noChange_soakState
0C1C 754802    1175                   mov     OVEN_STATE, #OVEN_STATE_RAMP2PEAK
0C1F 755400    1176                   mov     seconds_elapsed, #0 ; reset
0C22 D205      1177                   setb    TIME_TO_BEEP_FLAG
0C24           1178   
0C24           1179                   noChange_soakState:
0C24 020E5F    1180                           ljmp    oven_FSM_done
0C27           1181           
0C27           1182           ovenFSM_Ramp2Peak:
0C27 B40202    1183                   cjne    a, #OVEN_STATE_RAMP2PEAK, ovenFSM_reflow_jmp
0C2A 8003      1184                   sjmp ovenFSM_Ramp2Peak_task
0C2C           1185                   ovenFSM_reflow_jmp:
0C2C 020D0D    1186                   ljmp ovenFSM_reflow
0C2F           1187                   ovenFSM_Ramp2Peak_task:
0C2F 75585A    1188                   mov     pwm, #90
0C32 C0E0      1189            push acc
0C34 7401      1189            mov a, #1
0C36 14        1189            dec a
0C37 1200C7    1189            lcall ?Set_Cursor_1 ; Select column and row
0C3A D0E0      1189            pop acc
0C3C C083      1190            push dph
0C3E C082      1190            push dpl
0C40 C0E0      1190            push acc
0C42 90052B    1190            mov dptr, #ramp2peakMessage
0C45 1200BA    1190            lcall ?Send_Constant_String
0C48 D0E0      1190            pop acc
0C4A D082      1190            pop dpl
0C4C D083      1190            pop dph
0C4E C083      1191            push dph
0C50 C082      1191            push dpl
0C52 C0E0      1191            push acc
0C54 90050D    1191            mov dptr, #LCD_clearLine
0C57 1200BA    1191            lcall ?Send_Constant_String
0C5A D0E0      1191            pop acc
0C5C D082      1191            pop dpl
0C5E D083      1191            pop dph
0C60 C0E0      1192            push acc
0C62 740E      1192            mov a, #14
0C64 14        1192            dec a
0C65 1200C5    1192            lcall ?Set_Cursor_2 ; Select column and row
0C68 D0E0      1192            pop acc
0C6A E554      1193                   mov     a, seconds_elapsed
0C6C 1206A9    1194                   lcall   SendToLCD
0C6F E556      1195                   mov     a, total_seconds
0C71 C0E0      1196            push acc
0C73 740E      1196            mov a, #14
0C75 14        1196            dec a
0C76 1200C7    1196            lcall ?Set_Cursor_1 ; Select column and row
0C79 D0E0      1196            pop acc
0C7B 1206A9    1197                   lcall   SendToLCD
0C7E 1200E2    1198                   lcall   hex2bcd
0C81 12078B    1199                   lcall   Display_formated_BCD
0C84           1200   
0C84           1201                   ; check that temperature for reflow is reached, then exit 
0C84 854D34    1202                   mov y+0, temp_refl
0C87 753500    1203                   mov y+1, #0
0C8A 753600    1204                   mov y+2, #0
0C8D 753700    1205                   mov y+3, #0        
0C90 753810    1206            mov z+0, #low (10000 % 0x10000) 
0C93 753927    1206            mov z+1, #high(10000 % 0x10000) 
0C96 753A00    1206            mov z+2, #low (10000 / 0x10000) 
0C99 753B00    1206            mov z+3, #high(10000 / 0x10000) 
0C9C 12034E    1207                   lcall mul32z
0C9F 853834    1208                   mov y+0, z+0
0CA2 853935    1209                   mov y+1, z+1
0CA5 853A36    1210                   mov y+2, z+2
0CA8 853B37    1211                   mov y+3, z+3     ; y = y * 10000
0CAB 7538A0    1212            mov z+0, #low (100000 % 0x10000) 
0CAE 753986    1212            mov z+1, #high(100000 % 0x10000) 
0CB1 753A01    1212            mov z+2, #low (100000 / 0x10000) 
0CB4 753B00    1212            mov z+3, #high(100000 / 0x10000) 
0CB7 12022D    1213                   lcall sub32yyz    ; y = y - 10
0CBA           1214   
0CBA 12026B    1215                   lcall x_gt_y   ; if x > y-10, set PWM
0CBD 300003    1216                   jnb mf, $+3+3
0CC0 755823    1217                   mov PWM, #35 ; turn PWM off - commented out
0CC3           1218   
0CC3           1219                   ; Checking that temperature < 240
0CC3 7534C0    1220            mov y+0, #low (3000000 % 0x10000) 
0CC6 7535C6    1220            mov y+1, #high(3000000 % 0x10000) 
0CC9 75362D    1220            mov y+2, #low (3000000 / 0x10000) 
0CCC 753700    1220            mov y+3, #high(3000000 / 0x10000) 
0CCF 12026B    1221                   lcall x_gt_y                    ; if x > 240, mf = 1
0CD2 200035    1222                   jb mf, noChange_Ramp2Peak         
0CD5           1223   
0CD5 854D34    1224                   mov y+0, temp_refl
0CD8 753500    1225                   mov y+1, #0
0CDB 753600    1226                   mov y+2, #0
0CDE 753700    1227                   mov y+3, #0        
0CE1 753810    1228            mov z+0, #low (10000 % 0x10000) 
0CE4 753927    1228            mov z+1, #high(10000 % 0x10000) 
0CE7 753A00    1228            mov z+2, #low (10000 / 0x10000) 
0CEA 753B00    1228            mov z+3, #high(10000 / 0x10000) 
0CED 12034E    1229                   lcall mul32z
0CF0 853834    1230                   mov y+0, z+0
0CF3 853935    1231                   mov y+1, z+1
0CF6 853A36    1232                   mov y+2, z+2
0CF9 853B37    1233                   mov y+3, z+3                        
0CFC           1234   
0CFC 12026B    1235                   lcall x_gt_y
0CFF           1236                   ; 
0CFF 300008    1237                   jnb mf, noChange_Ramp2Peak ; jump past the jnb and mov instructions which are both 3 bytes
0D02 754803    1238                   mov OVEN_STATE, #OVEN_STATE_REFLOW
0D05 755400    1239                   mov  seconds_elapsed, #0
0D08 D205      1240                   setb TIME_TO_BEEP_FLAG
0D0A           1241   
0D0A           1242                   noChange_Ramp2Peak:
0D0A 020E5F    1243                   ljmp oven_FSM_done
0D0D           1244                   
0D0D           1245           ovenFSM_reflow:
0D0D B40365    1246                   cjne    a, #OVEN_STATE_REFLOW, ovenFSM_cooling
0D10 75580A    1247                   mov     pwm, #10
0D13 C0E0      1248            push acc
0D15 7401      1248            mov a, #1
0D17 14        1248            dec a
0D18 1200C7    1248            lcall ?Set_Cursor_1 ; Select column and row
0D1B D0E0      1248            pop acc
0D1D C083      1249            push dph
0D1F C082      1249            push dpl
0D21 C0E0      1249            push acc
0D23 900538    1249            mov dptr, #reflowMessage
0D26 1200BA    1249            lcall ?Send_Constant_String
0D29 D0E0      1249            pop acc
0D2B D082      1249            pop dpl
0D2D D083      1249            pop dph
0D2F C083      1250            push dph
0D31 C082      1250            push dpl
0D33 C0E0      1250            push acc
0D35 90050D    1250            mov dptr, #LCD_clearLine
0D38 1200BA    1250            lcall ?Send_Constant_String
0D3B D0E0      1250            pop acc
0D3D D082      1250            pop dpl
0D3F D083      1250            pop dph
0D41 C0E0      1251            push acc
0D43 740E      1251            mov a, #14
0D45 14        1251            dec a
0D46 1200C5    1251            lcall ?Set_Cursor_2 ; Select column and row
0D49 D0E0      1251            pop acc
0D4B E554      1252                   mov     a, seconds_elapsed
0D4D 1206A9    1253                   lcall   SendToLCD
0D50 E556      1254                   mov     a, total_seconds
0D52 C0E0      1255            push acc
0D54 740E      1255            mov a, #14
0D56 14        1255            dec a
0D57 1200C7    1255            lcall ?Set_Cursor_1 ; Select column and row
0D5A D0E0      1255            pop acc
0D5C 1206A9    1256                   lcall   SendToLCD
0D5F 1200E2    1257                   lcall   hex2bcd
0D62 12078B    1258                   lcall   Display_formated_BCD
0D65           1259   
0D65           1260                   ; check if seconds elapsed > reflow time
0D65 E554      1261                   mov     a, seconds_elapsed
0D67 B54E08    1262                   cjne    a, time_refl, noChange_reflowState
0D6A 754804    1263                   mov     OVEN_STATE, #OVEN_STATE_COOLING
0D6D 755400    1264                   mov     seconds_elapsed, #0 ; reset
0D70 D205      1265                   setb    TIME_TO_BEEP_FLAG
0D72           1266                  
0D72           1267                   noChange_reflowState:
0D72 020E5F    1268                           ljmp    oven_FSM_done
0D75           1269   
0D75           1270           ovenFSM_cooling:
0D75 B40472    1271                   cjne    a, #OVEN_STATE_COOLING, ovenFSM_finished
0D78 755800    1272                   mov     pwm, #0
0D7B C0E0      1273            push acc
0D7D 7401      1273            mov a, #1
0D7F 14        1273            dec a
0D80 1200C7    1273            lcall ?Set_Cursor_1 ; Select column and row
0D83 D0E0      1273            pop acc
0D85 C083      1274            push dph
0D87 C082      1274            push dpl
0D89 C0E0      1274            push acc
0D8B 90053F    1274            mov dptr, #coolingMessage
0D8E 1200BA    1274            lcall ?Send_Constant_String
0D91 D0E0      1274            pop acc
0D93 D082      1274            pop dpl
0D95 D083      1274            pop dph
0D97 C083      1275            push dph
0D99 C082      1275            push dpl
0D9B C0E0      1275            push acc
0D9D 90050D    1275            mov dptr, #LCD_clearLine
0DA0 1200BA    1275            lcall ?Send_Constant_String
0DA3 D0E0      1275            pop acc
0DA5 D082      1275            pop dpl
0DA7 D083      1275            pop dph
0DA9 C0E0      1276            push acc
0DAB 740E      1276            mov a, #14
0DAD 14        1276            dec a
0DAE 1200C5    1276            lcall ?Set_Cursor_2 ; Select column and row
0DB1 D0E0      1276            pop acc
0DB3 E554      1277                   mov     a, seconds_elapsed
0DB5 1206A9    1278                   lcall   SendToLCD
0DB8 E556      1279                   mov     a, total_seconds
0DBA C0E0      1280            push acc
0DBC 740E      1280            mov a, #14
0DBE 14        1280            dec a
0DBF 1200C7    1280            lcall ?Set_Cursor_1 ; Select column and row
0DC2 D0E0      1280            pop acc
0DC4 1206A9    1281                   lcall   SendToLCD
0DC7 1200E2    1282                   lcall   hex2bcd
0DCA 12078B    1283                   lcall   Display_formated_BCD
0DCD           1284   
0DCD           1285                   ; once temperature is low (compare with temp constant)
0DCD 753420    1286            mov y+0, #low (50 * 10000 % 0x10000) 
0DD0 7535A1    1286            mov y+1, #high(50 * 10000 % 0x10000) 
0DD3 753607    1286            mov y+2, #low (50 * 10000 / 0x10000) 
0DD6 753700    1286            mov y+3, #high(50 * 10000 / 0x10000) 
0DD9 12024F    1287                   lcall x_lt_y
0DDC 300006    1288                   jnb mf, $+3+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
0DDF 754805    1289                   mov OVEN_STATE, #OVEN_STATE_FINISHED
0DE2 755400    1290                   mov     seconds_elapsed, #0 ; reset
0DE5 D205      1291                   setb    TIME_TO_BEEP_FLAG
0DE7           1292                 
0DE7 020E5F    1293                   ljmp oven_FSM_done
0DEA           1294   
0DEA           1295           ovenFSM_finished:
0DEA B4056C    1296                   cjne    a, #OVEN_STATE_FINISHED, ovenFSM_exit
0DED C0E0      1297            push acc
0DEF 7401      1297            mov a, #1
0DF1 14        1297            dec a
0DF2 1200C7    1297            lcall ?Set_Cursor_1 ; Select column and row
0DF5 D0E0      1297            pop acc
0DF7 C083      1298            push dph
0DF9 C082      1298            push dpl
0DFB C0E0      1298            push acc
0DFD 900547    1298            mov dptr, #FinishedMessage
0E00 1200BA    1298            lcall ?Send_Constant_String
0E03 D0E0      1298            pop acc
0E05 D082      1298            pop dpl
0E07 D083      1298            pop dph
0E09 C083      1299            push dph
0E0B C082      1299            push dpl
0E0D C0E0      1299            push acc
0E0F 90050D    1299            mov dptr, #LCD_clearLine
0E12 1200BA    1299            lcall ?Send_Constant_String
0E15 D0E0      1299            pop acc
0E17 D082      1299            pop dpl
0E19 D083      1299            pop dph
0E1B C0E0      1300            push acc
0E1D 740E      1300            mov a, #14
0E1F 14        1300            dec a
0E20 1200C5    1300            lcall ?Set_Cursor_2 ; Select column and row
0E23 D0E0      1300            pop acc
0E25 E554      1301                   mov     a, seconds_elapsed
0E27 1206A9    1302                   lcall   SendToLCD
0E2A E556      1303                   mov     a, total_seconds
0E2C C0E0      1304            push acc
0E2E 740E      1304            mov a, #14
0E30 14        1304            dec a
0E31 1200C7    1304            lcall ?Set_Cursor_1 ; Select column and row
0E34 D0E0      1304            pop acc
0E36 1206A9    1305                   lcall SendToLCD
0E39           1306                   
0E39 C083      1307            push dph
0E3B C082      1307            push dpl
0E3D C0E0      1307            push acc
0E3F 90050D    1307            mov dptr, #LCD_clearLine
0E42 1200BA    1307            lcall ?Send_Constant_String
0E45 D0E0      1307            pop acc
0E47 D082      1307            pop dpl
0E49 D083      1307            pop dph
0E4B           1308   
0E4B           1309   
0E4B           1310                   ; go back to Start Screen after a certain number of seconds
0E4B E554      1311                   mov     a, seconds_elapsed
0E4D B40506    1312                   cjne    a, #FINISHED_SECONDS, noChange_finishedState
0E50 754800    1313                   mov OVEN_STATE, #OVEN_STATE_PREHEAT
0E53 120990    1314                   lcall STOP_PROCESS
0E56           1315                   noChange_finishedState:
0E56 020E5F    1316                           ljmp    oven_FSM_done
0E59           1317   
0E59           1318           ovenFSM_exit:
0E59 754800    1319                   mov     OVEN_STATE, #OVEN_STATE_PREHEAT
0E5C           1320                   ; ljmp oven_FSM_done
0E5C 120990    1321                   lcall   STOP_PROCESS ; Exit oven FSM, turn power off, return to program entry
0E5F           1322                   
0E5F           1323           oven_FSM_done:
0E5F 0209BE    1324                   ljmp    OVEN_FSM ; return to start of oven FSM ; this is a blocking FSM
0E62           1325           
0E62 22        1326   ret ; technically unncessary
0E63           1327   
0E63           1328   MENU_FSM: 
0E63           1329           ; Load variables for non-volatile memory
0E63           1330           ; Put at the menu FSM since this is where the variables are being set and displayed - GL
0E63 120664    1331           lcall Load_Variables
0E66           1332   
0E66 755800    1333           mov     pwm, #0
0E69 20965C    1334           jb DEFAULT_REFLOW_SETTING, dont_change_default_settings  ; Button logic
0E6C C002      1335            push AR2
0E6E 7A32      1335            mov R2, #50
0E70 120038    1335            lcall ?Wait_Milli_Seconds
0E73 D002      1335            pop AR2         
0E75 209650    1336            jb DEFAULT_REFLOW_SETTING, dont_change_default_settings  
0E78 3096FD    1337            jnb DEFAULT_REFLOW_SETTING, $           ; Wait for button release.  The '$' means: jump to same instruction.
0E7B           1338   
0E7B           1339           ;If its pressed enter this mini FSM
0E7B E54A      1340           mov a, DEFAULT_STATE
0E7D           1341           
0E7D B40217    1342           cjne a, #2, check_1
0E80 7400      1343           mov a, #0 
0E82 F54A      1344           mov DEFAULT_STATE, a
0E84           1345           
0E84 743C      1346           mov a, #60 ;set time soak
0E86 F54C      1347           mov time_soak, a
0E88           1348   
0E88 741E      1349           mov a, #30
0E8A F54E      1350           mov time_refl, a
0E8C           1351           
0E8C 748C      1352           mov a, #140
0E8E F54B      1353           mov temp_soak, a
0E90           1354           
0E90 74DC      1355           mov a, #220
0E92 F54D      1356           mov temp_refl, a
0E94 020EC8    1357           ljmp dont_change_default_settings
0E97           1358   
0E97           1359           check_1:
0E97 B40117    1360           cjne a, #1, check_0
0E9A 7402      1361           mov a, #2
0E9C F54A      1362           mov DEFAULT_STATE, a  
0E9E           1363   
0E9E 745A      1364           mov a, #90
0EA0 F54C      1365           mov time_soak, A
0EA2           1366           
0EA2 7428      1367           mov a, #40
0EA4 F54E      1368           mov time_refl, a 
0EA6           1369           
0EA6 74C8      1370           mov a, #200
0EA8 F54B      1371           mov temp_soak, a 
0EAA           1372           
0EAA 74F0      1373           mov a, #240
0EAC F54D      1374           mov temp_refl, a  ; values 
0EAE           1375   
0EAE 020EC8    1376           ljmp dont_change_default_settings
0EB1           1377           
0EB1           1378           check_0:
0EB1 7401      1379           mov a, #1
0EB3 F54A      1380           mov DEFAULT_STATE, a
0EB5           1381           
0EB5 744B      1382           mov a, #75 ;set time soak
0EB7 F54C      1383           mov time_soak, a
0EB9           1384   
0EB9 742D      1385           mov a, #45
0EBB F54E      1386           mov time_refl, a
0EBD           1387           
0EBD 74AA      1388           mov a, #170
0EBF F54B      1389           mov temp_soak, a
0EC1           1390           
0EC1 74E6      1391           mov a, #230
0EC3 F54D      1392           mov temp_refl, a
0EC5 020EC8    1393           ljmp dont_change_default_settings
0EC8           1394   
0EC8           1395   
0EC8           1396   
0EC8           1397   
0EC8           1398   ;settings 1 at a = 0
0EC8           1399   ;settigngs 2 at a = 1
0EC8           1400   ;settings 3 at  a = 2
0EC8           1401   ;then loop
0EC8           1402   
0EC8           1403   
0EC8           1404           dont_change_default_settings:
0EC8 E549      1405           mov     a, MENU_STATE 
0ECA D208      1406           setb PB_START_PIN
0ECC D209      1406           setb PB_CHANGE_MENU_PIN
0ECE D20A      1406           setb PB_INC_TEMP_PIN
0ED0 D20B      1406           setb PB_INC_TIME_PIN
0ED2 D20C      1406           setb PB_STOP_PIN
0ED4           1406           
0ED4 D295      1406           setb SHARED_PIN
0ED6           1406           ; check if any push buttons are pressed
0ED6 C293      1406           clr START_PIN             
0ED8 C281      1406           clr CHANGE_MENU_PIN       
0EDA C282      1406           clr INC_TEMP_PIN          
0EDC C283      1406           clr INC_TIME_PIN          
0EDE C280      1406           clr STOP_PIN
0EE0           1406   
0EE0           1406           ; debounce
0EE0 209502    1406           jb SHARED_PIN, $+2+3 ; use helper label to jump to the end
0EE3 8003      1406           sjmp $+2+3
0EE5 020F38    1406           ljmp checkTimeInc
0EE8 C002      1406            push AR2
0EEA 7A32      1406            mov R2, #50
0EEC 120038    1406            lcall ?Wait_Milli_Seconds
0EEF D002      1406            pop AR2
0EF1 209502    1406           jb SHARED_PIN, $+2+3
0EF4 8003      1406           sjmp $+2+3
0EF6 020F38    1406           ljmp checkTimeInc
0EF9           1406   
0EF9           1406           ; Set the LCD data pins to logic 1
0EF9 D293      1406           setb START_PIN
0EFB D281      1406           setb CHANGE_MENU_PIN
0EFD D282      1406           setb INC_TEMP_PIN
0EFF D283      1406           setb INC_TIME_PIN
0F01 D280      1406           setb STOP_PIN
0F03           1406   
0F03           1406           ; check push buttons 1 by one
0F03 C293      1406           clr START_PIN
0F05 A295      1406           mov c, SHARED_PIN
0F07 9208      1406           mov PB_START_PIN, c
0F09 D293      1406           setb START_PIN
0F0B           1406   
0F0B C281      1406           clr CHANGE_MENU_PIN
0F0D A295      1406           mov c, SHARED_PIN
0F0F 9209      1406           mov PB_CHANGE_MENU_PIN, c
0F11 D281      1406           setb CHANGE_MENU_PIN
0F13           1406   
0F13 C282      1406           clr INC_TEMP_PIN
0F15 A295      1406           mov c, SHARED_PIN
0F17 920A      1406           mov PB_INC_TEMP_PIN, c
0F19 D282      1406           setb INC_TEMP_PIN
0F1B           1406   
0F1B C283      1406           clr INC_TIME_PIN
0F1D A295      1406           mov c, SHARED_PIN
0F1F 920B      1406           mov PB_INC_TIME_PIN, c
0F21 D283      1406           setb INC_TIME_PIN
0F23           1406   
0F23 C280      1406           clr STOP_PIN
0F25 A295      1406           mov c, SHARED_PIN
0F27 920C      1406           mov PB_STOP_PIN, c
0F29 D280      1406           setb STOP_PIN
0F2B           1406   
0F2B           1406           ; jb PB_CHANGE_MENU_PIN, checkTimeInc ; check that the variable flag is not 1, otherwise jmp
0F2B           1406   
0F2B 200902    1406           jb PB_CHANGE_MENU_PIN, $+2+3 ; check that the variable flag is not 1, otherwise jmp
0F2E 8003      1406           sjmp $+2+3
0F30 020F38    1406           ljmp checkTimeInc     ; can access anypart of the code
0F33           1406    ; increments menu state
0F33 04        1407           inc     a
0F34 F549      1408           mov     MENU_STATE, a 
0F36           1409           ;clr     TIME_TO_BEEP_FLAG
0F36 D281      1410           setb    CHANGE_MENU_PIN
0F38           1411           
0F38           1412           ; increment is checked with a seperate cascade that's outside the FSM
0F38           1413           ; I wanted to keep FSM state outputs seperate from push button checks - George
0F38           1414           checkTimeInc:
0F38 D208      1415           setb PB_START_PIN
0F3A D209      1415           setb PB_CHANGE_MENU_PIN
0F3C D20A      1415           setb PB_INC_TEMP_PIN
0F3E D20B      1415           setb PB_INC_TIME_PIN
0F40 D20C      1415           setb PB_STOP_PIN
0F42           1415           
0F42 D295      1415           setb SHARED_PIN
0F44           1415           ; check if any push buttons are pressed
0F44 C293      1415           clr START_PIN             
0F46 C281      1415           clr CHANGE_MENU_PIN       
0F48 C282      1415           clr INC_TEMP_PIN          
0F4A C283      1415           clr INC_TIME_PIN          
0F4C C280      1415           clr STOP_PIN
0F4E           1415   
0F4E           1415           ; debounce
0F4E 209502    1415           jb SHARED_PIN, $+2+3 ; use helper label to jump to the end
0F51 8003      1415           sjmp $+2+3
0F53 020FC0    1415           ljmp checkTempInc
0F56 C002      1415            push AR2
0F58 7A32      1415            mov R2, #50
0F5A 120038    1415            lcall ?Wait_Milli_Seconds
0F5D D002      1415            pop AR2
0F5F 209502    1415           jb SHARED_PIN, $+2+3
0F62 8003      1415           sjmp $+2+3
0F64 020FC0    1415           ljmp checkTempInc
0F67           1415   
0F67           1415           ; Set the LCD data pins to logic 1
0F67 D293      1415           setb START_PIN
0F69 D281      1415           setb CHANGE_MENU_PIN
0F6B D282      1415           setb INC_TEMP_PIN
0F6D D283      1415           setb INC_TIME_PIN
0F6F D280      1415           setb STOP_PIN
0F71           1415   
0F71           1415           ; check push buttons 1 by one
0F71 C293      1415           clr START_PIN
0F73 A295      1415           mov c, SHARED_PIN
0F75 9208      1415           mov PB_START_PIN, c
0F77 D293      1415           setb START_PIN
0F79           1415   
0F79 C281      1415           clr CHANGE_MENU_PIN
0F7B A295      1415           mov c, SHARED_PIN
0F7D 9209      1415           mov PB_CHANGE_MENU_PIN, c
0F7F D281      1415           setb CHANGE_MENU_PIN
0F81           1415   
0F81 C282      1415           clr INC_TEMP_PIN
0F83 A295      1415           mov c, SHARED_PIN
0F85 920A      1415           mov PB_INC_TEMP_PIN, c
0F87 D282      1415           setb INC_TEMP_PIN
0F89           1415   
0F89 C283      1415           clr INC_TIME_PIN
0F8B A295      1415           mov c, SHARED_PIN
0F8D 920B      1415           mov PB_INC_TIME_PIN, c
0F8F D283      1415           setb INC_TIME_PIN
0F91           1415   
0F91 C280      1415           clr STOP_PIN
0F93 A295      1415           mov c, SHARED_PIN
0F95 920C      1415           mov PB_STOP_PIN, c
0F97 D280      1415           setb STOP_PIN
0F99           1415   
0F99           1415           ; jb PB_INC_TIME_PIN, checkTempInc ; check that the variable flag is not 1, otherwise jmp
0F99           1415   
0F99 200B02    1415           jb PB_INC_TIME_PIN, $+2+3 ; check that the variable flag is not 1, otherwise jmp
0F9C 8003      1415           sjmp $+2+3
0F9E 020FC0    1415           ljmp checkTempInc     ; can access anypart of the code
0FA1           1415   
0FA1 B4000F    1416                   cjne a, #MENU_STATE_SOAK, incTimeReflow
0FA4 E54C      1417                           mov     a, time_soak 
0FA6 2405      1418                           add     A, #5        
0FA8 F54C      1419                           mov     time_soak, a 
0FAA           1420   
0FAA           1421                           ; check if time_soak will need to reset - assumes multiples of 5
0FAA           1422                           ; +5 to constants so they display on LCD b/f reseting
0FAA B47D13    1423                           cjne a, #(MAX_SOAK_TIME+5), checkTempInc 
0FAD 740F      1424                           mov a, #MIN_TIME
0FAF F54C      1425                           mov time_soak, a
0FB1           1426   
0FB1 800D      1427                           sjmp checkTempInc       
0FB3           1428                   incTimeReflow:
0FB3 E54E      1429                           mov     a, time_refl
0FB5 2405      1430                           add     A, #5
0FB7 F54E      1431                           mov     time_refl, a
0FB9           1432   
0FB9 B43204    1433                           cjne a, #(MAX_REFLOW_TIME+5), checkTempInc
0FBC 740F      1434                           mov a, #MIN_TIME
0FBE F54E      1435                           mov time_refl, a
0FC0           1436   
0FC0           1437           ; check whether we're in the soak or 
0FC0           1438           checkTempInc:
0FC0 D208      1439           setb PB_START_PIN
0FC2 D209      1439           setb PB_CHANGE_MENU_PIN
0FC4 D20A      1439           setb PB_INC_TEMP_PIN
0FC6 D20B      1439           setb PB_INC_TIME_PIN
0FC8 D20C      1439           setb PB_STOP_PIN
0FCA           1439           
0FCA D295      1439           setb SHARED_PIN
0FCC           1439           ; check if any push buttons are pressed
0FCC C293      1439           clr START_PIN             
0FCE C281      1439           clr CHANGE_MENU_PIN       
0FD0 C282      1439           clr INC_TEMP_PIN          
0FD2 C283      1439           clr INC_TIME_PIN          
0FD4 C280      1439           clr STOP_PIN
0FD6           1439   
0FD6           1439           ; debounce
0FD6 209502    1439           jb SHARED_PIN, $+2+3 ; use helper label to jump to the end
0FD9 8003      1439           sjmp $+2+3
0FDB 021048    1439           ljmp enterMenuStateCheck
0FDE C002      1439            push AR2
0FE0 7A32      1439            mov R2, #50
0FE2 120038    1439            lcall ?Wait_Milli_Seconds
0FE5 D002      1439            pop AR2
0FE7 209502    1439           jb SHARED_PIN, $+2+3
0FEA 8003      1439           sjmp $+2+3
0FEC 021048    1439           ljmp enterMenuStateCheck
0FEF           1439   
0FEF           1439           ; Set the LCD data pins to logic 1
0FEF D293      1439           setb START_PIN
0FF1 D281      1439           setb CHANGE_MENU_PIN
0FF3 D282      1439           setb INC_TEMP_PIN
0FF5 D283      1439           setb INC_TIME_PIN
0FF7 D280      1439           setb STOP_PIN
0FF9           1439   
0FF9           1439           ; check push buttons 1 by one
0FF9 C293      1439           clr START_PIN
0FFB A295      1439           mov c, SHARED_PIN
0FFD 9208      1439           mov PB_START_PIN, c
0FFF D293      1439           setb START_PIN
1001           1439   
1001 C281      1439           clr CHANGE_MENU_PIN
1003 A295      1439           mov c, SHARED_PIN
1005 9209      1439           mov PB_CHANGE_MENU_PIN, c
1007 D281      1439           setb CHANGE_MENU_PIN
1009           1439   
1009 C282      1439           clr INC_TEMP_PIN
100B A295      1439           mov c, SHARED_PIN
100D 920A      1439           mov PB_INC_TEMP_PIN, c
100F D282      1439           setb INC_TEMP_PIN
1011           1439   
1011 C283      1439           clr INC_TIME_PIN
1013 A295      1439           mov c, SHARED_PIN
1015 920B      1439           mov PB_INC_TIME_PIN, c
1017 D283      1439           setb INC_TIME_PIN
1019           1439   
1019 C280      1439           clr STOP_PIN
101B A295      1439           mov c, SHARED_PIN
101D 920C      1439           mov PB_STOP_PIN, c
101F D280      1439           setb STOP_PIN
1021           1439   
1021           1439           ; jb PB_INC_TEMP_PIN, enterMenuStateCheck ; check that the variable flag is not 1, otherwise jmp
1021           1439   
1021 200A02    1439           jb PB_INC_TEMP_PIN, $+2+3 ; check that the variable flag is not 1, otherwise jmp
1024 8003      1439           sjmp $+2+3
1026 021048    1439           ljmp enterMenuStateCheck     ; can access anypart of the code
1029           1439   
1029 B4000F    1440                   cjne a, #MENU_STATE_SOAK, incTempReflow
102C E54B      1441                           mov     a, temp_soak 
102E 2405      1442                           add     a, #5        
1030 F54B      1443                           mov     temp_soak, a 
1032           1444   
1032 B4F513    1445                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
1035 7450      1446                           mov a, #MIN_TEMP
1037 F54B      1447                           mov temp_soak, a
1039           1448   
1039 800D      1449                           sjmp enterMenuStateCheck       
103B           1450                   incTempReflow:
103B E54D      1451                           mov     a, temp_refl
103D 2405      1452                           add     a, #5
103F F54D      1453                           mov     temp_refl, a
1041           1454   
1041 B4F504    1455                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
1044 7450      1456                           mov a, #MIN_TEMP
1046 F54D      1457                           mov temp_refl, a
1048           1458   
1048           1459           ; ---------------- FSM State Check ---------------- ;  
1048           1460           enterMenuStateCheck:
1048 D282      1461                   setb INC_TEMP_PIN
104A E549      1462                   mov     a, MENU_STATE
104C           1463   
104C           1464           menuFSM_configSoak:
104C B40069    1465                   cjne    a, #MENU_STATE_SOAK, menuFSM_configReflow
104F           1466                   ; display Soak Menu Options
104F C0E0      1467            push acc
1051 7401      1467            mov a, #1
1053 14        1467            dec a
1054 1200C7    1467            lcall ?Set_Cursor_1 ; Select column and row
1057 D0E0      1467            pop acc
1059 C083      1468            push dph
105B C082      1468            push dpl
105D C0E0      1468            push acc
105F 9004DB    1468            mov dptr, #LCD_soakTemp
1062 1200BA    1468            lcall ?Send_Constant_String
1065 D0E0      1468            pop acc
1067 D082      1468            pop dpl
1069 D083      1468            pop dph
106B           1468   
106B E54B      1469                   mov     a, temp_soak
106D 1206A9    1470                   lcall   SendToLCD
1070 C083      1471            push dph
1072 C082      1471            push dpl
1074 C0E0      1471            push acc
1076 90050D    1471            mov dptr, #LCD_clearLine
1079 1200BA    1471            lcall ?Send_Constant_String
107C D0E0      1471            pop acc
107E D082      1471            pop dpl
1080 D083      1471            pop dph
1082 C0E0      1472            push acc
1084 7401      1472            mov a, #1
1086 14        1472            dec a
1087 1200C5    1472            lcall ?Set_Cursor_2 ; Select column and row
108A D0E0      1472            pop acc 
108C C083      1473            push dph
108E C082      1473            push dpl
1090 C0E0      1473            push acc
1092 9004CF    1473            mov dptr, #LCD_soakTime
1095 1200BA    1473            lcall ?Send_Constant_String
1098 D0E0      1473            pop acc
109A D082      1473            pop dpl
109C D083      1473            pop dph
109E E54C      1474                   mov     a, time_soak
10A0 1206A9    1475                   lcall   SendToLCD
10A3 C083      1476            push dph
10A5 C082      1476            push dpl
10A7 C0E0      1476            push acc
10A9 90050D    1476            mov dptr, #LCD_clearLine
10AC 1200BA    1476            lcall ?Send_Constant_String
10AF D0E0      1476            pop acc
10B1 D082      1476            pop dpl
10B3 D083      1476            pop dph
10B5 02112A    1477                   ljmp    menu_FSM_done
10B8           1478   
10B8           1479           menuFSM_configReflow:
10B8 B40169    1480                   cjne    a, #MENU_STATE_REFLOW, reset_menu_state
10BB           1481                   ; display Reflow Menu Options
10BB C0E0      1482            push acc
10BD 7401      1482            mov a, #1
10BF 14        1482            dec a
10C0 1200C7    1482            lcall ?Set_Cursor_1 ; Select column and row
10C3 D0E0      1482            pop acc
10C5 C083      1483            push dph
10C7 C082      1483            push dpl
10C9 C0E0      1483            push acc
10CB 9004F3    1483            mov dptr, #LCD_reflowTemp
10CE 1200BA    1483            lcall ?Send_Constant_String
10D1 D0E0      1483            pop acc
10D3 D082      1483            pop dpl
10D5 D083      1483            pop dph
10D7 E54D      1484                   mov     a, temp_refl
10D9 1206A9    1485                   lcall   SendToLCD
10DC C083      1486            push dph
10DE C082      1486            push dpl
10E0 C0E0      1486            push acc
10E2 90050D    1486            mov dptr, #LCD_clearLine
10E5 1200BA    1486            lcall ?Send_Constant_String
10E8 D0E0      1486            pop acc
10EA D082      1486            pop dpl
10EC D083      1486            pop dph
10EE C0E0      1487            push acc
10F0 7401      1487            mov a, #1
10F2 14        1487            dec a
10F3 1200C5    1487            lcall ?Set_Cursor_2 ; Select column and row
10F6 D0E0      1487            pop acc
10F8 C083      1488            push dph
10FA C082      1488            push dpl
10FC C0E0      1488            push acc
10FE 9004E7    1488            mov dptr, #LCD_reflowTime
1101 1200BA    1488            lcall ?Send_Constant_String
1104 D0E0      1488            pop acc
1106 D082      1488            pop dpl
1108 D083      1488            pop dph
110A E54E      1489                   mov     a, time_refl
110C 1206A9    1490                   lcall   SendToLCD
110F C083      1491            push dph
1111 C082      1491            push dpl
1113 C0E0      1491            push acc
1115 90050D    1491            mov dptr, #LCD_clearLine
1118 1200BA    1491            lcall ?Send_Constant_String
111B D0E0      1491            pop acc
111D D082      1491            pop dpl
111F D083      1491            pop dph
1121 02112A    1492                   ljmp    menu_FSM_done
1124           1493   
1124           1494           reset_menu_state: ; sets menu state variable to 0
1124 754900    1495                   mov     MENU_STATE, #MENU_STATE_SOAK
1127 02112A    1496                   ljmp    menu_FSM_done
112A           1497   
112A           1498           menu_FSM_done:
112A 1205C6    1499                   lcall Save_Variables ; save variabels before exiting the menu FSM
112D 22        1500                   ret
112E           1501   
112E           1502   main_program:
112E           1503           ; George
112E 75817F    1504           mov     sp, #0x7f
1131 120902    1505           lcall   INIT_ALL
1134 120087    1506           lcall   LCD_4BIT
1137 C292      1507           clr     PWM_OUT
1139           1508   
1139           1509           ; Default display - 
1139           1510           ; Reflow oven controller 
1139           1511           ; (Start or Configure?)
1139           1512           PROGRAM_ENTRY:
1139 C0E0      1513            push acc
113B 7401      1513            mov a, #1
113D 14        1513            dec a
113E 1200C7    1513            lcall ?Set_Cursor_1 ; Select column and row
1141 D0E0      1513            pop acc
1143 C083      1514            push dph
1145 C082      1514            push dpl
1147 C0E0      1514            push acc
1149 9004AD    1514            mov dptr, #LCD_defaultTop
114C 1200BA    1514            lcall ?Send_Constant_String
114F D0E0      1514            pop acc
1151 D082      1514            pop dpl
1153 D083      1514            pop dph
1155 C0E0      1515            push acc
1157 7401      1515            mov a, #1
1159 14        1515            dec a
115A 1200C5    1515            lcall ?Set_Cursor_2 ; Select column and row
115D D0E0      1515            pop acc
115F C083      1516            push dph
1161 C082      1516            push dpl
1163 C0E0      1516            push acc
1165 9004BE    1516            mov dptr, #LCD_defaultBot
1168 1200BA    1516            lcall ?Send_Constant_String
116B D0E0      1516            pop acc
116D D082      1516            pop dpl
116F D083      1516            pop dph
1171           1517                   
1171 755800    1518                   mov  PWM, #0 ; sets PWM to zero
1174 C292      1519                   clr  PWM_OUT
1176           1520   
1176 D2CA      1521                   setb TR2 ; keep TR2 enabled
1178           1522   
1178           1523           checkStartButton: ; assumed negative logic - used a label for an easy ljmp in the future
1178 D208      1524           setb PB_START_PIN
117A D209      1524           setb PB_CHANGE_MENU_PIN
117C D20A      1524           setb PB_INC_TEMP_PIN
117E D20B      1524           setb PB_INC_TIME_PIN
1180 D20C      1524           setb PB_STOP_PIN
1182           1524           
1182 D295      1524           setb SHARED_PIN
1184           1524           ; check if any push buttons are pressed
1184 C293      1524           clr START_PIN             
1186 C281      1524           clr CHANGE_MENU_PIN       
1188 C282      1524           clr INC_TEMP_PIN          
118A C283      1524           clr INC_TIME_PIN          
118C C280      1524           clr STOP_PIN
118E           1524   
118E           1524           ; debounce
118E 209502    1524           jb SHARED_PIN, $+2+3 ; use helper label to jump to the end
1191 8003      1524           sjmp $+2+3
1193 0211FC    1524           ljmp noStartButtonPress
1196 C002      1524            push AR2
1198 7A32      1524            mov R2, #50
119A 120038    1524            lcall ?Wait_Milli_Seconds
119D D002      1524            pop AR2
119F 209502    1524           jb SHARED_PIN, $+2+3
11A2 8003      1524           sjmp $+2+3
11A4 0211FC    1524           ljmp noStartButtonPress
11A7           1524   
11A7           1524           ; Set the LCD data pins to logic 1
11A7 D293      1524           setb START_PIN
11A9 D281      1524           setb CHANGE_MENU_PIN
11AB D282      1524           setb INC_TEMP_PIN
11AD D283      1524           setb INC_TIME_PIN
11AF D280      1524           setb STOP_PIN
11B1           1524   
11B1           1524           ; check push buttons 1 by one
11B1 C293      1524           clr START_PIN
11B3 A295      1524           mov c, SHARED_PIN
11B5 9208      1524           mov PB_START_PIN, c
11B7 D293      1524           setb START_PIN
11B9           1524   
11B9 C281      1524           clr CHANGE_MENU_PIN
11BB A295      1524           mov c, SHARED_PIN
11BD 9209      1524           mov PB_CHANGE_MENU_PIN, c
11BF D281      1524           setb CHANGE_MENU_PIN
11C1           1524   
11C1 C282      1524           clr INC_TEMP_PIN
11C3 A295      1524           mov c, SHARED_PIN
11C5 920A      1524           mov PB_INC_TEMP_PIN, c
11C7 D282      1524           setb INC_TEMP_PIN
11C9           1524   
11C9 C283      1524           clr INC_TIME_PIN
11CB A295      1524           mov c, SHARED_PIN
11CD 920B      1524           mov PB_INC_TIME_PIN, c
11CF D283      1524           setb INC_TIME_PIN
11D1           1524   
11D1 C280      1524           clr STOP_PIN
11D3 A295      1524           mov c, SHARED_PIN
11D5 920C      1524           mov PB_STOP_PIN, c
11D7 D280      1524           setb STOP_PIN
11D9           1524   
11D9           1524           ; jb PB_START_PIN, noStartButtonPress ; check that the variable flag is not 1, otherwise jmp
11D9           1524   
11D9 200802    1524           jb PB_START_PIN, $+2+3 ; check that the variable flag is not 1, otherwise jmp
11DC 8003      1524           sjmp $+2+3
11DE 0211FC    1524           ljmp noStartButtonPress     ; can access anypart of the code
11E1           1524   
11E1 D204      1525                   setb    ENABLE_SEC_INC_FLAG 
11E3 D205      1526                   setb    TIME_TO_BEEP_FLAG
11E5 D28C      1527                   setb    TR0
11E7           1528   
11E7           1529                   ; Send 0 to the serial 
11E7           1530                   ; Condition: In main menu and start button is pressed
11E7 753C00    1531                   mov BCD+0, #0x0
11EA 753D00    1532                   mov BCD+1, #0x0
11ED 753E00    1533                   mov BCD+2, #0x0
11F0 753F00    1534                   mov BCD+3, #0x0
11F3 754000    1535                   mov BCD+4, #0x0
11F6 1208BA    1536                   lcall send_temp_to_serial
11F9           1537                   ;mov a,  #'\r' ; Return character # removed bc send_temp_to_serial accounts for this
11F9           1538                   ;lcall   putchar
11F9           1539                   ;mov a,  #'\n' ; New-line character
11F9           1540                   ;lcall   putchar
11F9           1541   
11F9 021278    1542                   ljmp    enter_oven_fsm ; successful button press, enter oven FSM   
11FC           1543   
11FC           1544           noStartButtonPress:
11FC D293      1545                   setb    START_PIN
11FE           1546                   ; if the 'IN_MENU' flag is set, always enter into the menu FSM, this is so that the menu FSM can always be entered
11FE           1547                   ; creates an infinite loop that will always display menu once entered - broken if START button pressed
11FE 300106    1548                   jnb     IN_MENU_FLAG, checkMenuButtonPress
1201 120E63    1549                   lcall   MENU_FSM 
1204 021178    1550                   ljmp    checkStartButton
1207           1551   
1207           1552           checkMenuButtonPress:
1207           1553                   ; check for enter menu button press (reusing increment menu pin)
1207 D208      1554           setb PB_START_PIN
1209 D209      1554           setb PB_CHANGE_MENU_PIN
120B D20A      1554           setb PB_INC_TEMP_PIN
120D D20B      1554           setb PB_INC_TIME_PIN
120F D20C      1554           setb PB_STOP_PIN
1211           1554           
1211 D295      1554           setb SHARED_PIN
1213           1554           ; check if any push buttons are pressed
1213 C293      1554           clr START_PIN             
1215 C281      1554           clr CHANGE_MENU_PIN       
1217 C282      1554           clr INC_TEMP_PIN          
1219 C283      1554           clr INC_TIME_PIN          
121B C280      1554           clr STOP_PIN
121D           1554   
121D           1554           ; debounce
121D 209502    1554           jb SHARED_PIN, $+2+3 ; use helper label to jump to the end
1220 8003      1554           sjmp $+2+3
1222 021273    1554           ljmp noMenuButtonPress
1225 C002      1554            push AR2
1227 7A32      1554            mov R2, #50
1229 120038    1554            lcall ?Wait_Milli_Seconds
122C D002      1554            pop AR2
122E 209502    1554           jb SHARED_PIN, $+2+3
1231 8003      1554           sjmp $+2+3
1233 021273    1554           ljmp noMenuButtonPress
1236           1554   
1236           1554           ; Set the LCD data pins to logic 1
1236 D293      1554           setb START_PIN
1238 D281      1554           setb CHANGE_MENU_PIN
123A D282      1554           setb INC_TEMP_PIN
123C D283      1554           setb INC_TIME_PIN
123E D280      1554           setb STOP_PIN
1240           1554   
1240           1554           ; check push buttons 1 by one
1240 C293      1554           clr START_PIN
1242 A295      1554           mov c, SHARED_PIN
1244 9208      1554           mov PB_START_PIN, c
1246 D293      1554           setb START_PIN
1248           1554   
1248 C281      1554           clr CHANGE_MENU_PIN
124A A295      1554           mov c, SHARED_PIN
124C 9209      1554           mov PB_CHANGE_MENU_PIN, c
124E D281      1554           setb CHANGE_MENU_PIN
1250           1554   
1250 C282      1554           clr INC_TEMP_PIN
1252 A295      1554           mov c, SHARED_PIN
1254 920A      1554           mov PB_INC_TEMP_PIN, c
1256 D282      1554           setb INC_TEMP_PIN
1258           1554   
1258 C283      1554           clr INC_TIME_PIN
125A A295      1554           mov c, SHARED_PIN
125C 920B      1554           mov PB_INC_TIME_PIN, c
125E D283      1554           setb INC_TIME_PIN
1260           1554   
1260 C280      1554           clr STOP_PIN
1262 A295      1554           mov c, SHARED_PIN
1264 920C      1554           mov PB_STOP_PIN, c
1266 D280      1554           setb STOP_PIN
1268           1554   
1268           1554           ; jb PB_CHANGE_MENU_PIN, noMenuButtonPress ; check that the variable flag is not 1, otherwise jmp
1268           1554   
1268 200902    1554           jb PB_CHANGE_MENU_PIN, $+2+3 ; check that the variable flag is not 1, otherwise jmp
126B 8003      1554           sjmp $+2+3
126D 021273    1554           ljmp noMenuButtonPress     ; can access anypart of the code
1270           1554   
1270           1555                   ; setb IN_MENU_FLAG; successful button press, enter menu FSM loop ; - THIS LINE CAUSES THE BUG
1270 0212BA    1556                   ljmp    setMenuFlag
1273           1557                   
1273           1558           noMenuButtonPress:
1273 D281      1559                   setb CHANGE_MENU_PIN
1275 021178    1560                   ljmp    checkStartButton ; this line does not execute if ljmp setMenuFlag is there?!?!?
1278           1561   
1278           1562           enter_oven_fsm:
1278 C201      1563                   clr     IN_MENU_FLAG ; No longer in menu
127A D202      1564                   setb    IN_OVEN_FLAG
127C C0E0      1565            push acc
127E 7401      1565            mov a, #1
1280 14        1565            dec a
1281 1200C7    1565            lcall ?Set_Cursor_1 ; Select column and row
1284 D0E0      1565            pop acc
1286 C083      1566            push dph
1288 C082      1566            push dpl
128A C0E0      1566            push acc
128C 90050D    1566            mov dptr, #LCD_clearLine
128F 1200BA    1566            lcall ?Send_Constant_String
1292 D0E0      1566            pop acc
1294 D082      1566            pop dpl
1296 D083      1566            pop dph
1298 C0E0      1567            push acc
129A 7401      1567            mov a, #1
129C 14        1567            dec a
129D 1200C5    1567            lcall ?Set_Cursor_2 ; Select column and row
12A0 D0E0      1567            pop acc
12A2 C083      1568            push dph
12A4 C082      1568            push dpl
12A6 C0E0      1568            push acc
12A8 90050D    1568            mov dptr, #LCD_clearLine
12AB 1200BA    1568            lcall ?Send_Constant_String
12AE D0E0      1568            pop acc
12B0 D082      1568            pop dpl
12B2 D083      1568            pop dph
12B4           1569                   ; lcall   Timer2_Init  
12B4 1209BE    1570                   lcall   OVEN_FSM     ; `OVEN_FSM` exit by calling STOP_PROCESS which then loops back to the entry point
12B7 120990    1571                   lcall   STOP_PROCESS ; added for safety
12BA           1572                   
12BA           1573           setMenuFlag: 
12BA D201      1574                   setb    IN_MENU_FLAG
12BC 021178    1575                   ljmp    checkStartButton
12BF           1576   
12BF           1577           program_end:
12BF 02112E    1578                   ljmp    main_program
12C2           1579   END
