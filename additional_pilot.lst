0000              1   
0000              2   
0000              3   ; Main file. FSM implementing the following sequence:
0000              4   ;       State 0: Power = 0% (default state)
0000              5   ;               if start = NO, self loop; if start = YES, next state
0000              6   ;       State 1: Power = 100%; Sec = 0
0000              7   ;               if temp <= 150, self loop; temp > 150, next
0000              8   ;       State 2: Power = 20%
0000              9   ;               if sec <= 60s, self loop; sec>60s, next
0000             10   ;       State 3: Power = 100%; Sec = 0
0000             11   ;               if temp <= 220, self loop; temp>220, next
0000             12   ;       State 4: Power = 20%
0000             13   ;               if sec <= 45s, self loop; sec >45, next
0000             14   ;       State 5: Power = 0%
0000             15   ;               if temp >=60, self loop; temp <60, next
0000             16   ;       return to state 0
0000             17   
0000             18   
0000             19   ; MACROS ;
                 20   CLJNE mac  
                 21       cjne %0, %1, $+3+2 ; Jump if no equal 2 bytes ahead since sjmp is a 2 byte instruction  
                 22       sjmp $+2+3 ; Jump 3 bytes after this instruction as ljmp takes 3 bytes to encode
                 23       ljmp %2 ; ljmp can access any part of the code space
                 24   endmac
0000             25   
0000             26   ; check_Push_Button(variable_flag, dest_label)
0000             27   ; Params
0000             28   ; variable_flag - variable we are checking in place of the pin e.g. PB_START_PIN
0000             29   ; dest_label - where to jump if a push button is not pressed
                 30   check_Push_Button MAC ; new one with multiplexed buttons
                 31           setb PB_START_PIN
                 32           setb PB_CHANGE_MENU_PIN
                 33           setb PB_INC_TEMP_PIN
                 34           setb PB_INC_TIME_PIN
                 35           setb PB_STOP_PIN
                 36           
                 37           setb SHARED_PIN
                 38           ; check if any push buttons are pressed
                 39           clr START_PIN             
                 40           clr CHANGE_MENU_PIN       
                 41           clr INC_TEMP_PIN          
                 42           clr INC_TIME_PIN          
                 43           clr STOP_PIN
                 44   
                 45           ; debounce
                 46           jb SHARED_PIN, %1 ; use helper label to jump to the end
                 47           Wait_Milli_Seconds(#50)
                 48           jb SHARED_PIN, %1
                 49   
                 50           ; Set the LCD data pins to logic 1
                 51           setb START_PIN
                 52           setb CHANGE_MENU_PIN
                 53           setb INC_TEMP_PIN
                 54           setb INC_TIME_PIN
                 55           setb STOP_PIN
                 56   
                 57           ; check push buttons 1 by one
                 58           clr START_PIN
                 59           mov c, SHARED_PIN
                 60           mov PB_START_PIN, c
                 61           setb START_PIN
                 62   
                 63           clr CHANGE_MENU_PIN
                 64           mov c, SHARED_PIN
                 65           mov PB_CHANGE_MENU_PIN, c
                 66           setb CHANGE_MENU_PIN
                 67   
                 68           clr INC_TEMP_PIN
                 69           mov c, SHARED_PIN
                 70           mov PB_INC_TEMP_PIN, c
                 71           setb INC_TEMP_PIN
                 72   
                 73           clr INC_TIME_PIN
                 74           mov c, SHARED_PIN
                 75           mov PB_INC_TIME_PIN, c
                 76           setb INC_TIME_PIN
                 77   
                 78           clr STOP_PIN
                 79           mov c, SHARED_PIN
                 80           mov PB_STOP_PIN, c
                 81           setb STOP_PIN
                 82   
                 83           jb %0, %1 ; check that the variable flag is not 1, otherwise jmp
                 84   
                 85   ENDMAC
0000             86   
0000             87   ; temp_gt_threshold(threshold_temp, new_oven_state)
0000             88   ; assumes that x has current temp value
0000             89   ; new_oven_state is a constant
                 90   temp_gt_threshold MAC
                 91           load_y(%0 * 10000)
                 92   
                 93           lcall x_gt_y
                 94           jnb mf, $+3+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
                 95           mov OVEN_STATE, %1 
                 96           mov seconds_elapsed, #0
                 97           ljmp oven_FSM_done
                 98   
                 99   ENDMAC
0000            100   
                101   temp_lt_threshold MAC
                102           load_y(%0 * 10000)
                103   
                104           lcall x_lt_y
                105           jnb mf, $+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
                106           mov OVEN_STATE, %1 
                107           ljmp oven_FSM_done
                108   
                109   ENDMAC
0000            110   
                112   $LIST
0000            114   
0000            115   ;  N76E003 pinout:
0000            116   ;                               -------
0000            117   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000            118   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000            119   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000            120   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000            121   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000            122   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000            123   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000            124   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000            125   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000            126   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000            127   ;                               -------
0000            128   
0000            129   
0000            130   
0000            131   ;-------------------------------------------------------------------------------------------------------------------------------------
0000            132   
0000            133   ;                                                              STYLE GUIDE
0000            134   
0000            135   ; End flag names with _FLAG
0000            136   ; Use all upper case for constants (anything defined in equ or pin definitions), as it makes it easier to read quickly
0000            137   ; Before any jump or logic block comment purpose and try to comment throughout - code should be self explanatory, comment "why" it was implemented this way
0000            138   ; Before any block of code also comment who wrote it 
0000            139   ; Aim for variable names with 8-20 characters
0000            140   
0000            141   ; --------------------------------------------------------------------------------------------------------------------------
0000            142   
0000            143   
0000            144   ; Timer constants
0000            145   CLK                   EQU 16600000 ; Microcontroller system frequency in Hz
0000            146   BAUD                  EQU 115200   ; Baud rate of UART in bps 
0000            147   TIMER1_RELOAD         EQU (0x100-(CLK/(16*BAUD))) ; Serial ISR
0000            148   TIMER2_RELOAD         EQU (65536-(CLK/1000))      ; 1ms Delay ISR
0000            149   TIMER0_RELOAD         EQU (0x10000-(CLK/4096))    ; Sound ISR For 2kHz square wave
0000            150   
0000            151   ; Pin definitions + Hardware Wiring 
0000            152   ; Layout
0000            153   ; {Start} {Stop} {Change Menu} {Inc Temp} {Inc Time}
0000            154   START_PIN             EQU P1.3 
0000            155   CHANGE_MENU_PIN       EQU P0.1 
0000            156   INC_TEMP_PIN          EQU P0.2  
0000            157   INC_TIME_PIN          EQU P0.3  
0000            158   STOP_PIN              EQU P0.0  
0000            159   SHARED_PIN            EQU P1.5 
0000            160   
0000            161   PWM_OUT               EQU P1.2 ; Pin 13
0000            162   
0000            163   ; FSM uses integer state encodings
0000            164   ; Menu states
0000            165   MENU_STATE_SOAK       EQU 0
0000            166   MENU_STATE_REFLOW     EQU 1
0000            167   MENU_STATE_TEST       EQU 2
0000            168   
0000            169   ; oven states
0000            170   OVEN_STATE_PREHEAT    EQU 0
0000            171   OVEN_STATE_SOAK       EQU 1
0000            172   OVEN_STATE_RAMP2PEAK  EQU 2
0000            173   OVEN_STATE_REFLOW     EQU 3
0000            174   OVEN_STATE_COOLING    EQU 4
0000            175   OVEN_STATE_FINISHED   EQU 5
0000            176   
0000            177   ; things to keep track of
0000            178   COOLED_TEMP           EQU 50 ; once cooled to this temperature, the reflow is now "finished"
0000            179   COOLED_TEMP_LOAD_MATH EQU COOLED_TEMP*10000 ; use to load up the math
0000            180   FINISHED_SECONDS      EQU 5
0000            181   MAX_TIME              EQU 90
0000            182   MIN_TIME              EQU 45
0000            183   MAX_TEMP              EQU 250
0000            184   MIN_TEMP              EQU 80
0000            185   
0000            186   ; define vectors
0000            187   ORG 0x0000 ; Reset vector
0000 020E6C     188           ljmp main_program
0003            189   ORG 0x0003 ; External interrupt 0 vector
0003 32         190           reti
000B            191   ORG 0x000B ; Timer/Counter 0 overflow interrupt vector
000B 02058E     192            ljmp Timer0_ISR
0013            193   ORG 0x0013 ; External interrupt 1 vector
0013 32         194            reti
001B            195   ORG 0x001B ; Timer/Counter 1 overflow interrupt vector 
001B 32         196            reti
0023            197   ORG 0x0023 ; Serial port receive/transmit interrupt vector 
0023 32         198            reti
002B            199   ORG 0x002B ; Timer/Counter 2 overflow interrupt vector
002B 02059E     200            ljmp Timer2_ISR
002E            201   
002E            202   
002E            203   ; register definitions previously needed by 'math32.inc' - currently commented out for future changes
0030            204   DSEG at 0x30
0030            205   x               : ds 4
0034            206   y               : ds 4
0038            207   z               : ds 4
003C            208   bcd             : ds 5
0041            209   bcdf            : ds 5
0046            210   VLED_ADC        : ds 2
0048            211   
0048            212   OVEN_STATE      : ds 1 ; stores oven FSM state
0049            213   MENU_STATE      : ds 1 ; stores menu FSM state
004A            214   temp_soak       : ds 1 
004B            215   time_soak       : ds 1
004C            216   temp_refl       : ds 1
004D            217   time_refl       : ds 1
004E            218   ; pwm             : ds 1 ; controls output power to SSR
004E            219   ; pwm_counter     : ds 1 
004E            220   
004E            221   Count1ms        : ds 2 ; determines the number of 1ms increments that have passed 
0050            222   Count1ms0        : ds 2
0052            223   Count1ms_PWM    : ds 1
0053            224   seconds_elapsed  : ds 1
0054            225   exit_seconds    : ds 1 ; if we dont reach 50 c before 60 S terminate
0055            226   total_seconds   : ds 1 ; total runtime
0056            227   
0056            228   pwm_counter: ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0057            229   pwm: ds 1 ; pwm percentage
0058            230   
0058            231   
002E            232   CSEG ;starts the absolute segment from that address
002E            233   ; These 'EQU' must match the hardware wiring
002E            234   LCD_RS          EQU P1.3
002E            235   ;LCD_RW         EQU PX.X ; Not used in this code, connect the pin to GND
002E            236   LCD_E           EQU P1.4
002E            237   LCD_D4          EQU P0.0
002E            238   LCD_D5          EQU P0.1
002E            239   LCD_D6          EQU P0.2
002E            240   LCD_D7          EQU P0.3
002E            241   
002E            242   SOUND_OUT       EQU P0.4
                244   	$LIST
00E2            246   
00E2            247   ; Flags that are used to control events 
0000            248   BSEG 
0000            249   mf                  : dbit 1
0001            250   IN_MENU_FLAG        : dbit 1
0002            251   IN_OVEN_FLAG        : dbit 1
0003            252   REFLOW_FLAG         : dbit 1
0004            253   ENABLE_SEC_INC_FLAG : dbit 1 ; used to control whether seconds incrementing is enabled 
0005            254   TIME_TO_BEEP_FLAG   : dbit 1 ; state transition flag; set to high whenever entering a new state 
0006            255   SYSTEM_DONE_FLAG    : dbit 1 ; used for controlling the final beeping routine
0007            256   BEEP_SECOND_FLAG    : dbit 1
0008            257   
0008            258   ; Variables used for push button mux
0008            259   PB_START_PIN        : dbit 1
0009            260   PB_CHANGE_MENU_PIN  : dbit 1
000A            261   PB_INC_TEMP_PIN     : dbit 1
000B            262   PB_INC_TIME_PIN     : dbit 1
000C            263   PB_STOP_PIN         : dbit 1
000D            264   
                707   $LIST
                266   $LIST
0401            268   
0401            269   ; Messages to display on LCD when in Menu FSM
0401 5265666C   270   LCD_defaultTop  : db 'Reflow Oven:    ', 0
     6F77204F
     76656E3A
     20202020
     00
0412 53746172   271   LCD_defaultBot  : db 'Start/Configure?', 0
     742F436F
     6E666967
     7572653F
     00
0423 536F616B   272   LCD_soakTime    : db 'Soak Time: ', 0
     2054696D
     653A2000
042F 536F616B   273   LCD_soakTemp    : db 'Soak Temp: ', 0
     2054656D
     703A2000
043B 5265666C   274   LCD_reflowTime  : db 'Refl Time: ', 0
     2054696D
     653A2000
0447 5265666C   275   LCD_reflowTemp  : db 'Refl Temp: ', 0
     2054656D
     703A2000
0453 54455354   276   LCD_TEST        : db 'TEST MESSAGE ', 0
     204D4553
     53414745
     2000
0461 20202020   277   LCD_clearLine   : db '                ', 0 ; put at end to clear line
     20202020
     20202020
     20202020
     00
0472            278   
0472 50726568   279   preheatMessage  : db 'Preheat', 0
     65617400
047A 536F616B   280   soakMessage     : db 'Soak', 0
     00
047F 52616D70   281   ramp2peakMessage: db 'Ramp to Peak', 0
     20746F20
     5065616B
     00
048C 5265666C   282   reflowMessage   : db 'Reflow', 0
     6F7700
0493 436F6F6C   283   coolingMessage  : db 'Cooling', 0
     696E6700
049B 46696E69   284   FinishedMessage : db 'Finished!', 0
     73686564
     2100
04A5 454D4552   285   stopMessage     : db 'EMERGENCY STOP', 0
     47454E43
     59205354
     4F5000
04B4            286   
04B4            287   ; -- Debug messages
04B4            288   ; seonds_passed   : db 'Seconds: ', 0
04B4            289   ; temp            : db 'Temp: ', 0
04B4            290   ; ovenState       : db 'State: ', 0
04B4            291   ; errorMessage    : db '** ERROR **', 0
04B4            292   
04B4            293   emergency:
04B4 456D6572   294       DB  'Emergency Stop!', '\r', '\n', 0
     67656E63
     79205374
     6F70210D
     0A00
04C6            295   
04C6            296   soak:
04C6 79207661   297       DB  'y val from soak temp: ', 0
     6C206672
     6F6D2073
     6F616B20
     74656D70
     3A2000
04DD            298   
04DD            299   reflow:
04DD 79207661   300       DB  'y val from reflow temp: ',0
     6C206672
     6F6D2072
     65666C6F
     77207465
     6D703A20
     00
04F6            301   
04F6            302   soakTempLog:
04F6 536F616B   303       DB 'Soak Temp: ', 0
     2054656D
     703A2000
0502            304   
0502            305   reflowTempLog:
0502 5265666C   306       DB 'Reflow Temp: ', 0
     6F772054
     656D703A
     2000
0510            307   
0510            308   ; Messages to display on LCD when in Oven Controller FSM
0510            309   
0510            310   ; Send a character using the serial port
0510            311   putchar:
0510 3099FD     312           jnb     TI, putchar
0513 C299       313           clr     TI
0515 F599       314           mov     SBUF, a
0517 22         315           ret
0518            316   
0518            317   ; Send a constant-zero-terminated string using the serial port
0518            318   SendString:
0518 E4         319           clr     A
0519 93         320           movc    A, @A+DPTR
051A 6006       321           jz      SendStringDone
051C 120510     322           lcall   putchar
051F A3         323           inc     DPTR
0520 80F6       324           sjmp    SendString
0522            325   SendStringDone:
0522 22         326           ret
0523            327   
0523            328   ; Eight bit number to display passed in ’a’.
0523            329   SendToLCD:
0523 75F064     330           mov     b, #100
0526 84         331           div     ab
0527 4430       332           orl     a, #0x30 ; Convert hundreds to ASCII
0529 12007D     333           lcall   ?WriteData ; Send to LCD
052C E5F0       334           mov     a, b ; Remainder is in register b
052E 75F00A     335           mov     b, #10
0531 84         336           div     ab
0532 4430       337           orl     a, #0x30 ; Convert tens to ASCII
0534 12007D     338           lcall   ?WriteData; Send to LCD
0537 E5F0       339           mov     a, b
0539 4430       340           orl     a, #0x30 ; Convert units to ASCII
053B 12007D     341           lcall   ?WriteData; Send to LCD
053E 22         342           ret
053F            343   
053F            344   ; Eight bit number to display passed in ’a’.
053F            345   SendToSerialPort:
053F 75F064     346           mov     b, #100
0542 84         347           div     ab
0543 4430       348           orl     a, #0x30 ; Convert hundreds to ASCII
0545 120510     349           lcall   putchar ; Send to PuTTY/Python/Matlab
0548 E5F0       350           mov     a, b ; Remainder is in register b
054A 75F00A     351           mov     b, #10
054D 84         352           div     ab
054E 4430       353           orl     a, #0x30 ; Convert tens to ASCII
0550 120510     354           lcall   putchar ; Send to PuTTY/Python/Matlab
0553 E5F0       355           mov     a, b
0555 4430       356           orl     a, #0x30 ; Convert units to ASCII
0557 120510     357           lcall   putchar ; Send to PuTTY/Python/Matlab
055A 22         358           ret
055B            359   
055B            360   ;---------------------------------;
055B            361   ; Routine to initialize the ISR   ;
055B            362   ; for timer 0                     ;
055B            363   ;---------------------------------;
055B            364   Timer0_Init:
055B 438E08     365            orl     CKCON, #0b00001000 ; Input for timer 0 is sysclk/1 ; performs bit masking on CKON - Clock Control ; T0M = 1, timer 0 uses the system clock directly
055E E589       366            mov     a, TMOD
0560 54F0       367            anl     a, #0xf0 ; 11110000 Clear the bits for timer 0
0562 4401       368            orl     a, #0x01 ; 00000001 Configure timer 0 as 16-timer (M1M0 = 01 -> Mode 1: 16-bit Timer/Counter)
0564 F589       369            mov     TMOD, a
0566 758CF0     370            mov     TH0, #high(TIMER0_RELOAD) ; 8051 works with 8 bits so the oepration T0 = TIMER0_RELOAD  (16 bits) is done by setting high byte then low byte (8x2)
0569 758A2C     371            mov     TL0, #low (TIMER0_RELOAD)
056C            372            ; Enable the timer and interrupts
056C D2A9       373           setb    ET0  ; Enable timer 0 interrupt
056E D28C       374           setb    TR0  ; Start timer 0
0570 22         375            ret
0571            376   
0571            377   ;---------------------------------;
0571            378   ; Routine to initialize the ISR   ;
0571            379   ; for timer 2                     ;
0571            380   ;---------------------------------;
0571            381   Timer2_Init:
0571 75C800     382            mov     T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0574 75CDBF     383            mov     TH2, #high(TIMER2_RELOAD)
0577 75CC28     384            mov     TL2, #low(TIMER2_RELOAD)
057A            385            ; Set the reload value
057A 43C980     386            orl     T2MOD, #0x80 ; Enable timer 2 autoreload
057D 75CBBF     387            mov     RCMP2H, #high(TIMER2_RELOAD)
0580 75CA28     388            mov     RCMP2L, #low(TIMER2_RELOAD)
0583            389            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0583 E4         390            clr     a
0584 F54E       391            mov     Count1ms+0, a
0586 F54F       392            mov     Count1ms+1, a
0588            393            ; Enable the timer and interrupts
0588 439B80     394            orl     EIE, #0x80 ; Enable timer 2 interrupt ET2=1
058B D2CA       395           setb    TR2  ; Enable timer 2
058D 22         396            ret
058E            397   
058E            398   Timer0_ISR: ; PASTED- AL
058E            399           ;clr TF0  ; According to the data sheet this is done for us already.
058E            400            ; Timer 0 doesn't have 16-bit auto-reload, so
058E C28C       401            clr TR0
0590            402           
0590 758CF0     403            mov TH0, #high(TIMER0_RELOAD)
0593 758A2C     404            mov TL0, #low(TIMER0_RELOAD)
0596 D28C       405            setb TR0
0598            406   
0598            407   
0598 300502     408           jnb TIME_TO_BEEP_FLAG, Early_Exit
059B B284       409            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
059D            410   
059D            411       Early_Exit:
059D            412    
059D 32         413           reti
059E            414   
059E            415   ;---------------------------------;
059E            416   ; ISR for timer 2                 ;
059E            417   ;---------------------------------;
059E            418   Timer2_ISR:
059E C2CF       419           clr     TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
05A0            420           ; cpl     P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
05A0            421   
05A0            422           ; The two registers used in the ISR must be saved in the stack
05A0 C0E0       423           push    acc
05A2 C0D0       424           push    psw
05A4            425   
05A4 0552       426           inc     Count1ms_PWM   ; variable used to count every 10ms used for the PWM
05A6            427   
05A6            428           ; Increment the 16-bit one mili second counter
05A6 054E       429           inc     Count1ms+0    ; Increment the low 8-bits first
05A8 E54E       430           mov     a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
05AA 7002       431           jnz     Inc_done
05AC 054F       432           inc     Count1ms+1    
05AE            433   
05AE            434   
05AE            435           
05AE            436           Inc_done:
05AE            437           ; If not in oven, skip PWM
05AE 30021D     438           jnb    IN_OVEN_FLAG, skipPWM
05B1 E552       439           mov    a, Count1ms_PWM ; 
05B3            440   
05B3            441   
05B3            442           ; This check is done so that this subroutine executes every 10ms 
05B3 B40A18     443           cjne    a, #10, check10msPassed 
05B6 755200     444                   mov Count1ms_PWM, #0
05B9            445                   ;GL PWM code that Jesus gave
05B9            446                   ;RK working on PWM
05B9 0556       447                   inc     pwm_counter
05BB C3         448                   clr     c
05BC E557       449                   mov     a, pwm
05BE 9556       450                   subb    a, pwm_counter ; If pwm_counter <= pwm then c=1
05C0 B3         451                   cpl     c
05C1 9292       452                   mov     PWM_OUT, c 
05C3 E556       453                   mov     a, pwm_counter
05C5            454                   ; cjne    a, #100, Timer2_ISR_done ; why does this go to Timer2_ISR_done? - GL
05C5 B46406     455                   cjne    a, #100, check10msPassed ; changed label from `Timer2_ISR_done` to `check10msPassed`
05C8 755600     456                   mov     pwm_counter, #0
05CB            457   
05CB E4         458                   clr     a
05CC F552       459                   mov     Count1ms_PWM, a ; reset the 1ms for PWM counter
05CE            460           
05CE            461                   
05CE            462           check10msPassed:
05CE            463           skipPWM:
05CE            464           ; Check if one second has passed
05CE E54E       465            mov     a, Count1ms+0
05D0 B4E83C     466            cjne    a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
05D3 E54F       467            mov     a, Count1ms+1
05D5 B40337     468            cjne    a, #high(1000), Timer2_ISR_done         
05D8            469   
05D8            470           ; ---  1s has passed ----
05D8 C205       471           clr   TIME_TO_BEEP_FLAG
05DA 1206D0     472           lcall DO_TEMP_READ
05DD 1200E2     473           lcall hex2bcd ; puts value of x into BCD varaibles
05E0 120743     474           lcall send_temp_to_serial
05E3            475           
05E3 E4         476           clr     a
05E4 F54E       477           mov     Count1ms+0, a
05E6 F54F       478           mov     Count1ms+1, a
05E8            479           
05E8            480           ; -------- Log File -------
05E8 E557       481           mov a,  PWM
05EA 12053F     482           lcall   SendToSerialPort
05ED 740D       483           mov a,  #'\r' ; Return character
05EF 120510     484           lcall   putchar
05F2 740A       485           mov a,  #'\n' ; New-line character
05F4 120510     486           lcall   putchar
05F7            487   
05F7            488           ; mov a,  seconds_elapsed
05F7            489           ; lcall   SendToSerialPort
05F7            490           ; mov a,  #'\r' ; Return character
05F7            491           ; lcall   putchar
05F7            492           ; mov a,  #'\n' ; New-line character
05F7            493           ; lcall   putchar
05F7            494   
05F7            495           ; mov a, OVEN_STATE
05F7            496           ; add A, #1
05F7            497           ; mov OVEN_STATE, a
05F7            498   
05F7            499           ; mov DPTR, #soakTempLog
05F7            500           ; lcall SendString
05F7            501           ; mov a, temp_soak
05F7            502           ; lcall SendToSerialPort
05F7            503           ; mov a,  #'\r' ; Return character
05F7            504           ; lcall   putchar
05F7            505           ; mov a,  #'\n' ; New-line character
05F7            506           ; lcall   putchar
05F7            507   
05F7            508           ; mov DPTR, #reflowTempLog
05F7            509           ; lcall SendString
05F7            510           ; mov a, temp_refl
05F7            511           ; lcall SendToSerialPort
05F7            512           ; mov a,  #'\r' ; Return character
05F7            513           ; lcall   putchar
05F7            514           ; mov a,  #'\n' ; New-line character
05F7            515           ; lcall   putchar
05F7            516   
05F7 300306     517           jnb     REFLOW_FLAG,  not_in_reflow ;Checks if we are in reflow state
05FA E554       518           mov     a, exit_seconds             ;Increments the early exit seconds counter
05FC 2401       519           add     a, #1
05FE F554       520           mov     exit_seconds, a
0600            521           
0600            522    not_in_reflow:
0600            523           ; Check a flag for inc. seconds, otherwise go to end of timer, Timer2_ISR_done label used to save a line
0600 30040C     524           jnb     ENABLE_SEC_INC_FLAG, Timer2_ISR_done
0603 E553       525           mov     a, seconds_elapsed
0605 2401       526           add     A, #1
0607 F553       527           mov     seconds_elapsed, a
0609 E555       528           mov     a, total_seconds
060B 2401       529           add     a, #1
060D F555       530           mov     total_seconds, a
060F            531           
060F            532           Timer2_ISR_done:
060F            533           ; reset seconds ms counter
060F            534           
060F D0D0       535           pop     psw
0611 D0E0       536            pop     acc
0613 32         537           reti
0614            538   
0614            539   
0614            540   Display_formated_BCD:
0614 C0E0       541            push acc
0616 7401       541            mov a, #1
0618 14         541            dec a
0619 1200C5     541            lcall ?Set_Cursor_2 ; Select column and row
061C D0E0       541            pop acc
061E C000       542            push ar0
0620 A83F       542            mov r0, bcd+3
0622 1200CC     542            lcall ?Display_BCD
0625 D000       542            pop ar0
0627 C000       543            push ar0
0629 A83E       543            mov r0, bcd+2
062B 1200CC     543            lcall ?Display_BCD
062E D000       543            pop ar0
0630 C0E0       544            push acc
0632 742E       544            mov a, #'.'
0634 12007D     544            lcall ?WriteData
0637 D0E0       544            pop acc
0639 C000       545            push ar0
063B A83D       545            mov r0, bcd+1
063D 1200CC     545            lcall ?Display_BCD
0640 D000       545            pop ar0
0642 C000       546            push ar0
0644 A83C       546            mov r0, bcd+0
0646 1200CC     546            lcall ?Display_BCD
0649 D000       546            pop ar0
064B 22         547   ret
064C            548   
064C            549   
064C            550   InitSerialPort:
064C            551       ; Since the reset button bounces, we need to wait a bit before
064C            552       ; sending messages, otherwise we risk displaying gibberish!
064C 79C8       553       mov R1, #200
064E 7868       554       mov R0, #104
0650 D8FE       555       djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
0652 D9FA       556       djnz R1, $-4 ; 25us*200=5.0ms
0654            557   
0654            558       ; Now we can proceed with the configuration of the serial port
0654 438E10     559            orl     CKCON, #0x10 ; CLK is the input for timer 1
0657 438780     560            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
065A 759852     561            mov     SCON, #0x52
065D 53C4DF     562            anl     T3CON, #0b11011111
0660 53890F     563            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0663 438920     564            orl     TMOD, #0x20 ; Timer 1 Mode 2
0666 758DF7     565            mov     TH1, #TIMER1_RELOAD
0669 D28E       566            setb TR1
066B 22         567           ret
066C            568           
066C            569   ;jesus' beautiful averaging code, can be used in place of Read_ADC in place where we read
066C            570   Average_ADC:
066C 753000     571            mov x+0, #low (0 % 0x10000) 
066F 753100     571            mov x+1, #high(0 % 0x10000) 
0672 753200     571            mov x+2, #low (0 / 0x10000) 
0675 753300     571            mov x+3, #high(0 / 0x10000) 
0678 7D64       572           mov R5, #100
067A 7E64       573           mov R6, #100
067C            574   
067C            575           Sum_loop0:
067C 1206B5     576           lcall Read_ADC
067F 753700     577           mov y+3, #0
0682 753600     578           mov y+2, #0
0685 8935       579           mov y+1, R1
0687 8834       580           mov y+0, R0
0689            581   
0689 C030       582           push x
068B 7530FC     583            mov x+0, #low (34300 % 0x10000) 
068E 753185     583            mov x+1, #high(34300 % 0x10000) 
0691 753200     583            mov x+2, #low (34300 / 0x10000) 
0694 753300     583            mov x+3, #high(34300 / 0x10000) 
0697 120274     584           lcall x_lteq_y
069A 200007     585           jb mf, skipval
069D D030       586           pop x
069F            587   
069F 1201A7     588           lcall add32
06A2 DDD8       589           djnz R5, Sum_loop0
06A4            590   
06A4            591           skipval:
06A4 DED6       592                  djnz R6, Sum_loop0
06A6            593   
06A6            594           ;load_y(100)
06A6 753700     595           mov y+3, #0
06A9 753600     596           mov y+2, #0
06AC 753500     597           mov y+1, #0
06AF 8E34       598           mov y+0, R6
06B1 120398     599           lcall div32
06B4 22         600           ret
06B5            601   
06B5            602   
06B5            603   Read_ADC:
06B5 C2EF       604           clr ADCF
06B7 D2EE       605           setb ADCS ;  ADC start trigger signal
06B9 30EFFD     606           jnb ADCF, $ ; Wait for conversion complete
06BC            607           
06BC            608           ; Read the ADC result and store in [R1, R0]
06BC E5C2       609           mov a, ADCRL
06BE 540F       610           anl a, #0x0f
06C0 F8         611           mov R0, a
06C1 E5C3       612           mov a, ADCRH  
06C3 C4         613           swap a
06C4 C0E0       614           push acc
06C6 540F       615           anl a, #0x0f
06C8 F9         616           mov R1, a
06C9 D0E0       617           pop acc
06CB 54F0       618           anl a, #0xf0
06CD 48         619           orl a, R0
06CE F8         620           mov R0, A
06CF 22         621   ret
06D0            622   
06D0            623   DO_TEMP_READ:
06D0            624           ;push x
06D0            625           ; Read the 2.08V LED voltage connected to AIN0 on pin 6
06D0 53E8F0     626           anl ADCCON0, #0xF0
06D3 43E800     627           orl ADCCON0, #0x00 ; Select channel 0
06D6            628   
06D6 1206B5     629           lcall Read_ADC
06D9            630           ; Save result for later use
06D9 8846       631           mov VLED_ADC+0, R0
06DB 8947       632           mov VLED_ADC+1, R1
06DD            633   
06DD            634           ; Read the signal connected to AIN7
06DD 53E8F0     635           anl ADCCON0, #0xF0
06E0 43E807     636           orl ADCCON0, #0x07 ; Select channel 7
06E3            637           ;lcall Read_ADC
06E3 12066C     638           lcall Average_ADC ;using in place of Read_ADC function, takes 100 measurements and averages
06E6            639                             ;fairly instantaneous reading 
06E6            640   
06E6            641           ; Convert to voltage
06E6 8830       642           mov x+0, R0
06E8 8931       643           mov x+1, R1
06EA            644           ; Pad other bits with zero
06EA 753200     645           mov x+2, #0
06ED 753300     646           mov x+3, #0
06F0 753414     647            mov y+0, #low (20500 % 0x10000) 
06F3 753550     647            mov y+1, #high(20500 % 0x10000) 
06F6 753600     647            mov y+2, #low (20500 / 0x10000) 
06F9 753700     647            mov y+3, #high(20500 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
06FC 12027E     648           lcall mul32
06FF            649           ; Retrive the ADC LED value
06FF 854634     650           mov y+0, VLED_ADC+0
0702 854735     651           mov y+1, VLED_ADC+1
0705            652           ; Pad other bits with zero
0705 753600     653           mov y+2, #0
0708 753700     654           mov y+3, #0
070B 120398     655           lcall div32 ; x stores thermocouple voltage
070E            656   
070E 753451     657            mov y+0, #low (81 % 0x10000) 
0711 753500     657            mov y+1, #high(81 % 0x10000) 
0714 753600     657            mov y+2, #low (81 / 0x10000) 
0717 753700     657            mov y+3, #high(81 / 0x10000) 
071A 12027E     658           lcall mul32
071D            659   
071D            660           ; code to use temp sensor for amb temp
071D            661           ;push x
071D            662   ;
071D            663           ;anl ADCCON0, #0xF0
071D            664           ;orl ADCCON0, #0x01 ; Select channel 1
071D            665           ;lcall Read_ADC
071D            666   ;
071D            667           ;mov x+0, R0
071D            668           ;mov x+1, R1
071D            669           ;; Pad other bits with zero
071D            670           ;mov x+2, #0
071D            671           ;mov x+3, #0
071D            672           ;Load_y(20500) ; The MEASURED LED voltage: 2.074V, with 4 decimal places
071D            673           ;lcall mul32
071D            674           ;; Retrive the ADC LED value
071D            675           ;mov y+0, VLED_ADC+0
071D            676           ;mov y+1, VLED_ADC+1
071D            677           ;; Pad other bits with zero
071D            678           ;mov y+2, #0
071D            679           ;mov y+3, #0
071D            680           ;lcall div32
071D            681   ;
071D            682           ;load_y(100)
071D            683           ;lcall mul32
071D            684           ;
071D            685           ;
071D            686           ;load_y(273000)
071D            687           ;lcall sub32
071D            688   ;
071D            689           ;mov y+0, x+0
071D            690           ;mov y+1, x+1
071D            691           ;mov y+2, x+2
071D            692           ;mov y+3, x+3
071D            693   ;
071D            694           ;lcall hex2bcd
071D            695           ;lcall send_temp_to_serial
071D            696   ;
071D            697           ;pop x
071D            698           
071D 753460     699            mov y+0, #low (220000 % 0x10000) 
0720 75355B     699            mov y+1, #high(220000 % 0x10000) 
0723 753603     699            mov y+2, #low (220000 / 0x10000) 
0726 753700     699            mov y+3, #high(220000 / 0x10000)  ;adding 22, will change to ambient later
0729 1201A7     700           lcall add32
072C            701   
072C 22         702           ret
072D            703   
072D            704   ;---------------------------------;
072D            705   ; Send a BCD number to PuTTY      ;
072D            706   ;---------------------------------;
                707   Send_BCD mac
                708   	push    ar0
                709   	mov     r0, %0
                710   	lcall   ?Send_BCD
                711   	pop     ar0
                712   	endmac
072D            713            ?Send_BCD:
072D C0E0       714                   push    acc
072F            715                   ; Write most significant digit
072F E8         716                   mov     a, r0
0730 C4         717                   swap    a
0731 540F       718                   anl     a, #0fh
0733 4430       719                   orl     a, #30h
0735 120510     720                   lcall   putchar
0738            721                   ; write least significant digit
0738 E8         722                   mov     a, r0
0739 540F       723                   anl     a, #0fh
073B 4430       724                   orl     a, #30h
073D 120510     725                   lcall   putchar
0740 D0E0       726                   pop     acc
0742 22         727   ret
0743            728   
0743            729   ; oven_FSM_LCD_DISPLAY (message)
0743            730   ; Params
0743            731   ;       message - constant string dataByte
                732   oven_FSM_LCD_DISPLAY MAC
                733           ; Display mode and temperature on line 1
                734           Set_Cursor(1,1)
                735           Send_Constant_String(%0)
                736           Send_Constant_String(#LCD_clearLine)
                737   
                738           ; display seconds on line 2
                739           Set_Cursor(2, 1)
                740           mov     a, seconds_elapsed
                741   ENDMAC
0743            742   
0743            743   ; Sends the BCD value
0743            744   send_temp_to_serial:
0743            745           ; Sends temperature
0743 C000       746            push    ar0
0745 A83F       746            mov     r0, bcd+3
0747 12072D     746            lcall   ?Send_BCD
074A D000       746            pop     ar0
074C C000       747            push    ar0
074E A83E       747            mov     r0, bcd+2
0750 12072D     747            lcall   ?Send_BCD
0753 D000       747            pop     ar0
0755 742E       748           mov a, #'.'
0757 120510     749           lcall putchar
075A C000       750            push    ar0
075C A83D       750            mov     r0, bcd+1
075E 12072D     750            lcall   ?Send_BCD
0761 D000       750            pop     ar0
0763 C000       751            push    ar0
0765 A83C       751            mov     r0, bcd+0
0767 12072D     751            lcall   ?Send_BCD
076A D000       751            pop     ar0
076C            752   
076C            753           ; Sends soak time, soak temp, reflow time, reflow temp
076C E54B       754           mov a, time_soak
076E 12053F     755           lcall SendToSerialPort 
0771 E54A       756           mov a, temp_soak
0773 12053F     757           lcall SendToSerialPort 
0776 E54D       758           mov a, time_refl
0778 12053F     759           lcall SendToSerialPort 
077B E54C       760           mov a, temp_refl
077D 12053F     761           lcall SendToSerialPort 
0780            762   
0780 740D       763           mov a,  #'\r' ; Return character
0782 120510     764           lcall   putchar
0785 740A       765           mov a,  #'\n' ; New-line character
0787 120510     766           lcall   putchar
078A            767   
078A 22         768           ret 
078B            769   
078B            770   INIT_ALL:
078B            771           ; Configure pins to be bi-directional
078B 75AC00     772           mov      P3M1,#0x00
078E 75AD00     773            mov     P3M2,#0x00
0791 75B300     774            mov     P1M1,#0x00
0794 75B400     775            mov     P1M2,#0x00
0797 75B100     776            mov     P0M1,#0x00
079A 75B200     777            mov     P0M2,#0x00
079D            778   
079D D281       779           setb    CHANGE_MENU_PIN
079F D293       780           setb    START_PIN
07A1            781   
07A1 D2AF       782           setb    EA   ; Enable Global interrupts
07A3 12055B     783           lcall   Timer0_Init
07A6 120571     784           lcall   Timer2_Init
07A9            785   
07A9            786           ; Since the reset button bounces, we need to wait a bit before
07A9            787           ; sending messages, otherwise we risk displaying gibberish!
07A9 C002       788            push AR2
07AB 7A32       788            mov R2, #50
07AD 120038     788            lcall ?Wait_Milli_Seconds
07B0 D002       788            pop AR2
07B2            789   
07B2            790           ; Now we can proceed with the configuration of the serial port
07B2 438E10     791           orl      CKCON, #0x10 ; CLK is the input for timer 1
07B5 438780     792           orl      PCON, #0x80  ; Bit SMOD=1, double baud rate
07B8 759852     793           mov      SCON, #0x52
07BB 53C4DF     794           anl      T3CON, #0b11011111
07BE 53890F     795           anl      TMOD, #0x0F ; Clear the configuration bits for timer 1
07C1 438920     796           orl      TMOD, #0x20 ; Timer 1 Mode 2
07C4 758DF7     797           mov      TH1, #TIMER1_RELOAD
07C7 D28E       798           setb    TR1
07C9            799   
07C9            800           ; ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ SUS  ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓   
07C9            801           ; works on its own from lab3, might interfere with other stuff though       ; NOTE TIMER ZERO HAS NOT YET BEEN TESTED       
07C9            802           ; Using timer 0 for delay functions.  Initialize here:
07C9            803            ;clr    TR0         ; Stop timer 0
07C9            804            ;orl    CKCON,#0x08 ; CLK is the input for timer 0
07C9            805            ;anl    TMOD,#0xF0  ; Clear the configuration bits for timer 0
07C9            806            ;orl    TMOD,#0x01  ; Timer 0 in Mode 1: 16-bit timer
07C9            807           ; ^ ^ ^ ^ ^ ^ ^ ^^ ^ ^ ^ ^ ^^ ^ ^ ^ ^^ ^ ^ ^            
07C9            808            
07C9            809            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
07C9 43B382     810            orl     P1M1, #0b10000010
07CC 53B47D     811            anl     P1M2, #0b01111101
07CF            812            
07CF            813            ; Initialize and start the ADC:
07CF 53E8F0     814            anl     ADCCON0, #0xF0
07D2 43E807     815            orl     ADCCON0, #0x07 ; Select channel 7
07D5            816            
07D5            817           ; AINDIDS select if some pins are analog inputs or digital I/O:
07D5 75F600     818            mov     AINDIDS, #0x00 ; Disable all analog inputs
07D8 43F681     819            orl     AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
07DB 43E101     820            orl     ADCCON1, #0x01 ; Enable ADC
07DE            821   
07DE            822           ; Menu Configuration
07DE C201       823           clr     IN_MENU_FLAG
07E0 C202       824           clr     IN_OVEN_FLAG
07E2 7400       825           mov     a, #0
07E4 F549       826           mov     MENU_STATE, a ; set menu state to 0 
07E6            827   
07E6            828           ; mov     temp_soak, #0x250
07E6 754A50     829           mov     temp_soak, #MIN_TEMP ; 80
07E9 754B2D     830           mov     time_soak, #MIN_TIME
07EC 754C78     831           mov     temp_refl, #120
07EF 754D2D     832           mov     time_refl, #MIN_TIME
07F2            833           
07F2            834           ; Oven configuration
07F2 754800     835           mov     OVEN_STATE, #OVEN_STATE_PREHEAT
07F5 755300     836           mov     seconds_elapsed, #0
07F8 755700     837           mov     PWM, #0
07FB 755200     838           mov     Count1ms_PWM, #0
07FE 755400     839           mov     exit_seconds, #0
0801 755500     840           mov     total_seconds, #0
0804 C203       841           clr     REFLOW_FLAG
0806 C204       842           clr     ENABLE_SEC_INC_FLAG ; flag is set to zero so that seconds won't increment
0808 C205       843           clr     TIME_TO_BEEP_FLAG   ; flag is one when we switch states (i.e will beep)
080A            844   
080A D2CA       845           setb    TR2
080C            846   
080C            847           ; clear x
080C 753000     848           mov x+0, #0
080F 753100     849           mov x+1, #0
0812 753200     850           mov x+2, #0
0815 753300     851           mov x+3, #0
0818            852   
0818            853           
0818 22         854           ret
0819            855   
0819            856   STOP_PROCESS:
0819            857           ; Turn everything off
0819            858          
0819 C292       859           clr     PWM_OUT
081B C203       860           clr     REFLOW_FLAG
081D C202       861           clr     IN_OVEN_FLAG
081F C201       862           clr     IN_MENU_FLAG
0821 754800     863           MOV     OVEN_STATE, #OVEN_STATE_PREHEAT
0824 755300     864           MOV     seconds_elapsed, #0
0827 755200     865           mov     Count1ms_PWM, #0
082A 755400     866           mov     exit_seconds, #0
082D 755500     867           mov     total_seconds, #0
0830 755700     868           MOV     pwm, #0
0833 755600     869           MOV     pwm_counter, #0
0836 753000     870           mov x+0, #0
0839 753100     871           mov x+1, #0
083C 753200     872           mov x+2, #0
083F 753300     873           mov x+3, #0
0842            874   
0842            875           ; mov DPTR, #emergency
0842            876           ; lcall SendString
0842            877   
0842            878           ; Do not disable TR2, otherwise temperature will no longer be sent to serial
0842            879           ; clr     TR2 ; disable timer 2 so that it doesn't count up in background ; 
0842 C204       880           clr     ENABLE_SEC_INC_FLAG ; 
0844 020E77     881           ljmp    PROGRAM_ENTRY
0847            882   
0847            883   ; Precondition: Has temperature stored in BCD
0847            884   ; States
0847            885   ;       Preheat --> Soak --> Ramp to Peak --> Reflow --> Cooling --> Finished ----> EXIT
0847            886   ;
0847            887   ; Exit conditions
0847            888   ;       1. Early exit  - Stop button pressed
0847            889   ;       2. Early exit  - Temp threshold not reached after 60s
0847            890   ;       3. Normal exit - End of FSM reached 
0847            891   ;
0847            892   ; State Layout
0847            893   ;    state_label
0847            894   ;       if OVEN_STATE != state,  jmp
0847            895   ;       display on time and temp LCD
0847            896   OVEN_FSM:
0847 C002       897            push AR2
0849 7A32       897            mov R2, #50
084B 120038     897            lcall ?Wait_Milli_Seconds
084E D002       897            pop AR2                                 
0850            898           
0850            899   
0850 D208       900           setb PB_START_PIN
0852 D209       900           setb PB_CHANGE_MENU_PIN
0854 D20A       900           setb PB_INC_TEMP_PIN
0856 D20B       900           setb PB_INC_TIME_PIN
0858 D20C       900           setb PB_STOP_PIN
085A            900           
085A D295       900           setb SHARED_PIN
085C            900           ; check if any push buttons are pressed
085C C293       900           clr START_PIN             
085E C281       900           clr CHANGE_MENU_PIN       
0860 C282       900           clr INC_TEMP_PIN          
0862 C283       900           clr INC_TIME_PIN          
0864 C280       900           clr STOP_PIN
0866            900   
0866            900           ; debounce
0866 209546     900           jb SHARED_PIN, enterOvenStateCheck ; use helper label to jump to the end
0869 C002       900            push AR2
086B 7A32       900            mov R2, #50
086D 120038     900            lcall ?Wait_Milli_Seconds
0870 D002       900            pop AR2
0872 20953A     900           jb SHARED_PIN, enterOvenStateCheck
0875            900   
0875            900           ; Set the LCD data pins to logic 1
0875 D293       900           setb START_PIN
0877 D281       900           setb CHANGE_MENU_PIN
0879 D282       900           setb INC_TEMP_PIN
087B D283       900           setb INC_TIME_PIN
087D D280       900           setb STOP_PIN
087F            900   
087F            900           ; check push buttons 1 by one
087F C293       900           clr START_PIN
0881 A295       900           mov c, SHARED_PIN
0883 9208       900           mov PB_START_PIN, c
0885 D293       900           setb START_PIN
0887            900   
0887 C281       900           clr CHANGE_MENU_PIN
0889 A295       900           mov c, SHARED_PIN
088B 9209       900           mov PB_CHANGE_MENU_PIN, c
088D D281       900           setb CHANGE_MENU_PIN
088F            900   
088F C282       900           clr INC_TEMP_PIN
0891 A295       900           mov c, SHARED_PIN
0893 920A       900           mov PB_INC_TEMP_PIN, c
0895 D282       900           setb INC_TEMP_PIN
0897            900   
0897 C283       900           clr INC_TIME_PIN
0899 A295       900           mov c, SHARED_PIN
089B 920B       900           mov PB_INC_TIME_PIN, c
089D D283       900           setb INC_TIME_PIN
089F            900   
089F C280       900           clr STOP_PIN
08A1 A295       900           mov c, SHARED_PIN
08A3 920C       900           mov PB_STOP_PIN, c
08A5 D280       900           setb STOP_PIN
08A7            900   
08A7 200C05     900           jb PB_STOP_PIN, enterOvenStateCheck ; check that the variable flag is not 1, otherwise jmp
08AA            900   
08AA            900       
08AA D205       901           setb    TIME_TO_BEEP_FLAG
08AC 120819     902           lcall   STOP_PROCESS
08AF            903   
08AF            904           ; check oven state if stop button is not pressed
08AF            905           enterOvenStateCheck:
08AF E548       906                   mov  a, OVEN_STATE
08B1            907           
08B1            908           ovenFSM_preheat:
08B1            909   
08B1            910                   ;
08B1            911                   
08B1            912                   ; long jump for relative offset
08B1 B40002     913                   cjne    a, #OVEN_STATE_PREHEAT, ovenFSM_soak_jmp
08B4 8003       914                   sjmp    oven_state_preheat_tasks
08B6            915                   ovenFSM_soak_jmp:
08B6 0209A1     916                           ljmp    ovenFSM_soak
08B9            917                   oven_state_preheat_tasks:
08B9 755750     918                           mov     pwm, #80
08BC C0E0       919            push acc
08BE 7401       919            mov a, #1
08C0 14         919            dec a
08C1 1200C7     919            lcall ?Set_Cursor_1 ; Select column and row
08C4 D0E0       919            pop acc
08C6 C083       920            push dph
08C8 C082       920            push dpl
08CA C0E0       920            push acc
08CC 900472     920            mov dptr, #preheatMessage
08CF 1200BA     920            lcall ?Send_Constant_String
08D2 D0E0       920            pop acc
08D4 D082       920            pop dpl
08D6 D083       920            pop dph
08D8 C083       921            push dph
08DA C082       921            push dpl
08DC C0E0       921            push acc
08DE 900461     921            mov dptr, #LCD_clearLine
08E1 1200BA     921            lcall ?Send_Constant_String
08E4 D0E0       921            pop acc
08E6 D082       921            pop dpl
08E8 D083       921            pop dph
08EA C0E0       922            push acc
08EC 740E       922            mov a, #14
08EE 14         922            dec a
08EF 1200C5     922            lcall ?Set_Cursor_2 ; Select column and row
08F2 D0E0       922            pop acc
08F4 E553       923                           mov     a, seconds_elapsed
08F6 120523     924                           lcall   SendToLCD ; send seconds to LCD
08F9 E555       925                           mov     a, total_seconds
08FB C0E0       926            push acc
08FD 740E       926            mov a, #14
08FF 14         926            dec a
0900 1200C7     926            lcall ?Set_Cursor_1 ; Select column and row
0903 D0E0       926            pop acc
0905 120523     927                           lcall   SendToLCD
0908 1200E2     928                           lcall   hex2bcd
090B            929                           ; lcall   send_temp_to_serial
090B 120614     930                           lcall   Display_formated_BCD
090E            931   
090E            932                   ;Emergency exit process; tested, works
090E D203       933                   setb    REFLOW_FLAG
0910 E554       934                   mov     a, exit_seconds
0912 B43C15     935                   cjne    a, #60, Skip_Emergency_exit
0915 753420     936            mov y+0, #low (50*10000 % 0x10000) 
0918 7535A1     936            mov y+1, #high(50*10000 % 0x10000) 
091B 753607     936            mov y+2, #low (50*10000 / 0x10000) 
091E 753700     936            mov y+3, #high(50*10000 / 0x10000) 
0921 12026A     937                   lcall   x_gteq_y
0924 200003     938                   jb      mf, Skip_Emergency_exit ; if x > y, don't exit
0927            939                   
0927            940                   ; mov a, temp
0927            941                   ; lcall ;send temperature value to serial
0927 020819     942                   ljmp    STOP_PROCESS ; more then 60 seconds has elapsed and we are below 50C ESCAPE
092A            943                   
092A            944           Skip_Emergency_exit:       
092A            945                   ; State transition check ; if x > temp_soak, next state ; else, self loop
092A 854A34     946                   mov y+0, temp_soak
092D 753500     947                   mov y+1, #0
0930 753600     948                   mov y+2, #0
0933 753700     949                   mov y+3, #0        
0936 753810     950            mov z+0, #low (10000 % 0x10000) 
0939 753927     950            mov z+1, #high(10000 % 0x10000) 
093C 753A00     950            mov z+2, #low (10000 / 0x10000) 
093F 753B00     950            mov z+3, #high(10000 / 0x10000) 
0942 12030B     951                   lcall mul32z
0945 853834     952                   mov y+0, z+0
0948 853935     953                   mov y+1, z+1
094B 853A36     954                   mov y+2, z+2
094E 853B37     955                   mov y+3, z+3     ; y = y * 10000
0951 753890     956            mov z+0, #low (250000 % 0x10000) 
0954 7539D0     956            mov z+1, #high(250000 % 0x10000) 
0957 753A03     956            mov z+2, #low (250000 / 0x10000) 
095A 753B00     956            mov z+3, #high(250000 / 0x10000) 
095D 1201EA     957                   lcall sub32z    ; y = y - 25
0960            958   
0960            959                   ; print value of y to serial for debugging
0960            960                   ; mov a, y+3
0960            961                   ; lcall SendToSerialPort
0960            962                   ; mov a, y+2
0960            963                   ; lcall SendToSerialPort
0960            964                   ; mov a, y+1
0960            965                   ; lcall SendToSerialPort
0960            966                   ; mov a, y+0
0960            967                   ; lcall SendToSerialPort
0960            968   
0960            969                   ; mov a,  #'\r' ; Return character
0960            970                   ; lcall   putchar
0960            971                   ; mov a,  #'\n' ; New-line character
0960            972                   ; lcall   putchar
0960            973   
0960 120228     974                   lcall x_gt_y   ; if x > y-30, set PWM
0963 300003     975                   jnb mf, $+3+3
0966 755700     976                   mov PWM, #0 ; turn PWM off
0969            977   
0969 854A34     978                   mov y+0, temp_soak
096C 753500     979                   mov y+1, #0
096F 753600     980                   mov y+2, #0
0972 753700     981                   mov y+3, #0        
0975 753810     982            mov z+0, #low (10000 % 0x10000) 
0978 753927     982            mov z+1, #high(10000 % 0x10000) 
097B 753A00     982            mov z+2, #low (10000 / 0x10000) 
097E 753B00     982            mov z+3, #high(10000 / 0x10000) 
0981 12030B     983                   lcall mul32z
0984 853834     984                   mov y+0, z+0
0987 853935     985                   mov y+1, z+1
098A 853A36     986                   mov y+2, z+2
098D 853B37     987                   mov y+3, z+3                        
0990            988   
0990 120228     989                   lcall x_gt_y
0993 300008     990                   jnb mf, noChange_preHeat ; jump past the jnb and mov instructions which are both 3 bytes
0996 754801     991                   mov OVEN_STATE, #OVEN_STATE_SOAK
0999 755300     992                   mov seconds_elapsed, #0
099C D205       993                   setb TIME_TO_BEEP_FLAG
099E            994                   
099E            995           noChange_preHeat:
099E 020C2F     996                   ljmp oven_FSM_done
09A1            997           
09A1            998           ovenFSM_soak:
09A1 B40165     999                   cjne    a, #OVEN_STATE_SOAK, ovenFSM_Ramp2Peak
09A4 755701    1000                   mov     pwm, #1
09A7 C0E0      1001            push acc
09A9 7401      1001            mov a, #1
09AB 14        1001            dec a
09AC 1200C7    1001            lcall ?Set_Cursor_1 ; Select column and row
09AF D0E0      1001            pop acc
09B1 C083      1002            push dph
09B3 C082      1002            push dpl
09B5 C0E0      1002            push acc
09B7 90047A    1002            mov dptr, #soakMessage
09BA 1200BA    1002            lcall ?Send_Constant_String
09BD D0E0      1002            pop acc
09BF D082      1002            pop dpl
09C1 D083      1002            pop dph
09C3 C083      1003            push dph
09C5 C082      1003            push dpl
09C7 C0E0      1003            push acc
09C9 900461    1003            mov dptr, #LCD_clearLine
09CC 1200BA    1003            lcall ?Send_Constant_String
09CF D0E0      1003            pop acc
09D1 D082      1003            pop dpl
09D3 D083      1003            pop dph
09D5 C0E0      1004            push acc
09D7 740E      1004            mov a, #14
09D9 14        1004            dec a
09DA 1200C5    1004            lcall ?Set_Cursor_2 ; Select column and row
09DD D0E0      1004            pop acc
09DF E553      1005                   mov     a, seconds_elapsed
09E1 120523    1006                   lcall   SendToLCD
09E4 E555      1007                   mov     a, total_seconds
09E6 C0E0      1008            push acc
09E8 740E      1008            mov a, #14
09EA 14        1008            dec a
09EB 1200C7    1008            lcall ?Set_Cursor_1 ; Select column and row
09EE D0E0      1008            pop acc
09F0 120523    1009                   lcall SendToLCD
09F3           1010                   
09F3 1200E2    1011                   lcall   hex2bcd
09F6 120614    1012                   lcall   Display_formated_BCD
09F9           1013   
09F9           1014                   ; check if seconds elapsed > soak time
09F9 E553      1015                   mov     a, seconds_elapsed
09FB B54B08    1016                   cjne    a, time_soak, noChange_soakState
09FE 754802    1017                   mov     OVEN_STATE, #OVEN_STATE_RAMP2PEAK
0A01 755300    1018                   mov     seconds_elapsed, #0 ; reset
0A04 D205      1019                   setb    TIME_TO_BEEP_FLAG
0A06           1020   
0A06           1021                   noChange_soakState:
0A06 020C2F    1022                           ljmp    oven_FSM_done
0A09           1023           
0A09           1024           ovenFSM_Ramp2Peak:
0A09 B40202    1025                   cjne    a, #OVEN_STATE_RAMP2PEAK, ovenFSM_reflow_jmp
0A0C 8003      1026                   sjmp ovenFSM_Ramp2Peak_task
0A0E           1027                   ovenFSM_reflow_jmp:
0A0E 020ADD    1028                   ljmp ovenFSM_reflow
0A11           1029                   ovenFSM_Ramp2Peak_task:
0A11 755750    1030                   mov     pwm, #80
0A14 C0E0      1031            push acc
0A16 7401      1031            mov a, #1
0A18 14        1031            dec a
0A19 1200C7    1031            lcall ?Set_Cursor_1 ; Select column and row
0A1C D0E0      1031            pop acc
0A1E C083      1032            push dph
0A20 C082      1032            push dpl
0A22 C0E0      1032            push acc
0A24 90047F    1032            mov dptr, #ramp2peakMessage
0A27 1200BA    1032            lcall ?Send_Constant_String
0A2A D0E0      1032            pop acc
0A2C D082      1032            pop dpl
0A2E D083      1032            pop dph
0A30 C083      1033            push dph
0A32 C082      1033            push dpl
0A34 C0E0      1033            push acc
0A36 900461    1033            mov dptr, #LCD_clearLine
0A39 1200BA    1033            lcall ?Send_Constant_String
0A3C D0E0      1033            pop acc
0A3E D082      1033            pop dpl
0A40 D083      1033            pop dph
0A42 C0E0      1034            push acc
0A44 740E      1034            mov a, #14
0A46 14        1034            dec a
0A47 1200C5    1034            lcall ?Set_Cursor_2 ; Select column and row
0A4A D0E0      1034            pop acc
0A4C E553      1035                   mov     a, seconds_elapsed
0A4E 120523    1036                   lcall   SendToLCD
0A51 E555      1037                   mov     a, total_seconds
0A53 C0E0      1038            push acc
0A55 740E      1038            mov a, #14
0A57 14        1038            dec a
0A58 1200C7    1038            lcall ?Set_Cursor_1 ; Select column and row
0A5B D0E0      1038            pop acc
0A5D 120523    1039                   lcall SendToLCD
0A60           1040   
0A60 1200E2    1041                   lcall   hex2bcd
0A63 120614    1042                   lcall   Display_formated_BCD
0A66           1043   
0A66           1044                   ; check that temperature for reflow is reached, then exit 
0A66 854C34    1045                   mov y+0, temp_refl
0A69 753500    1046                   mov y+1, #0
0A6C 753600    1047                   mov y+2, #0
0A6F 753700    1048                   mov y+3, #0        
0A72 753810    1049            mov z+0, #low (10000 % 0x10000) 
0A75 753927    1049            mov z+1, #high(10000 % 0x10000) 
0A78 753A00    1049            mov z+2, #low (10000 / 0x10000) 
0A7B 753B00    1049            mov z+3, #high(10000 / 0x10000) 
0A7E 12030B    1050                   lcall mul32z
0A81 853834    1051                   mov y+0, z+0
0A84 853935    1052                   mov y+1, z+1
0A87 853A36    1053                   mov y+2, z+2
0A8A 853B37    1054                   mov y+3, z+3     ; y = y * 10000
0A8D 7538A0    1055            mov z+0, #low (100000 % 0x10000) 
0A90 753986    1055            mov z+1, #high(100000 % 0x10000) 
0A93 753A01    1055            mov z+2, #low (100000 / 0x10000) 
0A96 753B00    1055            mov z+3, #high(100000 / 0x10000) 
0A99 1201EA    1056                   lcall sub32z    ; y = y - 10
0A9C           1057   
0A9C           1058   
0A9C 120228    1059                   lcall x_gt_y   ; if x > y-30, set PWM
0A9F 300003    1060                   jnb mf, $+3+3
0AA2 755700    1061                   mov PWM, #0 ; turn PWM off
0AA5           1062   
0AA5 854C34    1063                   mov y+0, temp_refl
0AA8 753500    1064                   mov y+1, #0
0AAB 753600    1065                   mov y+2, #0
0AAE 753700    1066                   mov y+3, #0        
0AB1 753810    1067            mov z+0, #low (10000 % 0x10000) 
0AB4 753927    1067            mov z+1, #high(10000 % 0x10000) 
0AB7 753A00    1067            mov z+2, #low (10000 / 0x10000) 
0ABA 753B00    1067            mov z+3, #high(10000 / 0x10000) 
0ABD 12030B    1068                   lcall mul32z
0AC0 853834    1069                   mov y+0, z+0
0AC3 853935    1070                   mov y+1, z+1
0AC6 853A36    1071                   mov y+2, z+2
0AC9 853B37    1072                   mov y+3, z+3                        
0ACC           1073   
0ACC 120228    1074                   lcall x_gt_y
0ACF           1075                   ; 
0ACF 300008    1076                   jnb mf, noChange_Ramp2Peak ; jump past the jnb and mov instructions which are both 3 bytes
0AD2 754803    1077                   mov OVEN_STATE, #OVEN_STATE_REFLOW
0AD5 755300    1078                   mov  seconds_elapsed, #0
0AD8 D205      1079                   setb TIME_TO_BEEP_FLAG
0ADA           1080   
0ADA           1081                   noChange_Ramp2Peak:
0ADA 020C2F    1082                   ljmp oven_FSM_done
0ADD           1083                   
0ADD           1084           ovenFSM_reflow:
0ADD B40365    1085                   cjne    a, #OVEN_STATE_REFLOW, ovenFSM_cooling
0AE0 755705    1086                   mov     pwm, #5
0AE3 C0E0      1087            push acc
0AE5 7401      1087            mov a, #1
0AE7 14        1087            dec a
0AE8 1200C7    1087            lcall ?Set_Cursor_1 ; Select column and row
0AEB D0E0      1087            pop acc
0AED C083      1088            push dph
0AEF C082      1088            push dpl
0AF1 C0E0      1088            push acc
0AF3 90048C    1088            mov dptr, #reflowMessage
0AF6 1200BA    1088            lcall ?Send_Constant_String
0AF9 D0E0      1088            pop acc
0AFB D082      1088            pop dpl
0AFD D083      1088            pop dph
0AFF C083      1089            push dph
0B01 C082      1089            push dpl
0B03 C0E0      1089            push acc
0B05 900461    1089            mov dptr, #LCD_clearLine
0B08 1200BA    1089            lcall ?Send_Constant_String
0B0B D0E0      1089            pop acc
0B0D D082      1089            pop dpl
0B0F D083      1089            pop dph
0B11 C0E0      1090            push acc
0B13 740E      1090            mov a, #14
0B15 14        1090            dec a
0B16 1200C5    1090            lcall ?Set_Cursor_2 ; Select column and row
0B19 D0E0      1090            pop acc
0B1B E553      1091                   mov     a, seconds_elapsed
0B1D 120523    1092                   lcall   SendToLCD
0B20 E555      1093                   mov     a, total_seconds
0B22 C0E0      1094            push acc
0B24 740E      1094            mov a, #14
0B26 14        1094            dec a
0B27 1200C7    1094            lcall ?Set_Cursor_1 ; Select column and row
0B2A D0E0      1094            pop acc
0B2C 120523    1095                   lcall SendToLCD
0B2F           1096   
0B2F 1200E2    1097                   lcall   hex2bcd
0B32 120614    1098                   lcall   Display_formated_BCD
0B35           1099   
0B35           1100                   ; check if seconds elapsed > reflow time
0B35 E553      1101                   mov     a, seconds_elapsed
0B37 B54D08    1102                   cjne    a, time_refl, noChange_reflowState
0B3A 754804    1103                   mov     OVEN_STATE, #OVEN_STATE_COOLING
0B3D 755300    1104                   mov     seconds_elapsed, #0 ; reset
0B40 D205      1105                   setb    TIME_TO_BEEP_FLAG
0B42           1106                  
0B42           1107                   noChange_reflowState:
0B42 020C2F    1108                           ljmp    oven_FSM_done
0B45           1109   
0B45           1110           ovenFSM_cooling:
0B45 B40472    1111                   cjne    a, #OVEN_STATE_COOLING, ovenFSM_finished
0B48 755700    1112                   mov     pwm, #0
0B4B C0E0      1113            push acc
0B4D 7401      1113            mov a, #1
0B4F 14        1113            dec a
0B50 1200C7    1113            lcall ?Set_Cursor_1 ; Select column and row
0B53 D0E0      1113            pop acc
0B55 C083      1114            push dph
0B57 C082      1114            push dpl
0B59 C0E0      1114            push acc
0B5B 900493    1114            mov dptr, #coolingMessage
0B5E 1200BA    1114            lcall ?Send_Constant_String
0B61 D0E0      1114            pop acc
0B63 D082      1114            pop dpl
0B65 D083      1114            pop dph
0B67 C083      1115            push dph
0B69 C082      1115            push dpl
0B6B C0E0      1115            push acc
0B6D 900461    1115            mov dptr, #LCD_clearLine
0B70 1200BA    1115            lcall ?Send_Constant_String
0B73 D0E0      1115            pop acc
0B75 D082      1115            pop dpl
0B77 D083      1115            pop dph
0B79 C0E0      1116            push acc
0B7B 740E      1116            mov a, #14
0B7D 14        1116            dec a
0B7E 1200C5    1116            lcall ?Set_Cursor_2 ; Select column and row
0B81 D0E0      1116            pop acc
0B83 E553      1117                   mov     a, seconds_elapsed
0B85 120523    1118                   lcall   SendToLCD
0B88 E555      1119                   mov     a, total_seconds
0B8A C0E0      1120            push acc
0B8C 740E      1120            mov a, #14
0B8E 14        1120            dec a
0B8F 1200C7    1120            lcall ?Set_Cursor_1 ; Select column and row
0B92 D0E0      1120            pop acc
0B94 120523    1121                   lcall SendToLCD
0B97           1122   
0B97 1200E2    1123                   lcall   hex2bcd
0B9A           1124                   ; lcall   send_temp_to_serial
0B9A 120614    1125                   lcall   Display_formated_BCD
0B9D           1126   
0B9D           1127                   ; once temperature is low (compare with temp constant)
0B9D 753420    1128            mov y+0, #low (50 * 10000 % 0x10000) 
0BA0 7535A1    1128            mov y+1, #high(50 * 10000 % 0x10000) 
0BA3 753607    1128            mov y+2, #low (50 * 10000 / 0x10000) 
0BA6 753700    1128            mov y+3, #high(50 * 10000 / 0x10000) 
0BA9 12020C    1129                   lcall x_lt_y
0BAC 300006    1130                   jnb mf, $+3+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
0BAF 754805    1131                   mov OVEN_STATE, #OVEN_STATE_FINISHED
0BB2 755300    1132                   mov     seconds_elapsed, #0 ; reset
0BB5 D205      1133                   setb    TIME_TO_BEEP_FLAG
0BB7           1134                 
0BB7 020C2F    1135                   ljmp oven_FSM_done
0BBA           1136   
0BBA           1137           ovenFSM_finished:
0BBA B4056C    1138                   cjne    a, #OVEN_STATE_FINISHED, ovenFSM_exit
0BBD C0E0      1139            push acc
0BBF 7401      1139            mov a, #1
0BC1 14        1139            dec a
0BC2 1200C7    1139            lcall ?Set_Cursor_1 ; Select column and row
0BC5 D0E0      1139            pop acc
0BC7 C083      1140            push dph
0BC9 C082      1140            push dpl
0BCB C0E0      1140            push acc
0BCD 90049B    1140            mov dptr, #FinishedMessage
0BD0 1200BA    1140            lcall ?Send_Constant_String
0BD3 D0E0      1140            pop acc
0BD5 D082      1140            pop dpl
0BD7 D083      1140            pop dph
0BD9 C083      1141            push dph
0BDB C082      1141            push dpl
0BDD C0E0      1141            push acc
0BDF 900461    1141            mov dptr, #LCD_clearLine
0BE2 1200BA    1141            lcall ?Send_Constant_String
0BE5 D0E0      1141            pop acc
0BE7 D082      1141            pop dpl
0BE9 D083      1141            pop dph
0BEB C0E0      1142            push acc
0BED 740E      1142            mov a, #14
0BEF 14        1142            dec a
0BF0 1200C5    1142            lcall ?Set_Cursor_2 ; Select column and row
0BF3 D0E0      1142            pop acc
0BF5 E553      1143                   mov     a, seconds_elapsed
0BF7 120523    1144                   lcall   SendToLCD
0BFA E555      1145                   mov     a, total_seconds
0BFC C0E0      1146            push acc
0BFE 740E      1146            mov a, #14
0C00 14        1146            dec a
0C01 1200C7    1146            lcall ?Set_Cursor_1 ; Select column and row
0C04 D0E0      1146            pop acc
0C06 120523    1147                   lcall SendToLCD
0C09           1148                   
0C09 C083      1149            push dph
0C0B C082      1149            push dpl
0C0D C0E0      1149            push acc
0C0F 900461    1149            mov dptr, #LCD_clearLine
0C12 1200BA    1149            lcall ?Send_Constant_String
0C15 D0E0      1149            pop acc
0C17 D082      1149            pop dpl
0C19 D083      1149            pop dph
0C1B           1150   
0C1B           1151   
0C1B           1152                   ; go back to Start Screen after a certain number of seconds
0C1B E553      1153                   mov     a, seconds_elapsed
0C1D B40506    1154                   cjne    a, #FINISHED_SECONDS, noChange_finishedState
0C20 754800    1155                   mov OVEN_STATE, #OVEN_STATE_PREHEAT
0C23 120819    1156                   lcall STOP_PROCESS
0C26           1157                   noChange_finishedState:
0C26 020C2F    1158                           ljmp    oven_FSM_done
0C29           1159   
0C29           1160           ovenFSM_exit:
0C29 754800    1161                   mov     OVEN_STATE, #OVEN_STATE_PREHEAT
0C2C           1162                   ; ljmp oven_FSM_done
0C2C 120819    1163                   lcall   STOP_PROCESS ; Exit oven FSM, turn power off, return to program entry
0C2F           1164                   
0C2F           1165           oven_FSM_done:
0C2F 020847    1166                   ljmp    OVEN_FSM ; return to start of oven FSM ; this is a blocking FSM
0C32           1167           
0C32 22        1168   ret ; technically unncessary
0C33           1169   
0C33           1170   MENU_FSM: 
0C33           1171           ; lcall configure_LCD_multiplexing
0C33 755700    1172           mov     pwm, #0
0C36 E549      1173           mov     a, MENU_STATE 
0C38 D208      1174           setb PB_START_PIN
0C3A D209      1174           setb PB_CHANGE_MENU_PIN
0C3C D20A      1174           setb PB_INC_TEMP_PIN
0C3E D20B      1174           setb PB_INC_TIME_PIN
0C40 D20C      1174           setb PB_STOP_PIN
0C42           1174           
0C42 D295      1174           setb SHARED_PIN
0C44           1174           ; check if any push buttons are pressed
0C44 C293      1174           clr START_PIN             
0C46 C281      1174           clr CHANGE_MENU_PIN       
0C48 C282      1174           clr INC_TEMP_PIN          
0C4A C283      1174           clr INC_TIME_PIN          
0C4C C280      1174           clr STOP_PIN
0C4E           1174   
0C4E           1174           ; debounce
0C4E 209546    1174           jb SHARED_PIN, checkTimeInc ; use helper label to jump to the end
0C51 C002      1174            push AR2
0C53 7A32      1174            mov R2, #50
0C55 120038    1174            lcall ?Wait_Milli_Seconds
0C58 D002      1174            pop AR2
0C5A 20953A    1174           jb SHARED_PIN, checkTimeInc
0C5D           1174   
0C5D           1174           ; Set the LCD data pins to logic 1
0C5D D293      1174           setb START_PIN
0C5F D281      1174           setb CHANGE_MENU_PIN
0C61 D282      1174           setb INC_TEMP_PIN
0C63 D283      1174           setb INC_TIME_PIN
0C65 D280      1174           setb STOP_PIN
0C67           1174   
0C67           1174           ; check push buttons 1 by one
0C67 C293      1174           clr START_PIN
0C69 A295      1174           mov c, SHARED_PIN
0C6B 9208      1174           mov PB_START_PIN, c
0C6D D293      1174           setb START_PIN
0C6F           1174   
0C6F C281      1174           clr CHANGE_MENU_PIN
0C71 A295      1174           mov c, SHARED_PIN
0C73 9209      1174           mov PB_CHANGE_MENU_PIN, c
0C75 D281      1174           setb CHANGE_MENU_PIN
0C77           1174   
0C77 C282      1174           clr INC_TEMP_PIN
0C79 A295      1174           mov c, SHARED_PIN
0C7B 920A      1174           mov PB_INC_TEMP_PIN, c
0C7D D282      1174           setb INC_TEMP_PIN
0C7F           1174   
0C7F C283      1174           clr INC_TIME_PIN
0C81 A295      1174           mov c, SHARED_PIN
0C83 920B      1174           mov PB_INC_TIME_PIN, c
0C85 D283      1174           setb INC_TIME_PIN
0C87           1174   
0C87 C280      1174           clr STOP_PIN
0C89 A295      1174           mov c, SHARED_PIN
0C8B 920C      1174           mov PB_STOP_PIN, c
0C8D D280      1174           setb STOP_PIN
0C8F           1174   
0C8F 200905    1174           jb PB_CHANGE_MENU_PIN, checkTimeInc ; check that the variable flag is not 1, otherwise jmp
0C92           1174    ; increments menu state
0C92 04        1175           inc     a
0C93 F549      1176           mov     MENU_STATE, a 
0C95           1177           ;clr     TIME_TO_BEEP_FLAG
0C95 D281      1178           setb    CHANGE_MENU_PIN
0C97           1179           
0C97           1180           ; increment is checked with a seperate cascade that's outside the FSM
0C97           1181           ; I wanted to keep FSM state outputs seperate from push button checks - George
0C97           1182           checkTimeInc:
0C97 D208      1183           setb PB_START_PIN
0C99 D209      1183           setb PB_CHANGE_MENU_PIN
0C9B D20A      1183           setb PB_INC_TEMP_PIN
0C9D D20B      1183           setb PB_INC_TIME_PIN
0C9F D20C      1183           setb PB_STOP_PIN
0CA1           1183           
0CA1 D295      1183           setb SHARED_PIN
0CA3           1183           ; check if any push buttons are pressed
0CA3 C293      1183           clr START_PIN             
0CA5 C281      1183           clr CHANGE_MENU_PIN       
0CA7 C282      1183           clr INC_TEMP_PIN          
0CA9 C283      1183           clr INC_TIME_PIN          
0CAB C280      1183           clr STOP_PIN
0CAD           1183   
0CAD           1183           ; debounce
0CAD 209560    1183           jb SHARED_PIN, checkTempInc ; use helper label to jump to the end
0CB0 C002      1183            push AR2
0CB2 7A32      1183            mov R2, #50
0CB4 120038    1183            lcall ?Wait_Milli_Seconds
0CB7 D002      1183            pop AR2
0CB9 209554    1183           jb SHARED_PIN, checkTempInc
0CBC           1183   
0CBC           1183           ; Set the LCD data pins to logic 1
0CBC D293      1183           setb START_PIN
0CBE D281      1183           setb CHANGE_MENU_PIN
0CC0 D282      1183           setb INC_TEMP_PIN
0CC2 D283      1183           setb INC_TIME_PIN
0CC4 D280      1183           setb STOP_PIN
0CC6           1183   
0CC6           1183           ; check push buttons 1 by one
0CC6 C293      1183           clr START_PIN
0CC8 A295      1183           mov c, SHARED_PIN
0CCA 9208      1183           mov PB_START_PIN, c
0CCC D293      1183           setb START_PIN
0CCE           1183   
0CCE C281      1183           clr CHANGE_MENU_PIN
0CD0 A295      1183           mov c, SHARED_PIN
0CD2 9209      1183           mov PB_CHANGE_MENU_PIN, c
0CD4 D281      1183           setb CHANGE_MENU_PIN
0CD6           1183   
0CD6 C282      1183           clr INC_TEMP_PIN
0CD8 A295      1183           mov c, SHARED_PIN
0CDA 920A      1183           mov PB_INC_TEMP_PIN, c
0CDC D282      1183           setb INC_TEMP_PIN
0CDE           1183   
0CDE C283      1183           clr INC_TIME_PIN
0CE0 A295      1183           mov c, SHARED_PIN
0CE2 920B      1183           mov PB_INC_TIME_PIN, c
0CE4 D283      1183           setb INC_TIME_PIN
0CE6           1183   
0CE6 C280      1183           clr STOP_PIN
0CE8 A295      1183           mov c, SHARED_PIN
0CEA 920C      1183           mov PB_STOP_PIN, c
0CEC D280      1183           setb STOP_PIN
0CEE           1183   
0CEE 200B1F    1183           jb PB_INC_TIME_PIN, checkTempInc ; check that the variable flag is not 1, otherwise jmp
0CF1           1183   
0CF1           1183   
0CF1 B4000F    1184                   cjne a, #MENU_STATE_SOAK, incTimeReflow
0CF4 E54B      1185                           mov     a, time_soak 
0CF6 2405      1186                           add     A, #5        
0CF8 F54B      1187                           mov     time_soak, a 
0CFA           1188   
0CFA           1189                           ; check if time_soak will need to reset - assumes multiples of 5
0CFA           1190                           ; +5 to constants so they display on LCD b/f reseting
0CFA B45F13    1191                           cjne a, #(MAX_TIME+5), checkTempInc 
0CFD 742D      1192                           mov a, #MIN_TIME
0CFF F54B      1193                           mov time_soak, a
0D01           1194   
0D01 800D      1195                           sjmp checkTempInc       
0D03           1196                   incTimeReflow:
0D03 E54D      1197                           mov     a, time_refl
0D05 2405      1198                           add     A, #5
0D07 F54D      1199                           mov     time_refl, a
0D09           1200   
0D09 B45F04    1201                           cjne a, #(MAX_TIME+5), checkTempInc
0D0C 742D      1202                           mov a, #MIN_TIME
0D0E F54D      1203                           mov time_refl, a
0D10           1204   
0D10           1205           ; check whether we're in the soak or 
0D10           1206           checkTempInc:
0D10 D208      1207           setb PB_START_PIN
0D12 D209      1207           setb PB_CHANGE_MENU_PIN
0D14 D20A      1207           setb PB_INC_TEMP_PIN
0D16 D20B      1207           setb PB_INC_TIME_PIN
0D18 D20C      1207           setb PB_STOP_PIN
0D1A           1207           
0D1A D295      1207           setb SHARED_PIN
0D1C           1207           ; check if any push buttons are pressed
0D1C C293      1207           clr START_PIN             
0D1E C281      1207           clr CHANGE_MENU_PIN       
0D20 C282      1207           clr INC_TEMP_PIN          
0D22 C283      1207           clr INC_TIME_PIN          
0D24 C280      1207           clr STOP_PIN
0D26           1207   
0D26           1207           ; debounce
0D26 209560    1207           jb SHARED_PIN, enterMenuStateCheck ; use helper label to jump to the end
0D29 C002      1207            push AR2
0D2B 7A32      1207            mov R2, #50
0D2D 120038    1207            lcall ?Wait_Milli_Seconds
0D30 D002      1207            pop AR2
0D32 209554    1207           jb SHARED_PIN, enterMenuStateCheck
0D35           1207   
0D35           1207           ; Set the LCD data pins to logic 1
0D35 D293      1207           setb START_PIN
0D37 D281      1207           setb CHANGE_MENU_PIN
0D39 D282      1207           setb INC_TEMP_PIN
0D3B D283      1207           setb INC_TIME_PIN
0D3D D280      1207           setb STOP_PIN
0D3F           1207   
0D3F           1207           ; check push buttons 1 by one
0D3F C293      1207           clr START_PIN
0D41 A295      1207           mov c, SHARED_PIN
0D43 9208      1207           mov PB_START_PIN, c
0D45 D293      1207           setb START_PIN
0D47           1207   
0D47 C281      1207           clr CHANGE_MENU_PIN
0D49 A295      1207           mov c, SHARED_PIN
0D4B 9209      1207           mov PB_CHANGE_MENU_PIN, c
0D4D D281      1207           setb CHANGE_MENU_PIN
0D4F           1207   
0D4F C282      1207           clr INC_TEMP_PIN
0D51 A295      1207           mov c, SHARED_PIN
0D53 920A      1207           mov PB_INC_TEMP_PIN, c
0D55 D282      1207           setb INC_TEMP_PIN
0D57           1207   
0D57 C283      1207           clr INC_TIME_PIN
0D59 A295      1207           mov c, SHARED_PIN
0D5B 920B      1207           mov PB_INC_TIME_PIN, c
0D5D D283      1207           setb INC_TIME_PIN
0D5F           1207   
0D5F C280      1207           clr STOP_PIN
0D61 A295      1207           mov c, SHARED_PIN
0D63 920C      1207           mov PB_STOP_PIN, c
0D65 D280      1207           setb STOP_PIN
0D67           1207   
0D67 200A1F    1207           jb PB_INC_TEMP_PIN, enterMenuStateCheck ; check that the variable flag is not 1, otherwise jmp
0D6A           1207   
0D6A B4000F    1208                   cjne a, #MENU_STATE_SOAK, incTempReflow
0D6D E54A      1209                           mov     a, temp_soak 
0D6F 2405      1210                           add     a, #5        
0D71 F54A      1211                           mov     temp_soak, a 
0D73           1212   
0D73 B4FF13    1213                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
0D76 7450      1214                           mov a, #MIN_TEMP
0D78 F54A      1215                           mov temp_soak, a
0D7A           1216   
0D7A 800D      1217                           sjmp enterMenuStateCheck       
0D7C           1218                   incTempReflow:
0D7C E54C      1219                           mov     a, temp_refl
0D7E 2405      1220                           add     a, #5
0D80 F54C      1221                           mov     temp_refl, a
0D82           1222   
0D82 B4FF04    1223                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
0D85 7450      1224                           mov a, #MIN_TEMP
0D87 F54C      1225                           mov temp_refl, a
0D89           1226   
0D89           1227           ; ---------------- FSM State Check ---------------- ;  
0D89           1228           enterMenuStateCheck:
0D89 D282      1229                   setb INC_TEMP_PIN
0D8B E549      1230                   mov     a, MENU_STATE
0D8D           1231   
0D8D           1232           menuFSM_configSoak:
0D8D B40069    1233                   cjne    a, #MENU_STATE_SOAK, menuFSM_configReflow
0D90           1234                   ; display Soak Menu Options
0D90 C0E0      1235            push acc
0D92 7401      1235            mov a, #1
0D94 14        1235            dec a
0D95 1200C7    1235            lcall ?Set_Cursor_1 ; Select column and row
0D98 D0E0      1235            pop acc
0D9A C083      1236            push dph
0D9C C082      1236            push dpl
0D9E C0E0      1236            push acc
0DA0 90042F    1236            mov dptr, #LCD_soakTemp
0DA3 1200BA    1236            lcall ?Send_Constant_String
0DA6 D0E0      1236            pop acc
0DA8 D082      1236            pop dpl
0DAA D083      1236            pop dph
0DAC           1236   
0DAC E54A      1237                   mov     a, temp_soak
0DAE 120523    1238                   lcall   SendToLCD
0DB1 C083      1239            push dph
0DB3 C082      1239            push dpl
0DB5 C0E0      1239            push acc
0DB7 900461    1239            mov dptr, #LCD_clearLine
0DBA 1200BA    1239            lcall ?Send_Constant_String
0DBD D0E0      1239            pop acc
0DBF D082      1239            pop dpl
0DC1 D083      1239            pop dph
0DC3 C0E0      1240            push acc
0DC5 7401      1240            mov a, #1
0DC7 14        1240            dec a
0DC8 1200C5    1240            lcall ?Set_Cursor_2 ; Select column and row
0DCB D0E0      1240            pop acc
0DCD C083      1241            push dph
0DCF C082      1241            push dpl
0DD1 C0E0      1241            push acc
0DD3 900423    1241            mov dptr, #LCD_soakTime
0DD6 1200BA    1241            lcall ?Send_Constant_String
0DD9 D0E0      1241            pop acc
0DDB D082      1241            pop dpl
0DDD D083      1241            pop dph
0DDF E54B      1242                   mov     a, time_soak
0DE1 120523    1243                   lcall   SendToLCD
0DE4 C083      1244            push dph
0DE6 C082      1244            push dpl
0DE8 C0E0      1244            push acc
0DEA 900461    1244            mov dptr, #LCD_clearLine
0DED 1200BA    1244            lcall ?Send_Constant_String
0DF0 D0E0      1244            pop acc
0DF2 D082      1244            pop dpl
0DF4 D083      1244            pop dph
0DF6 020E6B    1245                   ljmp    menu_FSM_done
0DF9           1246   
0DF9           1247           menuFSM_configReflow:
0DF9 B40169    1248                   cjne    a, #MENU_STATE_REFLOW, reset_menu_state
0DFC           1249                   ; display Reflow Menu Options
0DFC C0E0      1250            push acc
0DFE 7401      1250            mov a, #1
0E00 14        1250            dec a
0E01 1200C7    1250            lcall ?Set_Cursor_1 ; Select column and row
0E04 D0E0      1250            pop acc
0E06 C083      1251            push dph
0E08 C082      1251            push dpl
0E0A C0E0      1251            push acc
0E0C 900447    1251            mov dptr, #LCD_reflowTemp
0E0F 1200BA    1251            lcall ?Send_Constant_String
0E12 D0E0      1251            pop acc
0E14 D082      1251            pop dpl
0E16 D083      1251            pop dph
0E18 E54C      1252                   mov     a, temp_refl
0E1A 120523    1253                   lcall   SendToLCD
0E1D C083      1254            push dph
0E1F C082      1254            push dpl
0E21 C0E0      1254            push acc
0E23 900461    1254            mov dptr, #LCD_clearLine
0E26 1200BA    1254            lcall ?Send_Constant_String
0E29 D0E0      1254            pop acc
0E2B D082      1254            pop dpl
0E2D D083      1254            pop dph
0E2F C0E0      1255            push acc
0E31 7401      1255            mov a, #1
0E33 14        1255            dec a
0E34 1200C5    1255            lcall ?Set_Cursor_2 ; Select column and row
0E37 D0E0      1255            pop acc
0E39 C083      1256            push dph
0E3B C082      1256            push dpl
0E3D C0E0      1256            push acc
0E3F 90043B    1256            mov dptr, #LCD_reflowTime
0E42 1200BA    1256            lcall ?Send_Constant_String
0E45 D0E0      1256            pop acc
0E47 D082      1256            pop dpl
0E49 D083      1256            pop dph
0E4B E54D      1257                   mov     a, time_refl
0E4D 120523    1258                   lcall   SendToLCD
0E50 C083      1259            push dph
0E52 C082      1259            push dpl
0E54 C0E0      1259            push acc
0E56 900461    1259            mov dptr, #LCD_clearLine
0E59 1200BA    1259            lcall ?Send_Constant_String
0E5C D0E0      1259            pop acc
0E5E D082      1259            pop dpl
0E60 D083      1259            pop dph
0E62 020E6B    1260                   ljmp    menu_FSM_done
0E65           1261   
0E65           1262           reset_menu_state: ; sets menu state variable to 0
0E65 754900    1263                   mov     MENU_STATE, #MENU_STATE_SOAK
0E68 020E6B    1264                   ljmp    menu_FSM_done
0E6B           1265   
0E6B           1266           menu_FSM_done:
0E6B 22        1267                   ret
0E6C           1268   
0E6C           1269   main_program:
0E6C           1270           ; George
0E6C 75817F    1271           mov     sp, #0x7f
0E6F 12078B    1272           lcall   INIT_ALL
0E72 120087    1273           lcall   LCD_4BIT
0E75 C292      1274           clr     PWM_OUT
0E77           1275   
0E77           1276           ; Default display - 
0E77           1277           ; Reflow oven controller 
0E77           1278           ; (Start or Configure?)
0E77           1279           PROGRAM_ENTRY:
0E77 C0E0      1280            push acc
0E79 7401      1280            mov a, #1
0E7B 14        1280            dec a
0E7C 1200C7    1280            lcall ?Set_Cursor_1 ; Select column and row
0E7F D0E0      1280            pop acc
0E81 C083      1281            push dph
0E83 C082      1281            push dpl
0E85 C0E0      1281            push acc
0E87 900401    1281            mov dptr, #LCD_defaultTop
0E8A 1200BA    1281            lcall ?Send_Constant_String
0E8D D0E0      1281            pop acc
0E8F D082      1281            pop dpl
0E91 D083      1281            pop dph
0E93 C0E0      1282            push acc
0E95 7401      1282            mov a, #1
0E97 14        1282            dec a
0E98 1200C5    1282            lcall ?Set_Cursor_2 ; Select column and row
0E9B D0E0      1282            pop acc
0E9D C083      1283            push dph
0E9F C082      1283            push dpl
0EA1 C0E0      1283            push acc
0EA3 900412    1283            mov dptr, #LCD_defaultBot
0EA6 1200BA    1283            lcall ?Send_Constant_String
0EA9 D0E0      1283            pop acc
0EAB D082      1283            pop dpl
0EAD D083      1283            pop dph
0EAF           1284                   
0EAF 755700    1285                   mov  PWM, #0 ; sets PWM to zero
0EB2 C292      1286                   clr  PWM_OUT
0EB4           1287   
0EB4 D2CA      1288                   setb TR2 ; keep TR2 enabled
0EB6           1289   
0EB6           1290           checkStartButton: ; assumed negative logic - used a label for an easy ljmp in the future
0EB6 D208      1291           setb PB_START_PIN
0EB8 D209      1291           setb PB_CHANGE_MENU_PIN
0EBA D20A      1291           setb PB_INC_TEMP_PIN
0EBC D20B      1291           setb PB_INC_TIME_PIN
0EBE D20C      1291           setb PB_STOP_PIN
0EC0           1291           
0EC0 D295      1291           setb SHARED_PIN
0EC2           1291           ; check if any push buttons are pressed
0EC2 C293      1291           clr START_PIN             
0EC4 C281      1291           clr CHANGE_MENU_PIN       
0EC6 C282      1291           clr INC_TEMP_PIN          
0EC8 C283      1291           clr INC_TIME_PIN          
0ECA C280      1291           clr STOP_PIN
0ECC           1291   
0ECC           1291           ; debounce
0ECC 209566    1291           jb SHARED_PIN, noStartButtonPress ; use helper label to jump to the end
0ECF C002      1291            push AR2
0ED1 7A32      1291            mov R2, #50
0ED3 120038    1291            lcall ?Wait_Milli_Seconds
0ED6 D002      1291            pop AR2
0ED8 20955A    1291           jb SHARED_PIN, noStartButtonPress
0EDB           1291   
0EDB           1291           ; Set the LCD data pins to logic 1
0EDB D293      1291           setb START_PIN
0EDD D281      1291           setb CHANGE_MENU_PIN
0EDF D282      1291           setb INC_TEMP_PIN
0EE1 D283      1291           setb INC_TIME_PIN
0EE3 D280      1291           setb STOP_PIN
0EE5           1291   
0EE5           1291           ; check push buttons 1 by one
0EE5 C293      1291           clr START_PIN
0EE7 A295      1291           mov c, SHARED_PIN
0EE9 9208      1291           mov PB_START_PIN, c
0EEB D293      1291           setb START_PIN
0EED           1291   
0EED C281      1291           clr CHANGE_MENU_PIN
0EEF A295      1291           mov c, SHARED_PIN
0EF1 9209      1291           mov PB_CHANGE_MENU_PIN, c
0EF3 D281      1291           setb CHANGE_MENU_PIN
0EF5           1291   
0EF5 C282      1291           clr INC_TEMP_PIN
0EF7 A295      1291           mov c, SHARED_PIN
0EF9 920A      1291           mov PB_INC_TEMP_PIN, c
0EFB D282      1291           setb INC_TEMP_PIN
0EFD           1291   
0EFD C283      1291           clr INC_TIME_PIN
0EFF A295      1291           mov c, SHARED_PIN
0F01 920B      1291           mov PB_INC_TIME_PIN, c
0F03 D283      1291           setb INC_TIME_PIN
0F05           1291   
0F05 C280      1291           clr STOP_PIN
0F07 A295      1291           mov c, SHARED_PIN
0F09 920C      1291           mov PB_STOP_PIN, c
0F0B D280      1291           setb STOP_PIN
0F0D           1291   
0F0D 200825    1291           jb PB_START_PIN, noStartButtonPress ; check that the variable flag is not 1, otherwise jmp
0F10           1291   
0F10 D204      1292                   setb    ENABLE_SEC_INC_FLAG 
0F12 D205      1293                   setb    TIME_TO_BEEP_FLAG
0F14 D28C      1294                   setb    TR0
0F16           1295   
0F16           1296                   ; Send 0 to the serial
0F16 753C00    1297                   mov BCD+0, #0x0
0F19 753D00    1298                   mov BCD+1, #0x0
0F1C 753E00    1299                   mov BCD+2, #0x0
0F1F 753F00    1300                   mov BCD+3, #0x0
0F22 754000    1301                   mov BCD+4, #0x0
0F25 120743    1302                   lcall send_temp_to_serial
0F28 740D      1303                   mov a,  #'\r' ; Return character
0F2A 120510    1304                   lcall   putchar
0F2D 740A      1305                   mov a,  #'\n' ; New-line character
0F2F 120510    1306                   lcall   putchar
0F32           1307   
0F32 020FA2    1308                   ljmp    enter_oven_fsm ; successful button press, enter oven FSM   
0F35           1309   
0F35           1310           noStartButtonPress:
0F35 D293      1311                   setb    START_PIN
0F37           1312                   ; if the 'IN_MENU' flag is set, always enter into the menu FSM, this is so that the menu FSM can always be entered
0F37           1313                   ; creates an infinite loop that will always display menu once entered - broken if START button pressed
0F37 300106    1314                   jnb     IN_MENU_FLAG, checkMenuButtonPress
0F3A 120C33    1315                   lcall   MENU_FSM 
0F3D 020EB6    1316                   ljmp    checkStartButton
0F40           1317   
0F40           1318           checkMenuButtonPress:
0F40           1319                   ; check for enter menu button press (reusing increment menu pin)
0F40 D208      1320           setb PB_START_PIN
0F42 D209      1320           setb PB_CHANGE_MENU_PIN
0F44 D20A      1320           setb PB_INC_TEMP_PIN
0F46 D20B      1320           setb PB_INC_TIME_PIN
0F48 D20C      1320           setb PB_STOP_PIN
0F4A           1320           
0F4A D295      1320           setb SHARED_PIN
0F4C           1320           ; check if any push buttons are pressed
0F4C C293      1320           clr START_PIN             
0F4E C281      1320           clr CHANGE_MENU_PIN       
0F50 C282      1320           clr INC_TEMP_PIN          
0F52 C283      1320           clr INC_TIME_PIN          
0F54 C280      1320           clr STOP_PIN
0F56           1320   
0F56           1320           ; debounce
0F56 209544    1320           jb SHARED_PIN, noMenuButtonPress ; use helper label to jump to the end
0F59 C002      1320            push AR2
0F5B 7A32      1320            mov R2, #50
0F5D 120038    1320            lcall ?Wait_Milli_Seconds
0F60 D002      1320            pop AR2
0F62 209538    1320           jb SHARED_PIN, noMenuButtonPress
0F65           1320   
0F65           1320           ; Set the LCD data pins to logic 1
0F65 D293      1320           setb START_PIN
0F67 D281      1320           setb CHANGE_MENU_PIN
0F69 D282      1320           setb INC_TEMP_PIN
0F6B D283      1320           setb INC_TIME_PIN
0F6D D280      1320           setb STOP_PIN
0F6F           1320   
0F6F           1320           ; check push buttons 1 by one
0F6F C293      1320           clr START_PIN
0F71 A295      1320           mov c, SHARED_PIN
0F73 9208      1320           mov PB_START_PIN, c
0F75 D293      1320           setb START_PIN
0F77           1320   
0F77 C281      1320           clr CHANGE_MENU_PIN
0F79 A295      1320           mov c, SHARED_PIN
0F7B 9209      1320           mov PB_CHANGE_MENU_PIN, c
0F7D D281      1320           setb CHANGE_MENU_PIN
0F7F           1320   
0F7F C282      1320           clr INC_TEMP_PIN
0F81 A295      1320           mov c, SHARED_PIN
0F83 920A      1320           mov PB_INC_TEMP_PIN, c
0F85 D282      1320           setb INC_TEMP_PIN
0F87           1320   
0F87 C283      1320           clr INC_TIME_PIN
0F89 A295      1320           mov c, SHARED_PIN
0F8B 920B      1320           mov PB_INC_TIME_PIN, c
0F8D D283      1320           setb INC_TIME_PIN
0F8F           1320   
0F8F C280      1320           clr STOP_PIN
0F91 A295      1320           mov c, SHARED_PIN
0F93 920C      1320           mov PB_STOP_PIN, c
0F95 D280      1320           setb STOP_PIN
0F97           1320   
0F97 200903    1320           jb PB_CHANGE_MENU_PIN, noMenuButtonPress ; check that the variable flag is not 1, otherwise jmp
0F9A           1320   
0F9A           1320   
0F9A           1321                   ; setb IN_MENU_FLAG; successful button press, enter menu FSM loop ; - THIS LINE CAUSES THE BUG
0F9A 020FE4    1322                   ljmp    setMenuFlag
0F9D           1323                   
0F9D           1324           noMenuButtonPress:
0F9D D281      1325                   setb CHANGE_MENU_PIN
0F9F 020EB6    1326                   ljmp    checkStartButton ; this line does not execute if ljmp setMenuFlag is there?!?!?
0FA2           1327   
0FA2           1328           enter_oven_fsm:
0FA2 C201      1329                   clr     IN_MENU_FLAG ; No longer in menu
0FA4 D202      1330                   setb    IN_OVEN_FLAG
0FA6 C0E0      1331            push acc
0FA8 7401      1331            mov a, #1
0FAA 14        1331            dec a
0FAB 1200C7    1331            lcall ?Set_Cursor_1 ; Select column and row
0FAE D0E0      1331            pop acc
0FB0 C083      1332            push dph
0FB2 C082      1332            push dpl
0FB4 C0E0      1332            push acc
0FB6 900461    1332            mov dptr, #LCD_clearLine
0FB9 1200BA    1332            lcall ?Send_Constant_String
0FBC D0E0      1332            pop acc
0FBE D082      1332            pop dpl
0FC0 D083      1332            pop dph
0FC2 C0E0      1333            push acc
0FC4 7401      1333            mov a, #1
0FC6 14        1333            dec a
0FC7 1200C5    1333            lcall ?Set_Cursor_2 ; Select column and row
0FCA D0E0      1333            pop acc
0FCC C083      1334            push dph
0FCE C082      1334            push dpl
0FD0 C0E0      1334            push acc
0FD2 900461    1334            mov dptr, #LCD_clearLine
0FD5 1200BA    1334            lcall ?Send_Constant_String
0FD8 D0E0      1334            pop acc
0FDA D082      1334            pop dpl
0FDC D083      1334            pop dph
0FDE           1335                   ; lcall   Timer2_Init  
0FDE 120847    1336                   lcall   OVEN_FSM     ; `OVEN_FSM` exit by calling STOP_PROCESS which then loops back to the entry point
0FE1 120819    1337                   lcall   STOP_PROCESS ; added for safety
0FE4           1338                   
0FE4           1339           setMenuFlag: 
0FE4 D201      1340                   setb    IN_MENU_FLAG
0FE6 020EB6    1341                   ljmp    checkStartButton
0FE9           1342   
0FE9           1343           program_end:
0FE9 020E6C    1344                   ljmp    main_program
0FEC           1345   END
