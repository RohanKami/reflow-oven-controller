0000              1   ; Main file. FSM implementing the following sequence:
0000              2   ;       State 0: Power = 0% (default state)
0000              3   ;               if start = NO, self loop; if start = YES, next state
0000              4   ;       State 1: Power = 100%; Sec = 0
0000              5   ;               if temp <= 150, self loop; temp > 150, next
0000              6   ;       State 2: Power = 20%
0000              7   ;               if sec <= 60s, self loop; sec>60s, next
0000              8   ;       State 3: Power = 100%; Sec = 0
0000              9   ;               if temp <= 220, self loop; temp>220, next
0000             10   ;       State 4: Power = 20%
0000             11   ;               if sec <= 45s, self loop; sec >45, next
0000             12   ;       State 5: Power = 0%
0000             13   ;               if temp >=60, self loop; temp <60, next
0000             14   ;       return to state 0
0000             15   
0000             16   
0000             17   ; MACROS ;
                 18   CLJNE mac  
                 19       cjne %0, %1, $+3+2 ; Jump if no equal 2 bytes ahead since sjmp is a 2 byte instruction  
                 20       sjmp $+2+3 ; Jump 3 bytes after this instruction as ljmp takes 3 bytes to encode
                 21       ljmp %2 ; ljmp can access any part of the code space
                 22   endmac
0000             23   
0000             24   ; check_Push_Button(variable_flag, dest_label)
0000             25   ; Params
0000             26   ; variable_flag - variable we are checking in place of the pin e.g. PB_START_PIN
0000             27   ; dest_label - where to jump if a push button is not pressed
                 28   check_Push_Button MAC ; new one with multiplexed buttons
                 29           setb PB_START_PIN
                 30           setb PB_CHANGE_MENU_PIN
                 31           setb PB_INC_TEMP_PIN
                 32           setb PB_INC_TIME_PIN
                 33           setb PB_STOP_PIN
                 34           
                 35           setb SHARED_PIN
                 36           ; check if any push buttons are pressed
                 37           clr START_PIN             
                 38           clr CHANGE_MENU_PIN       
                 39           clr INC_TEMP_PIN          
                 40           clr INC_TIME_PIN          
                 41           clr STOP_PIN
                 42   
                 43           ; debounce
                 44           jb SHARED_PIN, %1 ; use helper label to jump to the end
                 45           Wait_Milli_Seconds(#50)
                 46           jb SHARED_PIN, %1
                 47   
                 48           ; Set the LCD data pins to logic 1
                 49           setb START_PIN
                 50           setb CHANGE_MENU_PIN
                 51           setb INC_TEMP_PIN
                 52           setb INC_TIME_PIN
                 53           setb STOP_PIN
                 54   
                 55           ; check push buttons 1 by one
                 56           clr START_PIN
                 57           mov c, SHARED_PIN
                 58           mov PB_START_PIN, c
                 59           setb START_PIN
                 60   
                 61           clr CHANGE_MENU_PIN
                 62           mov c, SHARED_PIN
                 63           mov PB_CHANGE_MENU_PIN, c
                 64           setb CHANGE_MENU_PIN
                 65   
                 66           clr INC_TEMP_PIN
                 67           mov c, SHARED_PIN
                 68           mov PB_INC_TEMP_PIN, c
                 69           setb INC_TEMP_PIN
                 70   
                 71           clr INC_TIME_PIN
                 72           mov c, SHARED_PIN
                 73           mov PB_INC_TIME_PIN, c
                 74           setb INC_TIME_PIN
                 75   
                 76           clr STOP_PIN
                 77           mov c, SHARED_PIN
                 78           mov PB_STOP_PIN, c
                 79           setb STOP_PIN
                 80   
                 81           jb %0, %1 ; check that the variable flag is not 1, otherwise jmp
                 82   
                 83   ENDMAC
0000             84   
0000             85   ; temp_gt_threshold(threshold_temp, new_oven_state)
0000             86   ; assumes that x has current temp value
0000             87   ; new_oven_state is a constant
                 88   temp_gt_threshold MAC
                 89           load_y(%0 * 10000)
                 90   
                 91           lcall x_gt_y
                 92           jnb mf, $+3+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
                 93           mov OVEN_STATE, %1 
                 94           mov seconds_elapsed, #0
                 95           ljmp oven_FSM_done
                 96   
                 97   ENDMAC
0000             98   
                 99   temp_lt_threshold MAC
                100           load_y(%0 * 10000)
                101   
                102           lcall x_lt_y
                103           jnb mf, $+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
                104           mov OVEN_STATE, %1 
                105           ljmp oven_FSM_done
                106   
                107   ENDMAC
0000            108   
                110   $LIST
0000            112   
0000            113   ;  N76E003 pinout:
0000            114   ;                               -------
0000            115   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000            116   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000            117   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000            118   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000            119   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000            120   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000            121   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000            122   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000            123   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000            124   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000            125   ;                               -------
0000            126   
0000            127   
0000            128   
0000            129   ;-------------------------------------------------------------------------------------------------------------------------------------
0000            130   
0000            131   ;                                                              STYLE GUIDE
0000            132   
0000            133   ; End flag names with _FLAG
0000            134   ; Use all upper case for constants (anything defined in equ or pin definitions), as it makes it easier to read quickly
0000            135   ; Before any jump or logic block comment purpose and try to comment throughout - code should be self explanatory, comment "why" it was implemented this way
0000            136   ; Before any block of code also comment who wrote it 
0000            137   ; Aim for variable names with 8-20 characters
0000            138   
0000            139   ; --------------------------------------------------------------------------------------------------------------------------
0000            140   
0000            141   
0000            142   ; Timer constants
0000            143   CLK                   EQU 16600000 ; Microcontroller system frequency in Hz
0000            144   BAUD                  EQU 115200   ; Baud rate of UART in bps 
0000            145   TIMER1_RELOAD         EQU (0x100-(CLK/(16*BAUD))) ; Serial ISR
0000            146   TIMER2_RELOAD         EQU (65536-(CLK/1000))    ; 1ms Delay ISR
0000            147   TIMER0_RELOAD         EQU (0x10000-(CLK/4096))    ; Sound ISR For 2kHz square wave
0000            148   
0000            149   ; Pin definitions + Hardware Wiring 
0000            150   ; Layout
0000            151   ; {Start} {Stop} {Change Menu} {Inc Temp} {Inc Time}
0000            152   START_PIN             EQU P1.3 
0000            153   CHANGE_MENU_PIN       EQU P0.1 
0000            154   INC_TEMP_PIN          EQU P0.2  
0000            155   INC_TIME_PIN          EQU P0.3  
0000            156   STOP_PIN              EQU P0.0  
0000            157   SHARED_PIN            EQU P1.5 
0000            158   
0000            159   PWM_OUT               EQU P1.2 ; Pin 13
0000            160   
0000            161   ; FSM uses integer state encodings
0000            162   ; Menu states
0000            163   MENU_STATE_SOAK       EQU 0
0000            164   MENU_STATE_REFLOW     EQU 1
0000            165   MENU_STATE_TEST       EQU 2
0000            166   
0000            167   ; oven states
0000            168   OVEN_STATE_PREHEAT    EQU 0
0000            169   OVEN_STATE_SOAK       EQU 1
0000            170   OVEN_STATE_RAMP2PEAK  EQU 2
0000            171   OVEN_STATE_REFLOW     EQU 3
0000            172   OVEN_STATE_COOLING    EQU 4
0000            173   OVEN_STATE_FINISHED   EQU 5
0000            174   
0000            175   ; things to keep track of
0000            176   COOLED_TEMP           EQU 50 ; once cooled to this temperature, the reflow is now "finished"
0000            177   COOLED_TEMP_LOAD_MATH EQU COOLED_TEMP*10000 ; use to load up the math
0000            178   FINISHED_SECONDS      EQU 5
0000            179   MAX_TIME              EQU 90
0000            180   MIN_TIME              EQU 45
0000            181   MAX_TEMP              EQU 250
0000            182   MIN_TEMP              EQU 80
0000            183   
0000            184   ; define vectors
0000            185   ORG 0x0000 ; Reset vector
0000 020DDA     186           ljmp main_program
0003            187   ORG 0x0003 ; External interrupt 0 vector
0003 32         188           reti
000B            189   ORG 0x000B ; Timer/Counter 0 overflow interrupt vector
000B 02056C     190            ljmp Timer0_ISR
0013            191   ORG 0x0013 ; External interrupt 1 vector
0013 32         192            reti
001B            193   ORG 0x001B ; Timer/Counter 1 overflow interrupt vector 
001B 32         194            reti
0023            195   ORG 0x0023 ; Serial port receive/transmit interrupt vector 
0023 32         196            reti
002B            197   ORG 0x002B ; Timer/Counter 2 overflow interrupt vector
002B 02056D     198            ljmp Timer2_ISR
002E            199   
002E            200   
002E            201   ; register definitions previously needed by 'math32.inc' - currently commented out for future changes
0030            202   DSEG at 0x30
0030            203   x               : ds 4
0034            204   y               : ds 4
0038            205   z               : ds 4
003C            206   bcd             : ds 5
0041            207   bcdf            : ds 5
0046            208   VLED_ADC        : ds 2
0048            209   
0048            210   OVEN_STATE      : ds 1 ; stores oven FSM state
0049            211   MENU_STATE      : ds 1 ; stores menu FSM state
004A            212   temp_soak       : ds 1 
004B            213   time_soak       : ds 1
004C            214   temp_refl       : ds 1
004D            215   time_refl       : ds 1
004E            216   ; pwm             : ds 1 ; controls output power to SSR
004E            217   ; pwm_counter     : ds 1 
004E            218   
004E            219   Count1ms        : ds 2 ; determines the number of 1ms increments that have passed 
0050            220   Count1ms_PWM    : ds 1
0051            221   seconds_elapsed  : ds 1
0052            222   exit_seconds    : ds 1 ; if we dont reach 50 c before 60 S terminate
0053            223   total_seconds   : ds 1 ; total runtime
0054            224   
0054            225   pwm_counter: ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0055            226   pwm: ds 1 ; pwm percentage
0056            227   
0056            228   
002E            229   CSEG ;starts the absolute segment from that address
002E            230   ; These 'EQU' must match the hardware wiring
002E            231   LCD_RS          EQU P1.3
002E            232   ;LCD_RW         EQU PX.X ; Not used in this code, connect the pin to GND
002E            233   LCD_E           EQU P1.4
002E            234   LCD_D4          EQU P0.0
002E            235   LCD_D5          EQU P0.1
002E            236   LCD_D6          EQU P0.2
002E            237   LCD_D7          EQU P0.3
002E            238   
                240   	$LIST
00E2            242   
00E2            243   ; Flags that are used to control events 
0000            244   BSEG 
0000            245   mf                  : dbit 1
0001            246   IN_MENU_FLAG        : dbit 1
0002            247   IN_OVEN_FLAG        : dbit 1
0003            248   REFLOW_FLAG         : dbit 1
0004            249   ENABLE_SEC_INC_FLAG : dbit 1 ; used to control whether seconds incrementing is enabled 
0005            250   TIME_TO_BEEP_FLAG   : dbit 1
0006            251   
0006            252   ; Variables used for push button mux
0006            253   PB_START_PIN        : dbit 1
0007            254   PB_CHANGE_MENU_PIN  : dbit 1
0008            255   PB_INC_TEMP_PIN     : dbit 1
0009            256   PB_INC_TIME_PIN     : dbit 1
000A            257   PB_STOP_PIN         : dbit 1
000B            258   
                667   $LIST
                260   $LIST
03DF            262   
03DF            263   ; Messages to display on LCD when in Menu FSM
03DF 5265666C   264   LCD_defaultTop  : db 'Reflow Oven:    ', 0
     6F77204F
     76656E3A
     20202020
     00
03F0 53746172   265   LCD_defaultBot  : db 'Start/Configure?', 0
     742F436F
     6E666967
     7572653F
     00
0401 536F616B   266   LCD_soakTime    : db 'Soak Time: ', 0
     2054696D
     653A2000
040D 536F616B   267   LCD_soakTemp    : db 'Soak Temp: ', 0
     2054656D
     703A2000
0419 5265666C   268   LCD_reflowTime  : db 'Refl Time: ', 0
     2054696D
     653A2000
0425 5265666C   269   LCD_reflowTemp  : db 'Refl Temp: ', 0
     2054656D
     703A2000
0431 54455354   270   LCD_TEST        : db 'TEST MESSAGE ', 0
     204D4553
     53414745
     2000
043F 20202020   271   LCD_clearLine   : db '                ', 0 ; put at end to clear line
     20202020
     20202020
     20202020
     00
0450            272   
0450 50726568   273   preheatMessage  : db 'Preheat', 0
     65617400
0458 536F616B   274   soakMessage     : db 'Soak', 0
     00
045D 52616D70   275   ramp2peakMessage: db 'Ramp to Peak', 0
     20746F20
     5065616B
     00
046A 5265666C   276   reflowMessage   : db 'Reflow', 0
     6F7700
0471 436F6F6C   277   coolingMessage  : db 'Cooling', 0
     696E6700
0479 46696E69   278   FinishedMessage : db 'Finished!', 0
     73686564
     2100
0483 454D4552   279   stopMessage     : db 'EMERGENCY STOP', 0
     47454E43
     59205354
     4F5000
0492            280   
0492            281   ; -- Debug messages
0492            282   ; seonds_passed   : db 'Seconds: ', 0
0492            283   ; temp            : db 'Temp: ', 0
0492            284   ; ovenState       : db 'State: ', 0
0492            285   ; errorMessage    : db '** ERROR **', 0
0492            286   
0492            287   emergency:
0492 456D6572   288       DB  'Emergency Stop!', '\r', '\n', 0
     67656E63
     79205374
     6F70210D
     0A00
04A4            289   
04A4            290   soak:
04A4 79207661   291       DB  'y val from soak temp: ', 0
     6C206672
     6F6D2073
     6F616B20
     74656D70
     3A2000
04BB            292   
04BB            293   reflow:
04BB 79207661   294       DB  'y val from reflow temp: ',0
     6C206672
     6F6D2072
     65666C6F
     77207465
     6D703A20
     00
04D4            295   
04D4            296   soakTempLog:
04D4 536F616B   297       DB 'Soak Temp: ', 0
     2054656D
     703A2000
04E0            298   
04E0            299   reflowTempLog:
04E0 5265666C   300       DB 'Reflow Temp: ', 0
     6F772054
     656D703A
     2000
04EE            301   
04EE            302   ; Messages to display on LCD when in Oven Controller FSM
04EE            303   
04EE            304   ; Send a character using the serial port
04EE            305   putchar:
04EE 3099FD     306           jnb     TI, putchar
04F1 C299       307           clr     TI
04F3 F599       308           mov     SBUF, a
04F5 22         309           ret
04F6            310   
04F6            311   ; Send a constant-zero-terminated string using the serial port
04F6            312   SendString:
04F6 E4         313           clr     A
04F7 93         314           movc    A, @A+DPTR
04F8 6006       315           jz      SendStringDone
04FA 1204EE     316           lcall   putchar
04FD A3         317           inc     DPTR
04FE 80F6       318           sjmp    SendString
0500            319   SendStringDone:
0500 22         320           ret
0501            321   
0501            322   ; Eight bit number to display passed in ’a’.
0501            323   SendToLCD:
0501 75F064     324           mov     b, #100
0504 84         325           div     ab
0505 4430       326           orl     a, #0x30 ; Convert hundreds to ASCII
0507 12007D     327           lcall   ?WriteData ; Send to LCD
050A E5F0       328           mov     a, b ; Remainder is in register b
050C 75F00A     329           mov     b, #10
050F 84         330           div     ab
0510 4430       331           orl     a, #0x30 ; Convert tens to ASCII
0512 12007D     332           lcall   ?WriteData; Send to LCD
0515 E5F0       333           mov     a, b
0517 4430       334           orl     a, #0x30 ; Convert units to ASCII
0519 12007D     335           lcall   ?WriteData; Send to LCD
051C 22         336           ret
051D            337   
051D            338   ; Eight bit number to display passed in ’a’.
051D            339   SendToSerialPort:
051D 75F064     340           mov     b, #100
0520 84         341           div     ab
0521 4430       342           orl     a, #0x30 ; Convert hundreds to ASCII
0523 1204EE     343           lcall   putchar ; Send to PuTTY/Python/Matlab
0526 E5F0       344           mov     a, b ; Remainder is in register b
0528 75F00A     345           mov     b, #10
052B 84         346           div     ab
052C 4430       347           orl     a, #0x30 ; Convert tens to ASCII
052E 1204EE     348           lcall   putchar ; Send to PuTTY/Python/Matlab
0531 E5F0       349           mov     a, b
0533 4430       350           orl     a, #0x30 ; Convert units to ASCII
0535 1204EE     351           lcall   putchar ; Send to PuTTY/Python/Matlab
0538 22         352           ret
0539            353   
0539            354   
0539            355   
0539            356   ;---------------------------------;
0539            357   ; Routine to initialize the ISR   ;
0539            358   ; for timer 0                     ;
0539            359   ;---------------------------------;
0539            360   Timer0_Init:
0539 438E08     361            orl     CKCON, #0b00001000 ; Input for timer 0 is sysclk/1 ; performs bit masking on CKON - Clock Control ; T0M = 1, timer 0 uses the system clock directly
053C E589       362            mov     a, TMOD
053E 54F0       363            anl     a, #0xf0 ; 11110000 Clear the bits for timer 0
0540 4401       364            orl     a, #0x01 ; 00000001 Configure timer 0 as 16-timer (M1M0 = 01 -> Mode 1: 16-bit Timer/Counter)
0542 F589       365            mov     TMOD, a
0544 758CF0     366            mov     TH0, #high(TIMER0_RELOAD) ; 8051 works with 8 bits so the oepration T0 = TIMER0_RELOAD  (16 bits) is done by setting high byte then low byte (8x2)
0547 758A2C     367            mov     TL0, #low (TIMER0_RELOAD)
054A            368            ; Enable the timer and interrupts
054A D2A9       369           setb    ET0  ; Enable timer 0 interrupt
054C D28C       370           setb    TR0  ; Start timer 0
054E 22         371            ret
054F            372   
054F            373   ;---------------------------------;
054F            374   ; Routine to initialize the ISR   ;
054F            375   ; for timer 2                     ;
054F            376   ;---------------------------------;
054F            377   Timer2_Init:
054F 75C800     378            mov     T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0552 75CDBF     379            mov     TH2, #high(TIMER2_RELOAD)
0555 75CC28     380            mov     TL2, #low(TIMER2_RELOAD)
0558            381            ; Set the reload value
0558 43C980     382            orl     T2MOD, #0x80 ; Enable timer 2 autoreload
055B 75CBBF     383            mov     RCMP2H, #high(TIMER2_RELOAD)
055E 75CA28     384            mov     RCMP2L, #low(TIMER2_RELOAD)
0561            385            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0561 E4         386            clr     a
0562 F54E       387            mov     Count1ms+0, a
0564 F54F       388            mov     Count1ms+1, a
0566            389            ; Enable the timer and interrupts
0566 439B80     390            orl     EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0569 D2CA       391           setb    TR2  ; Enable timer 2
056B 22         392            ret
056C            393   
056C            394   Timer0_ISR:
056C 32         395           reti
056D            396   
056D            397   ;---------------------------------;
056D            398   ; ISR for timer 2                 ;
056D            399   ;---------------------------------;
056D            400   Timer2_ISR:
056D C2CF       401           clr     TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
056F            402           ; cpl     P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
056F            403   
056F            404           ; The two registers used in the ISR must be saved in the stack
056F C0E0       405           push    acc
0571 C0D0       406           push    psw
0573            407   
0573 0550       408           inc     Count1ms_PWM   ; variable used to count every 10ms used for the PWM
0575            409   
0575            410           ; Increment the 16-bit one mili second counter
0575 054E       411           inc     Count1ms+0    ; Increment the low 8-bits first
0577 E54E       412           mov     a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0579 7002       413           jnz     Inc_done
057B 054F       414           inc     Count1ms+1    
057D            415    
057D            416           
057D            417           Inc_done:
057D            418           ; If not in oven, skip PWM
057D 30021D     419           jnb    IN_OVEN_FLAG, skipPWM
0580 E550       420           mov    a, Count1ms_PWM ; 
0582            421           ; This check is done so that this subroutine executes every 10ms 
0582 B40A18     422           cjne    a, #10, check10msPassed 
0585 755000     423                   mov Count1ms_PWM, #0
0588            424                   ;GL PWM code that Jesus gave
0588            425                   ;RK working on PWM
0588 0554       426                   inc     pwm_counter
058A C3         427                   clr     c
058B E555       428                   mov     a, pwm
058D 9554       429                   subb    a, pwm_counter ; If pwm_counter <= pwm then c=1
058F B3         430                   cpl     c
0590 9292       431                   mov     PWM_OUT, c 
0592 E554       432                   mov     a, pwm_counter
0594            433                   ; cjne    a, #100, Timer2_ISR_done ; why does this go to Timer2_ISR_done? - GL
0594 B46406     434                   cjne    a, #100, check10msPassed ; changed label from `Timer2_ISR_done` to `check10msPassed`
0597 755400     435                   mov     pwm_counter, #0
059A            436   
059A E4         437                   clr     a
059B F550       438                   mov     Count1ms_PWM, a ; reset the 1ms for PWM counter
059D            439           
059D            440           check10msPassed:
059D            441           skipPWM:
059D            442           ; Check if one second has passed
059D E54E       443            mov     a, Count1ms+0
059F B4E82B     444            cjne    a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
05A2 E54F       445            mov     a, Count1ms+1
05A4 B40326     446            cjne    a, #high(1000), Timer2_ISR_done         
05A7            447   
05A7            448           ; ---  1s has passed ----
05A7            449   
05A7 12068E     450           lcall DO_TEMP_READ
05AA 1200E2     451           lcall hex2bcd ; puts value of x into BCD varaibles
05AD 120701     452           lcall send_temp_to_serial
05B0            453           
05B0            454           ; ---- Log File -----
05B0            455           ; mov a,  PWM
05B0            456           ; lcall   SendToSerialPort
05B0            457           ; mov a,  #'\r' ; Return character
05B0            458           ; lcall   putchar
05B0            459           ; mov a,  #'\n' ; New-line character
05B0            460           ; lcall   putchar
05B0            461   
05B0            462           ; mov a,  seconds_elapsed
05B0            463           ; lcall   SendToSerialPort
05B0            464           ; mov a,  #'\r' ; Return character
05B0            465           ; lcall   putchar
05B0            466           ; mov a,  #'\n' ; New-line character
05B0            467           ; lcall   putchar
05B0            468   
05B0            469           ; mov a,  OVEN_STATE
05B0            470           ; lcall   SendToSerialPort
05B0            471           ; mov a,  #'\r' ; Return character
05B0            472           ; lcall   putchar
05B0            473           ; mov a,  #'\n' ; New-line character
05B0            474           ; lcall   putchar
05B0            475           
05B0            476   
05B0            477           ; mov a, OVEN_STATE
05B0            478           ; add A, #1
05B0            479           ; mov OVEN_STATE, a
05B0            480   
05B0            481           ; mov DPTR, #soakTempLog
05B0            482           ; lcall SendString
05B0            483           ; mov a, temp_soak
05B0            484           ; lcall SendToSerialPort
05B0            485           ; mov a,  #'\r' ; Return character
05B0            486           ; lcall   putchar
05B0            487           ; mov a,  #'\n' ; New-line character
05B0            488           ; lcall   putchar
05B0            489   
05B0            490           ; mov DPTR, #reflowTempLog
05B0            491           ; lcall SendString
05B0            492           ; mov a, temp_refl
05B0            493           ; lcall SendToSerialPort
05B0            494           ; mov a,  #'\r' ; Return character
05B0            495           ; lcall   putchar
05B0            496           ; mov a,  #'\n' ; New-line character
05B0            497           ; lcall   putchar
05B0            498   
05B0 300306     499           jnb     REFLOW_FLAG,  not_in_reflow ;Checks if we are in reflow state
05B3 E552       500           mov     a, exit_seconds             ;Increments the early exit seconds counter
05B5 2401       501           add     a, #1
05B7 F552       502           mov     exit_seconds, a
05B9            503           
05B9            504    not_in_reflow:
05B9            505           ; Check a flag for inc. seconds, otherwise go to end of timer, Timer2_ISR_done label used to save a line
05B9 300411     506           jnb ENABLE_SEC_INC_FLAG, Timer2_ISR_done
05BC E551       507           mov     a, seconds_elapsed
05BE 2401       508           add     A, #1
05C0 F551       509           mov     seconds_elapsed, a
05C2 E553       510           mov     a, total_seconds
05C4 2401       511           add     a, #1
05C6 F553       512           mov     total_seconds, a
05C8            513   
05C8            514           ; reset seconds ms counter
05C8 E4         515           clr     a
05C9 F54E       516           mov     Count1ms+0, a
05CB F54F       517           mov     Count1ms+1, a
05CD            518   
05CD            519           Timer2_ISR_done:
05CD D0D0       520           pop     psw
05CF D0E0       521            pop     acc
05D1 32         522           reti
05D2            523   
05D2            524   
05D2            525   Display_formated_BCD:
05D2 C0E0       526            push acc
05D4 7401       526            mov a, #1
05D6 14         526            dec a
05D7 1200C5     526            lcall ?Set_Cursor_2 ; Select column and row
05DA D0E0       526            pop acc
05DC C000       527            push ar0
05DE A83F       527            mov r0, bcd+3
05E0 1200CC     527            lcall ?Display_BCD
05E3 D000       527            pop ar0
05E5 C000       528            push ar0
05E7 A83E       528            mov r0, bcd+2
05E9 1200CC     528            lcall ?Display_BCD
05EC D000       528            pop ar0
05EE C0E0       529            push acc
05F0 742E       529            mov a, #'.'
05F2 12007D     529            lcall ?WriteData
05F5 D0E0       529            pop acc
05F7 C000       530            push ar0
05F9 A83D       530            mov r0, bcd+1
05FB 1200CC     530            lcall ?Display_BCD
05FE D000       530            pop ar0
0600 C000       531            push ar0
0602 A83C       531            mov r0, bcd+0
0604 1200CC     531            lcall ?Display_BCD
0607 D000       531            pop ar0
0609 22         532   ret
060A            533   
060A            534   
060A            535   InitSerialPort:
060A            536       ; Since the reset button bounces, we need to wait a bit before
060A            537       ; sending messages, otherwise we risk displaying gibberish!
060A 79C8       538       mov R1, #200
060C 7868       539       mov R0, #104
060E D8FE       540       djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
0610 D9FA       541       djnz R1, $-4 ; 25us*200=5.0ms
0612            542   
0612            543       ; Now we can proceed with the configuration of the serial port
0612 438E10     544            orl     CKCON, #0x10 ; CLK is the input for timer 1
0615 438780     545            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0618 759852     546            mov     SCON, #0x52
061B 53C4DF     547            anl     T3CON, #0b11011111
061E 53890F     548            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0621 438920     549            orl     TMOD, #0x20 ; Timer 1 Mode 2
0624 758DF7     550            mov     TH1, #TIMER1_RELOAD
0627 D28E       551            setb TR1
0629 22         552           ret
062A            553           
062A            554   ;jesus' beautiful averaging code, can be used in place of Read_ADC in place where we read
062A            555   Average_ADC:
062A 753000     556            mov x+0, #low (0 % 0x10000) 
062D 753100     556            mov x+1, #high(0 % 0x10000) 
0630 753200     556            mov x+2, #low (0 / 0x10000) 
0633 753300     556            mov x+3, #high(0 / 0x10000) 
0636 7D64       557           mov R5, #100
0638 7E64       558           mov R6, #100
063A            559   
063A            560           Sum_loop0:
063A 120673     561           lcall Read_ADC
063D 753700     562           mov y+3, #0
0640 753600     563           mov y+2, #0
0643 8935       564           mov y+1, R1
0645 8834       565           mov y+0, R0
0647            566   
0647 C030       567           push x
0649 7530FC     568            mov x+0, #low (34300 % 0x10000) 
064C 753185     568            mov x+1, #high(34300 % 0x10000) 
064F 753200     568            mov x+2, #low (34300 / 0x10000) 
0652 753300     568            mov x+3, #high(34300 / 0x10000) 
0655 120252     569           lcall x_lteq_y
0658 200007     570           jb mf, skipval
065B D030       571           pop x
065D            572   
065D 1201A7     573           lcall add32
0660 DDD8       574           djnz R5, Sum_loop0
0662            575   
0662            576           skipval:
0662 DED6       577                  djnz R6, Sum_loop0
0664            578   
0664            579           ;load_y(100)
0664 753700     580           mov y+3, #0
0667 753600     581           mov y+2, #0
066A 753500     582           mov y+1, #0
066D 8E34       583           mov y+0, R6
066F 120376     584           lcall div32
0672 22         585           ret
0673            586   
0673            587   
0673            588   Read_ADC:
0673 C2EF       589           clr ADCF
0675 D2EE       590           setb ADCS ;  ADC start trigger signal
0677 30EFFD     591           jnb ADCF, $ ; Wait for conversion complete
067A            592           
067A            593           ; Read the ADC result and store in [R1, R0]
067A E5C2       594           mov a, ADCRL
067C 540F       595           anl a, #0x0f
067E F8         596           mov R0, a
067F E5C3       597           mov a, ADCRH  
0681 C4         598           swap a
0682 C0E0       599           push acc
0684 540F       600           anl a, #0x0f
0686 F9         601           mov R1, a
0687 D0E0       602           pop acc
0689 54F0       603           anl a, #0xf0
068B 48         604           orl a, R0
068C F8         605           mov R0, A
068D 22         606   ret
068E            607   
068E            608   DO_TEMP_READ:
068E            609           ;push x
068E            610           ; Read the 2.08V LED voltage connected to AIN0 on pin 6
068E 53E8F0     611           anl ADCCON0, #0xF0
0691 43E800     612           orl ADCCON0, #0x00 ; Select channel 0
0694            613   
0694 120673     614           lcall Read_ADC
0697            615           ; Save result for later use
0697 8846       616           mov VLED_ADC+0, R0
0699 8947       617           mov VLED_ADC+1, R1
069B            618   
069B            619           ; Read the signal connected to AIN7
069B 53E8F0     620           anl ADCCON0, #0xF0
069E 43E807     621           orl ADCCON0, #0x07 ; Select channel 7
06A1            622           ;lcall Read_ADC
06A1 12062A     623           lcall Average_ADC ;using in place of Read_ADC function, takes 100 measurements and averages
06A4            624                             ;fairly instantaneous reading 
06A4            625   
06A4            626           ; Convert to voltage
06A4 8830       627           mov x+0, R0
06A6 8931       628           mov x+1, R1
06A8            629           ; Pad other bits with zero
06A8 753200     630           mov x+2, #0
06AB 753300     631           mov x+3, #0
06AE 753414     632            mov y+0, #low (20500 % 0x10000) 
06B1 753550     632            mov y+1, #high(20500 % 0x10000) 
06B4 753600     632            mov y+2, #low (20500 / 0x10000) 
06B7 753700     632            mov y+3, #high(20500 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
06BA 12025C     633           lcall mul32
06BD            634           ; Retrive the ADC LED value
06BD 854634     635           mov y+0, VLED_ADC+0
06C0 854735     636           mov y+1, VLED_ADC+1
06C3            637           ; Pad other bits with zero
06C3 753600     638           mov y+2, #0
06C6 753700     639           mov y+3, #0
06C9 120376     640           lcall div32 ; x stores thermocouple voltage
06CC            641   
06CC 753451     642            mov y+0, #low (81 % 0x10000) 
06CF 753500     642            mov y+1, #high(81 % 0x10000) 
06D2 753600     642            mov y+2, #low (81 / 0x10000) 
06D5 753700     642            mov y+3, #high(81 / 0x10000) 
06D8 12025C     643           lcall mul32
06DB            644   
06DB            645           ; code to use temp sensor for amb temp
06DB            646           ;push x
06DB            647   ;
06DB            648           ;anl ADCCON0, #0xF0
06DB            649           ;orl ADCCON0, #0x01 ; Select channel 1
06DB            650           ;lcall Read_ADC
06DB            651   ;
06DB            652           ;mov x+0, R0
06DB            653           ;mov x+1, R1
06DB            654           ;; Pad other bits with zero
06DB            655           ;mov x+2, #0
06DB            656           ;mov x+3, #0
06DB            657           ;Load_y(20500) ; The MEASURED LED voltage: 2.074V, with 4 decimal places
06DB            658           ;lcall mul32
06DB            659           ;; Retrive the ADC LED value
06DB            660           ;mov y+0, VLED_ADC+0
06DB            661           ;mov y+1, VLED_ADC+1
06DB            662           ;; Pad other bits with zero
06DB            663           ;mov y+2, #0
06DB            664           ;mov y+3, #0
06DB            665           ;lcall div32
06DB            666   ;
06DB            667           ;load_y(100)
06DB            668           ;lcall mul32
06DB            669           ;
06DB            670           ;
06DB            671           ;load_y(273000)
06DB            672           ;lcall sub32
06DB            673   ;
06DB            674           ;mov y+0, x+0
06DB            675           ;mov y+1, x+1
06DB            676           ;mov y+2, x+2
06DB            677           ;mov y+3, x+3
06DB            678   ;
06DB            679           ;lcall hex2bcd
06DB            680           ;lcall send_temp_to_serial
06DB            681   ;
06DB            682           ;pop x
06DB            683           
06DB 753460     684            mov y+0, #low (220000 % 0x10000) 
06DE 75355B     684            mov y+1, #high(220000 % 0x10000) 
06E1 753603     684            mov y+2, #low (220000 / 0x10000) 
06E4 753700     684            mov y+3, #high(220000 / 0x10000)  ;adding 22, will change to ambient later
06E7 1201A7     685           lcall add32
06EA            686   
06EA 22         687           ret
06EB            688   
06EB            689   ;---------------------------------;
06EB            690   ; Send a BCD number to PuTTY      ;
06EB            691   ;---------------------------------;
                692   Send_BCD mac
                693   	push    ar0
                694   	mov     r0, %0
                695   	lcall   ?Send_BCD
                696   	pop     ar0
                697   	endmac
06EB            698            ?Send_BCD:
06EB C0E0       699                   push    acc
06ED            700                   ; Write most significant digit
06ED E8         701                   mov     a, r0
06EE C4         702                   swap    a
06EF 540F       703                   anl     a, #0fh
06F1 4430       704                   orl     a, #30h
06F3 1204EE     705                   lcall   putchar
06F6            706                   ; write least significant digit
06F6 E8         707                   mov     a, r0
06F7 540F       708                   anl     a, #0fh
06F9 4430       709                   orl     a, #30h
06FB 1204EE     710                   lcall   putchar
06FE D0E0       711                   pop     acc
0700 22         712   ret
0701            713   
0701            714   ; oven_FSM_LCD_DISPLAY (message)
0701            715   ; Params
0701            716   ;       message - constant string dataByte
                717   oven_FSM_LCD_DISPLAY MAC
                718           ; Display mode and temperature on line 1
                719           Set_Cursor(1,1)
                720           Send_Constant_String(%0)
                721           Send_Constant_String(#LCD_clearLine)
                722   
                723           ; display seconds on line 2
                724           Set_Cursor(2, 1)
                725           mov     a, seconds_elapsed
                726   ENDMAC
0701            727   
0701            728   ; Sends the BCD value
0701            729   send_temp_to_serial:
0701            730           ; Sends temperature
0701 C000       731            push    ar0
0703 A83F       731            mov     r0, bcd+3
0705 1206EB     731            lcall   ?Send_BCD
0708 D000       731            pop     ar0
070A C000       732            push    ar0
070C A83E       732            mov     r0, bcd+2
070E 1206EB     732            lcall   ?Send_BCD
0711 D000       732            pop     ar0
0713 742E       733           mov a, #'.'
0715 1204EE     734           lcall putchar
0718 C000       735            push    ar0
071A A83D       735            mov     r0, bcd+1
071C 1206EB     735            lcall   ?Send_BCD
071F D000       735            pop     ar0
0721 C000       736            push    ar0
0723 A83C       736            mov     r0, bcd+0
0725 1206EB     736            lcall   ?Send_BCD
0728 D000       736            pop     ar0
072A            737   
072A            738           ; Sends soak time, soak temp, reflow time, reflow temp
072A E54B       739           mov a, time_soak
072C 12051D     740           lcall SendToSerialPort 
072F E54A       741           mov a, temp_soak
0731 12051D     742           lcall SendToSerialPort 
0734 E54D       743           mov a, time_refl
0736 12051D     744           lcall SendToSerialPort 
0739 E54C       745           mov a, temp_refl
073B 12051D     746           lcall SendToSerialPort 
073E            747   
073E 740D       748           mov a,  #'\r' ; Return character
0740 1204EE     749           lcall   putchar
0743 740A       750           mov a,  #'\n' ; New-line character
0745 1204EE     751           lcall   putchar
0748            752   
0748 22         753           ret 
0749            754   
0749            755   INIT_ALL:
0749            756           ; Configure pins to be bi-directional
0749 75AC00     757           mov      P3M1,#0x00
074C 75AD00     758            mov     P3M2,#0x00
074F 75B300     759            mov     P1M1,#0x00
0752 75B400     760            mov     P1M2,#0x00
0755 75B100     761            mov     P0M1,#0x00
0758 75B200     762            mov     P0M2,#0x00
075B            763   
075B D281       764           setb    CHANGE_MENU_PIN
075D D293       765           setb    START_PIN
075F            766   
075F D2AF       767           setb    EA   ; Enable Global interrupts
0761            768   
0761            769   
0761            770           ; Since the reset button bounces, we need to wait a bit before
0761            771           ; sending messages, otherwise we risk displaying gibberish!
0761 C002       772            push AR2
0763 7A32       772            mov R2, #50
0765 120038     772            lcall ?Wait_Milli_Seconds
0768 D002       772            pop AR2
076A            773   
076A            774           ; Now we can proceed with the configuration of the serial port
076A 438E10     775           orl      CKCON, #0x10 ; CLK is the input for timer 1
076D 438780     776           orl      PCON, #0x80  ; Bit SMOD=1, double baud rate
0770 759852     777           mov      SCON, #0x52
0773 53C4DF     778           anl      T3CON, #0b11011111
0776 53890F     779           anl      TMOD, #0x0F ; Clear the configuration bits for timer 1
0779 438920     780           orl      TMOD, #0x20 ; Timer 1 Mode 2
077C 758DF7     781           mov      TH1, #TIMER1_RELOAD
077F D28E       782           setb    TR1
0781            783   
0781            784           ; ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ SUS  ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓   
0781            785           ; works on its own from lab3, might interfere with other stuff though       ; NOTE TIMER ZERO HAS NOT YET BEEN TESTED       
0781            786           ; Using timer 0 for delay functions.  Initialize here:
0781 C28C       787            clr     TR0         ; Stop timer 0
0783 438E08     788            orl     CKCON,#0x08 ; CLK is the input for timer 0
0786 5389F0     789            anl     TMOD,#0xF0  ; Clear the configuration bits for timer 0
0789 438901     790            orl     TMOD,#0x01  ; Timer 0 in Mode 1: 16-bit timer
078C            791           ; ^ ^ ^ ^ ^ ^ ^ ^^ ^ ^ ^ ^ ^^ ^ ^ ^ ^^ ^ ^ ^            
078C            792            
078C            793            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
078C 43B382     794            orl     P1M1, #0b10000010
078F 53B47D     795            anl     P1M2, #0b01111101
0792            796            
0792            797            ; Initialize and start the ADC:
0792 53E8F0     798            anl     ADCCON0, #0xF0
0795 43E807     799            orl     ADCCON0, #0x07 ; Select channel 7
0798            800            
0798            801           ; AINDIDS select if some pins are analog inputs or digital I/O:
0798 75F600     802            mov     AINDIDS, #0x00 ; Disable all analog inputs
079B 43F681     803            orl     AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
079E 43E101     804            orl     ADCCON1, #0x01 ; Enable ADC
07A1            805   
07A1            806           ; Menu Configuration
07A1 C201       807           clr     IN_MENU_FLAG
07A3 C202       808           clr     IN_OVEN_FLAG
07A5 7400       809           mov     a, #0
07A7 F549       810           mov     MENU_STATE, a ; set menu state to 0 
07A9            811   
07A9            812           ; mov     temp_soak, #0x250
07A9 754A50     813           mov     temp_soak, #MIN_TEMP ; 80
07AC 754B2D     814           mov     time_soak, #MIN_TIME
07AF 754C78     815           mov     temp_refl, #120
07B2 754D2D     816           mov     time_refl, #MIN_TIME
07B5            817           
07B5            818           ; Oven configuration
07B5 754800     819           mov     OVEN_STATE, #OVEN_STATE_PREHEAT
07B8 755100     820           mov     seconds_elapsed, #0
07BB 755500     821           mov     PWM, #0
07BE 755000     822           mov     Count1ms_PWM, #0
07C1 755200     823           mov     exit_seconds, #0
07C4 755300     824           mov     total_seconds, #0
07C7 C203       825           clr     REFLOW_FLAG
07C9 C204       826           clr     ENABLE_SEC_INC_FLAG ; flag is set to zero so that seconds won't increment
07CB C205       827           clr     TIME_TO_BEEP_FLAG   ; flag is one when we switch states (i.e will beep)
07CD            828   
07CD            829           ; clear x
07CD 753000     830           mov x+0, #0
07D0 753100     831           mov x+1, #0
07D3 753200     832           mov x+2, #0
07D6 753300     833           mov x+3, #0
07D9            834   
07D9            835           
07D9 22         836           ret
07DA            837   
07DA            838   STOP_PROCESS:
07DA            839           ; Turn everything off
07DA D205       840           setb TIME_TO_BEEP_FLAG
07DC C292       841           clr     PWM_OUT
07DE C203       842           clr     REFLOW_FLAG
07E0 C202       843           clr     IN_OVEN_FLAG
07E2 C201       844           clr     IN_MENU_FLAG
07E4 754800     845           MOV     OVEN_STATE, #OVEN_STATE_PREHEAT
07E7 755100     846           MOV     seconds_elapsed, #0
07EA 755000     847           mov     Count1ms_PWM, #0
07ED 755200     848           mov     exit_seconds, #0
07F0 755300     849           mov     total_seconds, #0
07F3 755500     850           MOV     pwm, #0
07F6 755400     851           MOV     pwm_counter, #0
07F9 753000     852           mov x+0, #0
07FC 753100     853           mov x+1, #0
07FF 753200     854           mov x+2, #0
0802 753300     855           mov x+3, #0
0805            856   
0805            857           ; mov DPTR, #emergency
0805            858           ; lcall SendString
0805            859   
0805            860           ; Do not disable TR2, otherwise temperature will no longer be sent to serial
0805            861           ; clr     TR2 ; disable timer 2 so that it doesn't count up in background ; 
0805 C204       862           clr ENABLE_SEC_INC_FLAG ; 
0807 020DE5     863           ljmp    PROGRAM_ENTRY
080A            864   
080A            865   ; Precondition: Has temperature stored in BCD
080A            866   ; States
080A            867   ;       Preheat --> Soak --> Ramp to Peak --> Reflow --> Cooling --> Finished ----> EXIT
080A            868   ;
080A            869   ; Exit conditions
080A            870   ;       1. Early exit  - Stop button pressed
080A            871   ;       2. Early exit  - Temp threshold not reached after 60s
080A            872   ;       3. Normal exit - End of FSM reached 
080A            873   ;
080A            874   ; State Layout
080A            875   ;    state_label
080A            876   ;       if OVEN_STATE != state,  jmp
080A            877   ;       display on time and temp LCD
080A            878   OVEN_FSM:
080A C205       879           clr TIME_TO_BEEP_FLAG
080C C002       880            push AR2
080E 7A32       880            mov R2, #50
0810 120038     880            lcall ?Wait_Milli_Seconds
0813 D002       880            pop AR2                                 
0815            881           
0815 D206       882           setb PB_START_PIN
0817 D207       882           setb PB_CHANGE_MENU_PIN
0819 D208       882           setb PB_INC_TEMP_PIN
081B D209       882           setb PB_INC_TIME_PIN
081D D20A       882           setb PB_STOP_PIN
081F            882           
081F D295       882           setb SHARED_PIN
0821            882           ; check if any push buttons are pressed
0821 C293       882           clr START_PIN             
0823 C281       882           clr CHANGE_MENU_PIN       
0825 C282       882           clr INC_TEMP_PIN          
0827 C283       882           clr INC_TIME_PIN          
0829 C280       882           clr STOP_PIN
082B            882   
082B            882           ; debounce
082B 209544     882           jb SHARED_PIN, enterOvenStateCheck ; use helper label to jump to the end
082E C002       882            push AR2
0830 7A32       882            mov R2, #50
0832 120038     882            lcall ?Wait_Milli_Seconds
0835 D002       882            pop AR2
0837 209538     882           jb SHARED_PIN, enterOvenStateCheck
083A            882   
083A            882           ; Set the LCD data pins to logic 1
083A D293       882           setb START_PIN
083C D281       882           setb CHANGE_MENU_PIN
083E D282       882           setb INC_TEMP_PIN
0840 D283       882           setb INC_TIME_PIN
0842 D280       882           setb STOP_PIN
0844            882   
0844            882           ; check push buttons 1 by one
0844 C293       882           clr START_PIN
0846 A295       882           mov c, SHARED_PIN
0848 9206       882           mov PB_START_PIN, c
084A D293       882           setb START_PIN
084C            882   
084C C281       882           clr CHANGE_MENU_PIN
084E A295       882           mov c, SHARED_PIN
0850 9207       882           mov PB_CHANGE_MENU_PIN, c
0852 D281       882           setb CHANGE_MENU_PIN
0854            882   
0854 C282       882           clr INC_TEMP_PIN
0856 A295       882           mov c, SHARED_PIN
0858 9208       882           mov PB_INC_TEMP_PIN, c
085A D282       882           setb INC_TEMP_PIN
085C            882   
085C C283       882           clr INC_TIME_PIN
085E A295       882           mov c, SHARED_PIN
0860 9209       882           mov PB_INC_TIME_PIN, c
0862 D283       882           setb INC_TIME_PIN
0864            882   
0864 C280       882           clr STOP_PIN
0866 A295       882           mov c, SHARED_PIN
0868 920A       882           mov PB_STOP_PIN, c
086A D280       882           setb STOP_PIN
086C            882   
086C 200A03     882           jb PB_STOP_PIN, enterOvenStateCheck ; check that the variable flag is not 1, otherwise jmp
086F            882   
086F            882       
086F 1207DA     883           lcall   STOP_PROCESS
0872            884   
0872            885           ; check oven state if stop button is not pressed
0872            886           enterOvenStateCheck:
0872 E548       887                   mov  a, OVEN_STATE
0874            888           
0874            889           ovenFSM_preheat:
0874            890                   ; long jump for relative offset
0874 B40002     891                   cjne    a, #OVEN_STATE_PREHEAT, ovenFSM_soak_jmp
0877 8003       892                   sjmp    oven_state_preheat_tasks
0879            893                   ovenFSM_soak_jmp:
0879 020937     894                           ljmp    ovenFSM_soak
087C            895                   oven_state_preheat_tasks:
087C 755564     896                           mov     pwm, #100
087F C0E0       897            push acc
0881 7401       897            mov a, #1
0883 14         897            dec a
0884 1200C7     897            lcall ?Set_Cursor_1 ; Select column and row
0887 D0E0       897            pop acc
0889 C083       898            push dph
088B C082       898            push dpl
088D C0E0       898            push acc
088F 900450     898            mov dptr, #preheatMessage
0892 1200BA     898            lcall ?Send_Constant_String
0895 D0E0       898            pop acc
0897 D082       898            pop dpl
0899 D083       898            pop dph
089B C083       899            push dph
089D C082       899            push dpl
089F C0E0       899            push acc
08A1 90043F     899            mov dptr, #LCD_clearLine
08A4 1200BA     899            lcall ?Send_Constant_String
08A7 D0E0       899            pop acc
08A9 D082       899            pop dpl
08AB D083       899            pop dph
08AD C0E0       900            push acc
08AF 740E       900            mov a, #14
08B1 14         900            dec a
08B2 1200C5     900            lcall ?Set_Cursor_2 ; Select column and row
08B5 D0E0       900            pop acc
08B7 E551       901                           mov     a, seconds_elapsed
08B9 120501     902                           lcall   SendToLCD ; send seconds to LCD
08BC E553       903                           mov     a, total_seconds
08BE C0E0       904            push acc
08C0 740E       904            mov a, #14
08C2 14         904            dec a
08C3 1200C7     904            lcall ?Set_Cursor_1 ; Select column and row
08C6 D0E0       904            pop acc
08C8 120501     905                           lcall   SendToLCD
08CB 1200E2     906                           lcall   hex2bcd
08CE            907                           ; lcall   send_temp_to_serial
08CE 1205D2     908                           lcall   Display_formated_BCD
08D1            909   
08D1            910                   ;Emergency exit process; tested, works
08D1 D203       911                   setb    REFLOW_FLAG
08D3 E552       912                   mov     a, exit_seconds
08D5 B43C15     913                   cjne    a, #60, Skip_Emergency_exit
08D8 753420     914            mov y+0, #low (50*10000 % 0x10000) 
08DB 7535A1     914            mov y+1, #high(50*10000 % 0x10000) 
08DE 753607     914            mov y+2, #low (50*10000 / 0x10000) 
08E1 753700     914            mov y+3, #high(50*10000 / 0x10000) 
08E4 120248     915                   lcall   x_gteq_y
08E7 200003     916                   jb      mf, Skip_Emergency_exit ; if x > y, don't exit
08EA            917                   
08EA            918                   ; mov a, temp
08EA            919                   ; lcall ;send temperature value to serial
08EA 0207DA     920                   ljmp    STOP_PROCESS ; more then 60 seconds has elapsed and we are below 50C ESCAPE
08ED            921                   
08ED            922           Skip_Emergency_exit:       
08ED            923                   ; State transition check ; if x > temp_soak, next state ; else, self loop
08ED            924   
08ED            925                   ; first check that temperature is valid
08ED 7534C0     926            mov y+0, #low (3000000 % 0x10000) 
08F0 7535C6     926            mov y+1, #high(3000000 % 0x10000) 
08F3 75362D     926            mov y+2, #low (3000000 / 0x10000) 
08F6 753700     926            mov y+3, #high(3000000 / 0x10000)  ; 300 degrees
08F9 120206     927                   lcall x_gt_y   
08FC 200035     928                   jb mf, noChange_preHeat ; x > 300 degrees, this is an invalid temperature 
08FF            929   
08FF 854A34     930                   mov y+0, temp_soak
0902 753500     931                   mov y+1, #0
0905 753600     932                   mov y+2, #0
0908 753700     933                   mov y+3, #0        
090B 753810     934            mov z+0, #low (10000 % 0x10000) 
090E 753927     934            mov z+1, #high(10000 % 0x10000) 
0911 753A00     934            mov z+2, #low (10000 / 0x10000) 
0914 753B00     934            mov z+3, #high(10000 / 0x10000) 
0917 1202E9     935                   lcall mul32z
091A 853834     936                   mov y+0, z+0
091D 853935     937                   mov y+1, z+1
0920 853A36     938                   mov y+2, z+2
0923 853B37     939                   mov y+3, z+3                        
0926            940   
0926 120206     941                   lcall x_gt_y
0929 300008     942                   jnb mf, noChange_preHeat ; jump past the jnb and mov instructions which are both 3 bytes
092C 754801     943                   mov OVEN_STATE, #OVEN_STATE_SOAK
092F 755100     944                   mov seconds_elapsed, #0
0932 D205       945                   setb TIME_TO_BEEP_FLAG
0934            946           noChange_preHeat:
0934 020B9B     947                   ljmp oven_FSM_done
0937            948           
0937            949           ovenFSM_soak:
0937 B40165     950                   cjne    a, #OVEN_STATE_SOAK, ovenFSM_Ramp2Peak
093A 755501     951                   mov     pwm, #1
093D C0E0       952            push acc
093F 7401       952            mov a, #1
0941 14         952            dec a
0942 1200C7     952            lcall ?Set_Cursor_1 ; Select column and row
0945 D0E0       952            pop acc
0947 C083       953            push dph
0949 C082       953            push dpl
094B C0E0       953            push acc
094D 900458     953            mov dptr, #soakMessage
0950 1200BA     953            lcall ?Send_Constant_String
0953 D0E0       953            pop acc
0955 D082       953            pop dpl
0957 D083       953            pop dph
0959 C083       954            push dph
095B C082       954            push dpl
095D C0E0       954            push acc
095F 90043F     954            mov dptr, #LCD_clearLine
0962 1200BA     954            lcall ?Send_Constant_String
0965 D0E0       954            pop acc
0967 D082       954            pop dpl
0969 D083       954            pop dph
096B C0E0       955            push acc
096D 740E       955            mov a, #14
096F 14         955            dec a
0970 1200C5     955            lcall ?Set_Cursor_2 ; Select column and row
0973 D0E0       955            pop acc
0975 E551       956                   mov     a, seconds_elapsed
0977 120501     957                   lcall   SendToLCD
097A E553       958                   mov     a, total_seconds
097C C0E0       959            push acc
097E 740E       959            mov a, #14
0980 14         959            dec a
0981 1200C7     959            lcall ?Set_Cursor_1 ; Select column and row
0984 D0E0       959            pop acc
0986 120501     960                   lcall SendToLCD
0989            961                   
0989 1200E2     962                   lcall   hex2bcd
098C 1205D2     963                   lcall   Display_formated_BCD
098F            964   
098F            965                   ; check if seconds elapsed > soak time
098F E551       966                   mov     a, seconds_elapsed
0991 B54B08     967                   cjne    a, time_soak, noChange_soakState
0994 754802     968                   mov     OVEN_STATE, #OVEN_STATE_RAMP2PEAK
0997 755100     969                   mov     seconds_elapsed, #0 ; reset
099A D205       970                   setb    TIME_TO_BEEP_FLAG
099C            971                   noChange_soakState:
099C 020B9B     972                           ljmp    oven_FSM_done
099F            973           
099F            974           ovenFSM_Ramp2Peak:
099F B40202     975                   cjne    a, #OVEN_STATE_RAMP2PEAK, ovenFSM_reflow_jmp
09A2 8003       976                   sjmp ovenFSM_Ramp2Peak_task
09A4            977                   ovenFSM_reflow_jmp:
09A4 020A49     978                   ljmp ovenFSM_reflow
09A7            979                   ovenFSM_Ramp2Peak_task:
09A7 755564     980                   mov     pwm, #100
09AA C0E0       981            push acc
09AC 7401       981            mov a, #1
09AE 14         981            dec a
09AF 1200C7     981            lcall ?Set_Cursor_1 ; Select column and row
09B2 D0E0       981            pop acc
09B4 C083       982            push dph
09B6 C082       982            push dpl
09B8 C0E0       982            push acc
09BA 90045D     982            mov dptr, #ramp2peakMessage
09BD 1200BA     982            lcall ?Send_Constant_String
09C0 D0E0       982            pop acc
09C2 D082       982            pop dpl
09C4 D083       982            pop dph
09C6 C083       983            push dph
09C8 C082       983            push dpl
09CA C0E0       983            push acc
09CC 90043F     983            mov dptr, #LCD_clearLine
09CF 1200BA     983            lcall ?Send_Constant_String
09D2 D0E0       983            pop acc
09D4 D082       983            pop dpl
09D6 D083       983            pop dph
09D8 C0E0       984            push acc
09DA 740E       984            mov a, #14
09DC 14         984            dec a
09DD 1200C5     984            lcall ?Set_Cursor_2 ; Select column and row
09E0 D0E0       984            pop acc
09E2 E551       985                   mov     a, seconds_elapsed
09E4 120501     986                   lcall   SendToLCD
09E7 E553       987                   mov     a, total_seconds
09E9 C0E0       988            push acc
09EB 740E       988            mov a, #14
09ED 14         988            dec a
09EE 1200C7     988            lcall ?Set_Cursor_1 ; Select column and row
09F1 D0E0       988            pop acc
09F3 120501     989                   lcall SendToLCD
09F6            990   
09F6 1200E2     991                   lcall   hex2bcd
09F9 1205D2     992                   lcall   Display_formated_BCD
09FC            993   
09FC            994                   ; check that temperature for reflow is reached, then exit 
09FC 7534C0     995            mov y+0, #low (3000000 % 0x10000) 
09FF 7535C6     995            mov y+1, #high(3000000 % 0x10000) 
0A02 75362D     995            mov y+2, #low (3000000 / 0x10000) 
0A05 753700     995            mov y+3, #high(3000000 / 0x10000)   ; 300 degrees
0A08 1201EA     996                   lcall x_lt_y     ; check if x < 300
0A0B 200003     997                   jb mf, validTemp ; x < 300 degrees, this is a invalid, skip state transition
0A0E 020B9B     998                   ljmp oven_FSM_done
0A11            999   
0A11           1000                   validTemp:
0A11 854C34    1001                   mov y+0, temp_refl
0A14 753500    1002                   mov y+1, #0
0A17 753600    1003                   mov y+2, #0
0A1A 753700    1004                   mov y+3, #0        
0A1D 753810    1005            mov z+0, #low (10000 % 0x10000) 
0A20 753927    1005            mov z+1, #high(10000 % 0x10000) 
0A23 753A00    1005            mov z+2, #low (10000 / 0x10000) 
0A26 753B00    1005            mov z+3, #high(10000 / 0x10000) 
0A29 1202E9    1006                   lcall mul32z
0A2C 853834    1007                   mov y+0, z+0
0A2F 853935    1008                   mov y+1, z+1
0A32 853A36    1009                   mov y+2, z+2
0A35 853B37    1010                   mov y+3, z+3                        
0A38           1011   
0A38           1012                   ; logging the value of y on serial
0A38           1013                   ; mov DPTR, #reflow
0A38           1014                   ; lcall SendString 
0A38           1015   
0A38           1016                   ; mov a, y+3
0A38           1017                   ; lcall SendToSerialPort
0A38           1018                   ; mov a, y+2
0A38           1019                   ; lcall SendToSerialPort
0A38           1020                   ; mov a, y+1
0A38           1021                   ; lcall SendToSerialPort
0A38           1022                   ; mov a, y+0
0A38           1023                   ; lcall SendToSerialPort
0A38           1024   
0A38           1025                   ; mov a,  #'\r' ; Return character
0A38           1026                   ; lcall   putchar
0A38           1027                   ; mov a,  #'\n' ; New-line character
0A38           1028                   ; lcall   putchar
0A38           1029   
0A38 120206    1030                   lcall x_gt_y
0A3B 300006    1031                   jnb mf, $+3+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
0A3E 754803    1032                   mov OVEN_STATE, #OVEN_STATE_REFLOW
0A41 755100    1033                   mov  seconds_elapsed, #0
0A44 D205      1034                   setb TIME_TO_BEEP_FLAG
0A46 020B9B    1035                   ljmp oven_FSM_done
0A49           1036                   
0A49           1037           ovenFSM_reflow:
0A49 B40365    1038                   cjne    a, #OVEN_STATE_REFLOW, ovenFSM_cooling
0A4C 755505    1039                   mov     pwm, #5
0A4F C0E0      1040            push acc
0A51 7401      1040            mov a, #1
0A53 14        1040            dec a
0A54 1200C7    1040            lcall ?Set_Cursor_1 ; Select column and row
0A57 D0E0      1040            pop acc
0A59 C083      1041            push dph
0A5B C082      1041            push dpl
0A5D C0E0      1041            push acc
0A5F 90046A    1041            mov dptr, #reflowMessage
0A62 1200BA    1041            lcall ?Send_Constant_String
0A65 D0E0      1041            pop acc
0A67 D082      1041            pop dpl
0A69 D083      1041            pop dph
0A6B C083      1042            push dph
0A6D C082      1042            push dpl
0A6F C0E0      1042            push acc
0A71 90043F    1042            mov dptr, #LCD_clearLine
0A74 1200BA    1042            lcall ?Send_Constant_String
0A77 D0E0      1042            pop acc
0A79 D082      1042            pop dpl
0A7B D083      1042            pop dph
0A7D C0E0      1043            push acc
0A7F 740E      1043            mov a, #14
0A81 14        1043            dec a
0A82 1200C5    1043            lcall ?Set_Cursor_2 ; Select column and row
0A85 D0E0      1043            pop acc
0A87 E551      1044                   mov     a, seconds_elapsed
0A89 120501    1045                   lcall   SendToLCD
0A8C E553      1046                   mov     a, total_seconds
0A8E C0E0      1047            push acc
0A90 740E      1047            mov a, #14
0A92 14        1047            dec a
0A93 1200C7    1047            lcall ?Set_Cursor_1 ; Select column and row
0A96 D0E0      1047            pop acc
0A98 120501    1048                   lcall SendToLCD
0A9B           1049   
0A9B 1200E2    1050                   lcall   hex2bcd
0A9E 1205D2    1051                   lcall   Display_formated_BCD
0AA1           1052   
0AA1           1053                   ; check if seconds elapsed > reflow time
0AA1 E551      1054                   mov     a, seconds_elapsed
0AA3 B54D08    1055                   cjne    a, time_refl, noChange_reflowState
0AA6 754804    1056                   mov     OVEN_STATE, #OVEN_STATE_COOLING
0AA9 755100    1057                   mov     seconds_elapsed, #0 ; reset
0AAC D205      1058                   setb    TIME_TO_BEEP_FLAG
0AAE           1059                   noChange_reflowState:
0AAE 020B9B    1060                           ljmp    oven_FSM_done
0AB1           1061   
0AB1           1062           ovenFSM_cooling:
0AB1 B40472    1063                   cjne    a, #OVEN_STATE_COOLING, ovenFSM_finished
0AB4 755500    1064                   mov     pwm, #0
0AB7 C0E0      1065            push acc
0AB9 7401      1065            mov a, #1
0ABB 14        1065            dec a
0ABC 1200C7    1065            lcall ?Set_Cursor_1 ; Select column and row
0ABF D0E0      1065            pop acc
0AC1 C083      1066            push dph
0AC3 C082      1066            push dpl
0AC5 C0E0      1066            push acc
0AC7 900471    1066            mov dptr, #coolingMessage
0ACA 1200BA    1066            lcall ?Send_Constant_String
0ACD D0E0      1066            pop acc
0ACF D082      1066            pop dpl
0AD1 D083      1066            pop dph
0AD3 C083      1067            push dph
0AD5 C082      1067            push dpl
0AD7 C0E0      1067            push acc
0AD9 90043F    1067            mov dptr, #LCD_clearLine
0ADC 1200BA    1067            lcall ?Send_Constant_String
0ADF D0E0      1067            pop acc
0AE1 D082      1067            pop dpl
0AE3 D083      1067            pop dph
0AE5 C0E0      1068            push acc
0AE7 740E      1068            mov a, #14
0AE9 14        1068            dec a
0AEA 1200C5    1068            lcall ?Set_Cursor_2 ; Select column and row
0AED D0E0      1068            pop acc
0AEF E551      1069                   mov     a, seconds_elapsed
0AF1 120501    1070                   lcall   SendToLCD
0AF4 E553      1071                   mov     a, total_seconds
0AF6 C0E0      1072            push acc
0AF8 740E      1072            mov a, #14
0AFA 14        1072            dec a
0AFB 1200C7    1072            lcall ?Set_Cursor_1 ; Select column and row
0AFE D0E0      1072            pop acc
0B00 120501    1073                   lcall SendToLCD
0B03           1074   
0B03 1200E2    1075                   lcall   hex2bcd
0B06           1076                   ; lcall   send_temp_to_serial
0B06 1205D2    1077                   lcall   Display_formated_BCD
0B09           1078   
0B09           1079                   ; once temperature is low (compare with temp constant)
0B09 753420    1080            mov y+0, #low (50 * 10000 % 0x10000) 
0B0C 7535A1    1080            mov y+1, #high(50 * 10000 % 0x10000) 
0B0F 753607    1080            mov y+2, #low (50 * 10000 / 0x10000) 
0B12 753700    1080            mov y+3, #high(50 * 10000 / 0x10000) 
0B15 1201EA    1081                   lcall x_lt_y
0B18 300006    1082                   jnb mf, $+3+3+3 ; jump past the jnb and mov instructions which are both 3 bytes
0B1B 754805    1083                   mov OVEN_STATE, #OVEN_STATE_FINISHED
0B1E 755100    1084                   mov     seconds_elapsed, #0 ; reset
0B21 D205      1085                   setb    TIME_TO_BEEP_FLAG
0B23 020B9B    1086                   ljmp oven_FSM_done
0B26           1087   
0B26           1088           ovenFSM_finished:
0B26 B4056C    1089                   cjne    a, #OVEN_STATE_FINISHED, ovenFSM_exit
0B29 C0E0      1090            push acc
0B2B 7401      1090            mov a, #1
0B2D 14        1090            dec a
0B2E 1200C7    1090            lcall ?Set_Cursor_1 ; Select column and row
0B31 D0E0      1090            pop acc
0B33 C083      1091            push dph
0B35 C082      1091            push dpl
0B37 C0E0      1091            push acc
0B39 900479    1091            mov dptr, #FinishedMessage
0B3C 1200BA    1091            lcall ?Send_Constant_String
0B3F D0E0      1091            pop acc
0B41 D082      1091            pop dpl
0B43 D083      1091            pop dph
0B45 C083      1092            push dph
0B47 C082      1092            push dpl
0B49 C0E0      1092            push acc
0B4B 90043F    1092            mov dptr, #LCD_clearLine
0B4E 1200BA    1092            lcall ?Send_Constant_String
0B51 D0E0      1092            pop acc
0B53 D082      1092            pop dpl
0B55 D083      1092            pop dph
0B57 C0E0      1093            push acc
0B59 740E      1093            mov a, #14
0B5B 14        1093            dec a
0B5C 1200C5    1093            lcall ?Set_Cursor_2 ; Select column and row
0B5F D0E0      1093            pop acc
0B61 E551      1094                   mov     a, seconds_elapsed
0B63 120501    1095                   lcall   SendToLCD
0B66 E553      1096                   mov     a, total_seconds
0B68 C0E0      1097            push acc
0B6A 740E      1097            mov a, #14
0B6C 14        1097            dec a
0B6D 1200C7    1097            lcall ?Set_Cursor_1 ; Select column and row
0B70 D0E0      1097            pop acc
0B72 120501    1098                   lcall SendToLCD
0B75           1099                   
0B75 C083      1100            push dph
0B77 C082      1100            push dpl
0B79 C0E0      1100            push acc
0B7B 90043F    1100            mov dptr, #LCD_clearLine
0B7E 1200BA    1100            lcall ?Send_Constant_String
0B81 D0E0      1100            pop acc
0B83 D082      1100            pop dpl
0B85 D083      1100            pop dph
0B87           1101   
0B87           1102   
0B87           1103                   ; go back to Start Screen after a certain number of seconds
0B87 E551      1104                   mov     a, seconds_elapsed
0B89 B40506    1105                   cjne    a, #FINISHED_SECONDS, noChange_finishedState
0B8C 754800    1106                   mov OVEN_STATE, #OVEN_STATE_PREHEAT
0B8F 1207DA    1107                   lcall STOP_PROCESS
0B92           1108                   noChange_finishedState:
0B92 020B9B    1109                           ljmp    oven_FSM_done
0B95           1110   
0B95           1111           ovenFSM_exit:
0B95 754800    1112                   mov     OVEN_STATE, #OVEN_STATE_PREHEAT
0B98           1113                   ; ljmp oven_FSM_done
0B98 1207DA    1114                   lcall   STOP_PROCESS ; Exit oven FSM, turn power off, return to program entry
0B9B           1115                   
0B9B           1116           oven_FSM_done:
0B9B 02080A    1117                   ljmp    OVEN_FSM ; return to start of oven FSM ; this is a blocking FSM
0B9E           1118           
0B9E 22        1119   ret ; technically unncessary
0B9F           1120   
0B9F           1121   MENU_FSM: 
0B9F           1122           ; lcall configure_LCD_multiplexing
0B9F 755500    1123           mov     pwm, #0
0BA2 E549      1124           mov     a, MENU_STATE 
0BA4 D206      1125           setb PB_START_PIN
0BA6 D207      1125           setb PB_CHANGE_MENU_PIN
0BA8 D208      1125           setb PB_INC_TEMP_PIN
0BAA D209      1125           setb PB_INC_TIME_PIN
0BAC D20A      1125           setb PB_STOP_PIN
0BAE           1125           
0BAE D295      1125           setb SHARED_PIN
0BB0           1125           ; check if any push buttons are pressed
0BB0 C293      1125           clr START_PIN             
0BB2 C281      1125           clr CHANGE_MENU_PIN       
0BB4 C282      1125           clr INC_TEMP_PIN          
0BB6 C283      1125           clr INC_TIME_PIN          
0BB8 C280      1125           clr STOP_PIN
0BBA           1125   
0BBA           1125           ; debounce
0BBA 209548    1125           jb SHARED_PIN, checkTimeInc ; use helper label to jump to the end
0BBD C002      1125            push AR2
0BBF 7A32      1125            mov R2, #50
0BC1 120038    1125            lcall ?Wait_Milli_Seconds
0BC4 D002      1125            pop AR2
0BC6 20953C    1125           jb SHARED_PIN, checkTimeInc
0BC9           1125   
0BC9           1125           ; Set the LCD data pins to logic 1
0BC9 D293      1125           setb START_PIN
0BCB D281      1125           setb CHANGE_MENU_PIN
0BCD D282      1125           setb INC_TEMP_PIN
0BCF D283      1125           setb INC_TIME_PIN
0BD1 D280      1125           setb STOP_PIN
0BD3           1125   
0BD3           1125           ; check push buttons 1 by one
0BD3 C293      1125           clr START_PIN
0BD5 A295      1125           mov c, SHARED_PIN
0BD7 9206      1125           mov PB_START_PIN, c
0BD9 D293      1125           setb START_PIN
0BDB           1125   
0BDB C281      1125           clr CHANGE_MENU_PIN
0BDD A295      1125           mov c, SHARED_PIN
0BDF 9207      1125           mov PB_CHANGE_MENU_PIN, c
0BE1 D281      1125           setb CHANGE_MENU_PIN
0BE3           1125   
0BE3 C282      1125           clr INC_TEMP_PIN
0BE5 A295      1125           mov c, SHARED_PIN
0BE7 9208      1125           mov PB_INC_TEMP_PIN, c
0BE9 D282      1125           setb INC_TEMP_PIN
0BEB           1125   
0BEB C283      1125           clr INC_TIME_PIN
0BED A295      1125           mov c, SHARED_PIN
0BEF 9209      1125           mov PB_INC_TIME_PIN, c
0BF1 D283      1125           setb INC_TIME_PIN
0BF3           1125   
0BF3 C280      1125           clr STOP_PIN
0BF5 A295      1125           mov c, SHARED_PIN
0BF7 920A      1125           mov PB_STOP_PIN, c
0BF9 D280      1125           setb STOP_PIN
0BFB           1125   
0BFB 200707    1125           jb PB_CHANGE_MENU_PIN, checkTimeInc ; check that the variable flag is not 1, otherwise jmp
0BFE           1125    ; increments menu state
0BFE 04        1126           inc     a
0BFF F549      1127           mov     MENU_STATE, a 
0C01 C205      1128           clr     TIME_TO_BEEP_FLAG
0C03 D281      1129           setb    CHANGE_MENU_PIN
0C05           1130           
0C05           1131   
0C05           1132           ; increment is checked with a seperate cascade that's outside the FSM
0C05           1133           ; I wanted to keep FSM state outputs seperate from push button checks - George
0C05           1134           checkTimeInc:
0C05 D206      1135           setb PB_START_PIN
0C07 D207      1135           setb PB_CHANGE_MENU_PIN
0C09 D208      1135           setb PB_INC_TEMP_PIN
0C0B D209      1135           setb PB_INC_TIME_PIN
0C0D D20A      1135           setb PB_STOP_PIN
0C0F           1135           
0C0F D295      1135           setb SHARED_PIN
0C11           1135           ; check if any push buttons are pressed
0C11 C293      1135           clr START_PIN             
0C13 C281      1135           clr CHANGE_MENU_PIN       
0C15 C282      1135           clr INC_TEMP_PIN          
0C17 C283      1135           clr INC_TIME_PIN          
0C19 C280      1135           clr STOP_PIN
0C1B           1135   
0C1B           1135           ; debounce
0C1B 209560    1135           jb SHARED_PIN, checkTempInc ; use helper label to jump to the end
0C1E C002      1135            push AR2
0C20 7A32      1135            mov R2, #50
0C22 120038    1135            lcall ?Wait_Milli_Seconds
0C25 D002      1135            pop AR2
0C27 209554    1135           jb SHARED_PIN, checkTempInc
0C2A           1135   
0C2A           1135           ; Set the LCD data pins to logic 1
0C2A D293      1135           setb START_PIN
0C2C D281      1135           setb CHANGE_MENU_PIN
0C2E D282      1135           setb INC_TEMP_PIN
0C30 D283      1135           setb INC_TIME_PIN
0C32 D280      1135           setb STOP_PIN
0C34           1135   
0C34           1135           ; check push buttons 1 by one
0C34 C293      1135           clr START_PIN
0C36 A295      1135           mov c, SHARED_PIN
0C38 9206      1135           mov PB_START_PIN, c
0C3A D293      1135           setb START_PIN
0C3C           1135   
0C3C C281      1135           clr CHANGE_MENU_PIN
0C3E A295      1135           mov c, SHARED_PIN
0C40 9207      1135           mov PB_CHANGE_MENU_PIN, c
0C42 D281      1135           setb CHANGE_MENU_PIN
0C44           1135   
0C44 C282      1135           clr INC_TEMP_PIN
0C46 A295      1135           mov c, SHARED_PIN
0C48 9208      1135           mov PB_INC_TEMP_PIN, c
0C4A D282      1135           setb INC_TEMP_PIN
0C4C           1135   
0C4C C283      1135           clr INC_TIME_PIN
0C4E A295      1135           mov c, SHARED_PIN
0C50 9209      1135           mov PB_INC_TIME_PIN, c
0C52 D283      1135           setb INC_TIME_PIN
0C54           1135   
0C54 C280      1135           clr STOP_PIN
0C56 A295      1135           mov c, SHARED_PIN
0C58 920A      1135           mov PB_STOP_PIN, c
0C5A D280      1135           setb STOP_PIN
0C5C           1135   
0C5C 20091F    1135           jb PB_INC_TIME_PIN, checkTempInc ; check that the variable flag is not 1, otherwise jmp
0C5F           1135   
0C5F           1135   
0C5F B4000F    1136                   cjne a, #MENU_STATE_SOAK, incTimeReflow
0C62 E54B      1137                           mov     a, time_soak 
0C64 2405      1138                           add     A, #5        
0C66 F54B      1139                           mov     time_soak, a 
0C68           1140   
0C68           1141                           ; check if time_soak will need to reset - assumes multiples of 5
0C68           1142                           ; +5 to constants so they display on LCD b/f reseting
0C68 B45F13    1143                           cjne a, #(MAX_TIME+5), checkTempInc 
0C6B 742D      1144                           mov a, #MIN_TIME
0C6D F54B      1145                           mov time_soak, a
0C6F           1146   
0C6F 800D      1147                           sjmp checkTempInc       
0C71           1148                   incTimeReflow:
0C71 E54D      1149                           mov     a, time_refl
0C73 2405      1150                           add     A, #5
0C75 F54D      1151                           mov     time_refl, a
0C77           1152   
0C77 B45F04    1153                           cjne a, #(MAX_TIME+5), checkTempInc
0C7A 742D      1154                           mov a, #MIN_TIME
0C7C F54D      1155                           mov time_refl, a
0C7E           1156   
0C7E           1157           ; check whether we're in the soak or 
0C7E           1158           checkTempInc:
0C7E D206      1159           setb PB_START_PIN
0C80 D207      1159           setb PB_CHANGE_MENU_PIN
0C82 D208      1159           setb PB_INC_TEMP_PIN
0C84 D209      1159           setb PB_INC_TIME_PIN
0C86 D20A      1159           setb PB_STOP_PIN
0C88           1159           
0C88 D295      1159           setb SHARED_PIN
0C8A           1159           ; check if any push buttons are pressed
0C8A C293      1159           clr START_PIN             
0C8C C281      1159           clr CHANGE_MENU_PIN       
0C8E C282      1159           clr INC_TEMP_PIN          
0C90 C283      1159           clr INC_TIME_PIN          
0C92 C280      1159           clr STOP_PIN
0C94           1159   
0C94           1159           ; debounce
0C94 209560    1159           jb SHARED_PIN, enterMenuStateCheck ; use helper label to jump to the end
0C97 C002      1159            push AR2
0C99 7A32      1159            mov R2, #50
0C9B 120038    1159            lcall ?Wait_Milli_Seconds
0C9E D002      1159            pop AR2
0CA0 209554    1159           jb SHARED_PIN, enterMenuStateCheck
0CA3           1159   
0CA3           1159           ; Set the LCD data pins to logic 1
0CA3 D293      1159           setb START_PIN
0CA5 D281      1159           setb CHANGE_MENU_PIN
0CA7 D282      1159           setb INC_TEMP_PIN
0CA9 D283      1159           setb INC_TIME_PIN
0CAB D280      1159           setb STOP_PIN
0CAD           1159   
0CAD           1159           ; check push buttons 1 by one
0CAD C293      1159           clr START_PIN
0CAF A295      1159           mov c, SHARED_PIN
0CB1 9206      1159           mov PB_START_PIN, c
0CB3 D293      1159           setb START_PIN
0CB5           1159   
0CB5 C281      1159           clr CHANGE_MENU_PIN
0CB7 A295      1159           mov c, SHARED_PIN
0CB9 9207      1159           mov PB_CHANGE_MENU_PIN, c
0CBB D281      1159           setb CHANGE_MENU_PIN
0CBD           1159   
0CBD C282      1159           clr INC_TEMP_PIN
0CBF A295      1159           mov c, SHARED_PIN
0CC1 9208      1159           mov PB_INC_TEMP_PIN, c
0CC3 D282      1159           setb INC_TEMP_PIN
0CC5           1159   
0CC5 C283      1159           clr INC_TIME_PIN
0CC7 A295      1159           mov c, SHARED_PIN
0CC9 9209      1159           mov PB_INC_TIME_PIN, c
0CCB D283      1159           setb INC_TIME_PIN
0CCD           1159   
0CCD C280      1159           clr STOP_PIN
0CCF A295      1159           mov c, SHARED_PIN
0CD1 920A      1159           mov PB_STOP_PIN, c
0CD3 D280      1159           setb STOP_PIN
0CD5           1159   
0CD5 20081F    1159           jb PB_INC_TEMP_PIN, enterMenuStateCheck ; check that the variable flag is not 1, otherwise jmp
0CD8           1159   
0CD8 B4000F    1160                   cjne a, #MENU_STATE_SOAK, incTempReflow
0CDB E54A      1161                           mov     a, temp_soak 
0CDD 2405      1162                           add     a, #5        
0CDF F54A      1163                           mov     temp_soak, a 
0CE1           1164   
0CE1 B4FF13    1165                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
0CE4 7450      1166                           mov a, #MIN_TEMP
0CE6 F54A      1167                           mov temp_soak, a
0CE8           1168   
0CE8 800D      1169                           sjmp enterMenuStateCheck       
0CEA           1170                   incTempReflow:
0CEA E54C      1171                           mov     a, temp_refl
0CEC 2405      1172                           add     a, #5
0CEE F54C      1173                           mov     temp_refl, a
0CF0           1174   
0CF0 B4FF04    1175                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
0CF3 7450      1176                           mov a, #MIN_TEMP
0CF5 F54C      1177                           mov temp_refl, a
0CF7           1178   
0CF7           1179           ; ---------------- FSM State Check ---------------- ;  
0CF7           1180           enterMenuStateCheck:
0CF7 D282      1181                   setb INC_TEMP_PIN
0CF9 E549      1182                   mov     a, MENU_STATE
0CFB           1183   
0CFB           1184           menuFSM_configSoak:
0CFB B40069    1185                   cjne    a, #MENU_STATE_SOAK, menuFSM_configReflow
0CFE           1186                   ; display Soak Menu Options
0CFE C0E0      1187            push acc
0D00 7401      1187            mov a, #1
0D02 14        1187            dec a
0D03 1200C7    1187            lcall ?Set_Cursor_1 ; Select column and row
0D06 D0E0      1187            pop acc
0D08 C083      1188            push dph
0D0A C082      1188            push dpl
0D0C C0E0      1188            push acc
0D0E 90040D    1188            mov dptr, #LCD_soakTemp
0D11 1200BA    1188            lcall ?Send_Constant_String
0D14 D0E0      1188            pop acc
0D16 D082      1188            pop dpl
0D18 D083      1188            pop dph
0D1A           1188   
0D1A E54A      1189                   mov     a, temp_soak
0D1C 120501    1190                   lcall   SendToLCD
0D1F C083      1191            push dph
0D21 C082      1191            push dpl
0D23 C0E0      1191            push acc
0D25 90043F    1191            mov dptr, #LCD_clearLine
0D28 1200BA    1191            lcall ?Send_Constant_String
0D2B D0E0      1191            pop acc
0D2D D082      1191            pop dpl
0D2F D083      1191            pop dph
0D31 C0E0      1192            push acc
0D33 7401      1192            mov a, #1
0D35 14        1192            dec a
0D36 1200C5    1192            lcall ?Set_Cursor_2 ; Select column and row
0D39 D0E0      1192            pop acc
0D3B C083      1193            push dph
0D3D C082      1193            push dpl
0D3F C0E0      1193            push acc
0D41 900401    1193            mov dptr, #LCD_soakTime
0D44 1200BA    1193            lcall ?Send_Constant_String
0D47 D0E0      1193            pop acc
0D49 D082      1193            pop dpl
0D4B D083      1193            pop dph
0D4D E54B      1194                   mov     a, time_soak
0D4F 120501    1195                   lcall   SendToLCD
0D52 C083      1196            push dph
0D54 C082      1196            push dpl
0D56 C0E0      1196            push acc
0D58 90043F    1196            mov dptr, #LCD_clearLine
0D5B 1200BA    1196            lcall ?Send_Constant_String
0D5E D0E0      1196            pop acc
0D60 D082      1196            pop dpl
0D62 D083      1196            pop dph
0D64 020DD9    1197                   ljmp    menu_FSM_done
0D67           1198   
0D67           1199           menuFSM_configReflow:
0D67 B40169    1200                   cjne    a, #MENU_STATE_REFLOW, reset_menu_state
0D6A           1201                   ; display Reflow Menu Options
0D6A C0E0      1202            push acc
0D6C 7401      1202            mov a, #1
0D6E 14        1202            dec a
0D6F 1200C7    1202            lcall ?Set_Cursor_1 ; Select column and row
0D72 D0E0      1202            pop acc
0D74 C083      1203            push dph
0D76 C082      1203            push dpl
0D78 C0E0      1203            push acc
0D7A 900425    1203            mov dptr, #LCD_reflowTemp
0D7D 1200BA    1203            lcall ?Send_Constant_String
0D80 D0E0      1203            pop acc
0D82 D082      1203            pop dpl
0D84 D083      1203            pop dph
0D86 E54C      1204                   mov     a, temp_refl
0D88 120501    1205                   lcall   SendToLCD
0D8B C083      1206            push dph
0D8D C082      1206            push dpl
0D8F C0E0      1206            push acc
0D91 90043F    1206            mov dptr, #LCD_clearLine
0D94 1200BA    1206            lcall ?Send_Constant_String
0D97 D0E0      1206            pop acc
0D99 D082      1206            pop dpl
0D9B D083      1206            pop dph
0D9D C0E0      1207            push acc
0D9F 7401      1207            mov a, #1
0DA1 14        1207            dec a
0DA2 1200C5    1207            lcall ?Set_Cursor_2 ; Select column and row
0DA5 D0E0      1207            pop acc
0DA7 C083      1208            push dph
0DA9 C082      1208            push dpl
0DAB C0E0      1208            push acc
0DAD 900419    1208            mov dptr, #LCD_reflowTime
0DB0 1200BA    1208            lcall ?Send_Constant_String
0DB3 D0E0      1208            pop acc
0DB5 D082      1208            pop dpl
0DB7 D083      1208            pop dph
0DB9 E54D      1209                   mov     a, time_refl
0DBB 120501    1210                   lcall   SendToLCD
0DBE C083      1211            push dph
0DC0 C082      1211            push dpl
0DC2 C0E0      1211            push acc
0DC4 90043F    1211            mov dptr, #LCD_clearLine
0DC7 1200BA    1211            lcall ?Send_Constant_String
0DCA D0E0      1211            pop acc
0DCC D082      1211            pop dpl
0DCE D083      1211            pop dph
0DD0 020DD9    1212                   ljmp    menu_FSM_done
0DD3           1213   
0DD3           1214           reset_menu_state: ; sets menu state variable to 0
0DD3 754900    1215                   mov     MENU_STATE, #MENU_STATE_SOAK
0DD6 020DD9    1216                   ljmp    menu_FSM_done
0DD9           1217   
0DD9           1218           menu_FSM_done:
0DD9 22        1219                   ret
0DDA           1220   
0DDA           1221   main_program:
0DDA           1222           ; George
0DDA 75817F    1223           mov     sp, #0x7f
0DDD 120749    1224           lcall   INIT_ALL
0DE0 120087    1225           lcall   LCD_4BIT
0DE3 C292      1226           clr     PWM_OUT
0DE5           1227           ; lcall   configure_LCD_multiplexing
0DE5           1228   
0DE5           1229           ; Default display - 
0DE5           1230           ; Reflow oven controller 
0DE5           1231           ; (Start or Configure?)
0DE5           1232           PROGRAM_ENTRY:
0DE5 C0E0      1233            push acc
0DE7 7401      1233            mov a, #1
0DE9 14        1233            dec a
0DEA 1200C7    1233            lcall ?Set_Cursor_1 ; Select column and row
0DED D0E0      1233            pop acc
0DEF C083      1234            push dph
0DF1 C082      1234            push dpl
0DF3 C0E0      1234            push acc
0DF5 9003DF    1234            mov dptr, #LCD_defaultTop
0DF8 1200BA    1234            lcall ?Send_Constant_String
0DFB D0E0      1234            pop acc
0DFD D082      1234            pop dpl
0DFF D083      1234            pop dph
0E01 C0E0      1235            push acc
0E03 7401      1235            mov a, #1
0E05 14        1235            dec a
0E06 1200C5    1235            lcall ?Set_Cursor_2 ; Select column and row
0E09 D0E0      1235            pop acc
0E0B C083      1236            push dph
0E0D C082      1236            push dpl
0E0F C0E0      1236            push acc
0E11 9003F0    1236            mov dptr, #LCD_defaultBot
0E14 1200BA    1236            lcall ?Send_Constant_String
0E17 D0E0      1236            pop acc
0E19 D082      1236            pop dpl
0E1B D083      1236            pop dph
0E1D           1237                   
0E1D 755500    1238                   mov  PWM, #0 ; sets PWM to zero
0E20 C292      1239                   clr  PWM_OUT
0E22           1240   
0E22           1241           checkStartButton: ; assumed negative logic - used a label for an easy ljmp in the future
0E22 D206      1242           setb PB_START_PIN
0E24 D207      1242           setb PB_CHANGE_MENU_PIN
0E26 D208      1242           setb PB_INC_TEMP_PIN
0E28 D209      1242           setb PB_INC_TIME_PIN
0E2A D20A      1242           setb PB_STOP_PIN
0E2C           1242           
0E2C D295      1242           setb SHARED_PIN
0E2E           1242           ; check if any push buttons are pressed
0E2E C293      1242           clr START_PIN             
0E30 C281      1242           clr CHANGE_MENU_PIN       
0E32 C282      1242           clr INC_TEMP_PIN          
0E34 C283      1242           clr INC_TIME_PIN          
0E36 C280      1242           clr STOP_PIN
0E38           1242   
0E38           1242           ; debounce
0E38 209564    1242           jb SHARED_PIN, noStartButtonPress ; use helper label to jump to the end
0E3B C002      1242            push AR2
0E3D 7A32      1242            mov R2, #50
0E3F 120038    1242            lcall ?Wait_Milli_Seconds
0E42 D002      1242            pop AR2
0E44 209558    1242           jb SHARED_PIN, noStartButtonPress
0E47           1242   
0E47           1242           ; Set the LCD data pins to logic 1
0E47 D293      1242           setb START_PIN
0E49 D281      1242           setb CHANGE_MENU_PIN
0E4B D282      1242           setb INC_TEMP_PIN
0E4D D283      1242           setb INC_TIME_PIN
0E4F D280      1242           setb STOP_PIN
0E51           1242   
0E51           1242           ; check push buttons 1 by one
0E51 C293      1242           clr START_PIN
0E53 A295      1242           mov c, SHARED_PIN
0E55 9206      1242           mov PB_START_PIN, c
0E57 D293      1242           setb START_PIN
0E59           1242   
0E59 C281      1242           clr CHANGE_MENU_PIN
0E5B A295      1242           mov c, SHARED_PIN
0E5D 9207      1242           mov PB_CHANGE_MENU_PIN, c
0E5F D281      1242           setb CHANGE_MENU_PIN
0E61           1242   
0E61 C282      1242           clr INC_TEMP_PIN
0E63 A295      1242           mov c, SHARED_PIN
0E65 9208      1242           mov PB_INC_TEMP_PIN, c
0E67 D282      1242           setb INC_TEMP_PIN
0E69           1242   
0E69 C283      1242           clr INC_TIME_PIN
0E6B A295      1242           mov c, SHARED_PIN
0E6D 9209      1242           mov PB_INC_TIME_PIN, c
0E6F D283      1242           setb INC_TIME_PIN
0E71           1242   
0E71 C280      1242           clr STOP_PIN
0E73 A295      1242           mov c, SHARED_PIN
0E75 920A      1242           mov PB_STOP_PIN, c
0E77 D280      1242           setb STOP_PIN
0E79           1242   
0E79 200623    1242           jb PB_START_PIN, noStartButtonPress ; check that the variable flag is not 1, otherwise jmp
0E7C           1242   
0E7C D204      1243                   setb    ENABLE_SEC_INC_FLAG 
0E7E D205      1244                   setb    TIME_TO_BEEP_FLAG
0E80           1245                   ; Send 0 to the serial
0E80 753C00    1246                   mov BCD+0, #0x0
0E83 753D00    1247                   mov BCD+1, #0x0
0E86 753E00    1248                   mov BCD+2, #0x0
0E89 753F00    1249                   mov BCD+3, #0x0
0E8C 754000    1250                   mov BCD+4, #0x0
0E8F 120701    1251                   lcall send_temp_to_serial
0E92 740D      1252                   mov a,  #'\r' ; Return character
0E94 1204EE    1253                   lcall   putchar
0E97 740A      1254                   mov a,  #'\n' ; New-line character
0E99 1204EE    1255                   lcall   putchar
0E9C           1256   
0E9C 020F0C    1257                   ljmp    enter_oven_fsm ; successful button press, enter oven FSM   
0E9F           1258   
0E9F           1259           noStartButtonPress:
0E9F D293      1260                   setb    START_PIN
0EA1           1261                   ; if the 'IN_MENU' flag is set, always enter into the menu FSM, this is so that the menu FSM can always be entered
0EA1           1262                   ; creates an infinite loop that will always display menu once entered - broken if START button pressed
0EA1 300106    1263                   jnb     IN_MENU_FLAG, checkMenuButtonPress
0EA4 120B9F    1264                   lcall   MENU_FSM 
0EA7 020E22    1265                   ljmp    checkStartButton
0EAA           1266   
0EAA           1267           checkMenuButtonPress:
0EAA           1268                   ; check for enter menu button press (reusing increment menu pin)
0EAA D206      1269           setb PB_START_PIN
0EAC D207      1269           setb PB_CHANGE_MENU_PIN
0EAE D208      1269           setb PB_INC_TEMP_PIN
0EB0 D209      1269           setb PB_INC_TIME_PIN
0EB2 D20A      1269           setb PB_STOP_PIN
0EB4           1269           
0EB4 D295      1269           setb SHARED_PIN
0EB6           1269           ; check if any push buttons are pressed
0EB6 C293      1269           clr START_PIN             
0EB8 C281      1269           clr CHANGE_MENU_PIN       
0EBA C282      1269           clr INC_TEMP_PIN          
0EBC C283      1269           clr INC_TIME_PIN          
0EBE C280      1269           clr STOP_PIN
0EC0           1269   
0EC0           1269           ; debounce
0EC0 209544    1269           jb SHARED_PIN, noMenuButtonPress ; use helper label to jump to the end
0EC3 C002      1269            push AR2
0EC5 7A32      1269            mov R2, #50
0EC7 120038    1269            lcall ?Wait_Milli_Seconds
0ECA D002      1269            pop AR2
0ECC 209538    1269           jb SHARED_PIN, noMenuButtonPress
0ECF           1269   
0ECF           1269           ; Set the LCD data pins to logic 1
0ECF D293      1269           setb START_PIN
0ED1 D281      1269           setb CHANGE_MENU_PIN
0ED3 D282      1269           setb INC_TEMP_PIN
0ED5 D283      1269           setb INC_TIME_PIN
0ED7 D280      1269           setb STOP_PIN
0ED9           1269   
0ED9           1269           ; check push buttons 1 by one
0ED9 C293      1269           clr START_PIN
0EDB A295      1269           mov c, SHARED_PIN
0EDD 9206      1269           mov PB_START_PIN, c
0EDF D293      1269           setb START_PIN
0EE1           1269   
0EE1 C281      1269           clr CHANGE_MENU_PIN
0EE3 A295      1269           mov c, SHARED_PIN
0EE5 9207      1269           mov PB_CHANGE_MENU_PIN, c
0EE7 D281      1269           setb CHANGE_MENU_PIN
0EE9           1269   
0EE9 C282      1269           clr INC_TEMP_PIN
0EEB A295      1269           mov c, SHARED_PIN
0EED 9208      1269           mov PB_INC_TEMP_PIN, c
0EEF D282      1269           setb INC_TEMP_PIN
0EF1           1269   
0EF1 C283      1269           clr INC_TIME_PIN
0EF3 A295      1269           mov c, SHARED_PIN
0EF5 9209      1269           mov PB_INC_TIME_PIN, c
0EF7 D283      1269           setb INC_TIME_PIN
0EF9           1269   
0EF9 C280      1269           clr STOP_PIN
0EFB A295      1269           mov c, SHARED_PIN
0EFD 920A      1269           mov PB_STOP_PIN, c
0EFF D280      1269           setb STOP_PIN
0F01           1269   
0F01 200703    1269           jb PB_CHANGE_MENU_PIN, noMenuButtonPress ; check that the variable flag is not 1, otherwise jmp
0F04           1269   
0F04           1269   
0F04           1270                   ; setb IN_MENU_FLAG; successful button press, enter menu FSM loop ; - THIS LINE CAUSES THE BUG
0F04 020F51    1271                   ljmp    setMenuFlag
0F07           1272                   
0F07           1273           noMenuButtonPress:
0F07 D281      1274                   setb CHANGE_MENU_PIN
0F09 020E22    1275                   ljmp    checkStartButton ; this line does not execute if ljmp setMenuFlag is there?!?!?
0F0C           1276   
0F0C           1277           enter_oven_fsm:
0F0C C201      1278                   clr     IN_MENU_FLAG ; No longer in menu
0F0E D202      1279                   setb    IN_OVEN_FLAG
0F10 C0E0      1280            push acc
0F12 7401      1280            mov a, #1
0F14 14        1280            dec a
0F15 1200C7    1280            lcall ?Set_Cursor_1 ; Select column and row
0F18 D0E0      1280            pop acc
0F1A C083      1281            push dph
0F1C C082      1281            push dpl
0F1E C0E0      1281            push acc
0F20 90043F    1281            mov dptr, #LCD_clearLine
0F23 1200BA    1281            lcall ?Send_Constant_String
0F26 D0E0      1281            pop acc
0F28 D082      1281            pop dpl
0F2A D083      1281            pop dph
0F2C C0E0      1282            push acc
0F2E 7401      1282            mov a, #1
0F30 14        1282            dec a
0F31 1200C5    1282            lcall ?Set_Cursor_2 ; Select column and row
0F34 D0E0      1282            pop acc
0F36 C083      1283            push dph
0F38 C082      1283            push dpl
0F3A C0E0      1283            push acc
0F3C 90043F    1283            mov dptr, #LCD_clearLine
0F3F 1200BA    1283            lcall ?Send_Constant_String
0F42 D0E0      1283            pop acc
0F44 D082      1283            pop dpl
0F46 D083      1283            pop dph
0F48           1284   
0F48 12054F    1285                   lcall   Timer2_Init  ; breaks things
0F4B 12080A    1286                   lcall   OVEN_FSM     ; `OVEN_FSM` exit by calling STOP_PROCESS which then loops back to the entry point
0F4E 1207DA    1287                   lcall   STOP_PROCESS ; added for safety
0F51           1288                   
0F51           1289           setMenuFlag: 
0F51 D201      1290                   setb    IN_MENU_FLAG
0F53 020E22    1291                   ljmp    checkStartButton
0F56           1292   
0F56           1293           program_end:
0F56 020DDA    1294                   ljmp    main_program
0F59           1295   END
