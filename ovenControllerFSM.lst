0000              1   
0000              2   ; Main file. FSM implementing the following sequence:
0000              3   ;       State 0: Power = 0% (default state)
0000              4   ;               if start = NO, self loop; if start = YES, next state
0000              5   ;       State 1: Power = 100%; Sec = 0
0000              6   ;               if temp <= 150, self loop; temp > 150, next
0000              7   ;       State 2: Power = 20%
0000              8   ;               if sec <= 60s, self loop; sec>60s, next
0000              9   ;       State 3: Power = 100%; Sec = 0
0000             10   ;               if temp <= 220, self loop; temp>220, next
0000             11   ;       State 4: Power = 20%
0000             12   ;               if sec <= 45s, self loop; sec >45, next
0000             13   ;       State 5: Power = 0%
0000             14   ;               if temp >=60, self loop; temp <60, next
0000             15   ;       return to state 0
0000             16   
0000             17   
0000             18   ; MACROS ;
                 19   CLJNE mac
                 20       cjne %0, %1, $+3+2 ; Jump if no equal 2 bytes ahead since sjmp is a 2 byte instruction  
                 21       sjmp $+2+3 ; Jump 3 bytes after this instruction as ljmp takes 3 bytes to encode
                 22       ljmp %2 ; ljmp can access any part of the code space
                 23   endmac
0000             24   
0000             25   ; Push button macro - It does not work :( - check if it works now, moved location
                 26   check_Push_Button MAC
                 27       jb %0, %1
                 28       Wait_Milli_Seconds(#50)
                 29       jb %0, %1
                 30       jnb %0, $
                 31   ENDMAC
0000             32   
0000             33   
                 35   $LIST
0000             37   
0000             38   ;  N76E003 pinout:
0000             39   ;                               -------
0000             40   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             41   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             42   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             43   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             44   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             45   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             46   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             47   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             48   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             49   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             50   ;                               -------
0000             51   
0000             52   
0000             53   
0000             54   ;-------------------------------------------------------------------------------------------------------------------------------------
0000             55   
0000             56   ;                                                              STYLE GUIDE
0000             57   
0000             58   ; End flag names with _FLAG
0000             59   ; Use all upper case for constants (anything defined in equ or pin definitions), as it makes it easier to read quickly
0000             60   ; Before any jump or logic block comment purpose and try to comment throughout - code should be self explanatory, comment "why" it was implemented this way
0000             61   ; Before any block of code also comment who wrote it 
0000             62   ; Aim for variable names with 8-20 characters
0000             63   
0000             64   ; --------------------------------------------------------------------------------------------------------------------------
0000             65   
0000             66   
0000             67   ; Timer constants
0000             68   CLK                   EQU 16600000 ; Microcontroller system frequency in Hz
0000             69   BAUD                  EQU 115200   ; Baud rate of UART in bps 
0000             70   TIMER1_RELOAD         EQU (0x100-(CLK/(16*BAUD))) ; Serial ISR
0000             71   TIMER2_RELOAD         EQU (65536-(CLK/1000))    ; 1ms Delay ISR
0000             72   TIMER0_RELOAD         EQU (0x10000-(CLK/4096))    ; Sound ISR For 2kHz square wave
0000             73   
0000             74   ; Pin definitions + Hardware Wiring 
0000             75   START_PIN             EQU P1.5 ; change to correct pin later
0000             76   CHANGE_MENU_PIN       EQU P1.6 ; change to correct pin later 
0000             77   INC_TEMP_PIN          EQU P3.0 ; change to correct pin later
0000             78   INC_TIME_PIN          EQU P0.4 ; change to correct pin later
0000             79   STOP_PIN              EQU P1.0 ; change to correct pin later
0000             80   PWM_OUT               EQU P1.1 ; change to correct pin later
0000             81   
0000             82   ; Menu states
0000             83   MENU_STATE_SOAK       EQU 0
0000             84   MENU_STATE_REFLOW     EQU 1
0000             85   MENU_STATE_TEST       EQU 2
0000             86   
0000             87   ; oven states
0000             88   OVEN_STATE_PREHEAT    EQU 0
0000             89   OVEN_STATE_SOAK       EQU 1
0000             90   OVEN_STATE_RAMP2PEAK  EQU 2
0000             91   OVEN_STATE_REFLOW     EQU 3
0000             92   OVEN_STATE_COOLING    EQU 4
0000             93   OVEN_STATE_FINISHED   EQU 5
0000             94   
0000             95   ; things to keep track of
0000             96   COOLED_TEMP           EQU 50 ; once cooled to this temperature, the reflow is now "finished"
0000             97   COOLED_TEMP_LOAD_MATH EQU COOLED_TEMP*10000 ; use to load up the math
0000             98   FINISHED_SECONDS      EQU 10
0000             99   MAX_TIME              EQU 90
0000            100   MIN_TIME              EQU 15
0000            101   MAX_TEMP              EQU 250
0000            102   MIN_TEMP              EQU 100
0000            103   
0000            104   ; define vectors
0000            105   ORG 0x0000 ; Reset vector
0000 020915     106           ljmp main_program
0003            107   ORG 0x0003 ; External interrupt 0 vector
0003 32         108           reti
000B            109   ORG 0x000B ; Timer/Counter 0 overflow interrupt vector
000B 020496     110            ljmp Timer0_ISR
0013            111   ORG 0x0013 ; External interrupt 1 vector
0013 32         112            reti
001B            113   ORG 0x001B ; Timer/Counter 1 overflow interrupt vector 
001B 32         114            reti
0023            115   ORG 0x0023 ; Serial port receive/transmit interrupt vector 
0023 32         116            reti
002B            117   ORG 0x002B ; Timer/Counter 2 overflow interrupt vector
002B 020497     118            ljmp Timer2_ISR
002E            119   
002E            120   
002E            121   ; register definitions previously needed by 'math32.inc' - currently commented out for future changes
0030            122   DSEG at 0x30
0030            123   x               : ds 4
0034            124   y               : ds 4
0038            125   bcd             : ds 5
003D            126   bcdf            : ds 5
0042            127   VLED_ADC        : ds 2
0044            128   
0044            129   OVEN_STATE      : ds 1 ; stores oven FSM state
0045            130   MENU_STATE      : ds 1 ; stores menu FSM state
0046            131   temp_soak       : ds 1 
0047            132   time_soak       : ds 1
0048            133   temp_refl       : ds 1
0049            134   time_refl       : ds 1
004A            135   ; pwm             : ds 1 ; controls output power to SSR
004A            136   ; pwm_counter     : ds 1 
004A            137   
004A            138   Count1ms        : ds 2 ; determines the number of 1ms increments that have passed 
004C            139   Count1ms_PWM    : ds 1
004D            140   seconds_elapsed  : ds 1
004E            141   exit_seconds    : ds 1 ; if we dont reach 50 c before 60 S terminate
004F            142   
004F            143   pwm_counter: ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0050            144   pwm: ds 1 ; pwm percentage
0051            145   
0051            146   
002E            147   CSEG ;starts the absolute segment from that address
002E            148   ; These 'EQU' must match the hardware wiring
002E            149   LCD_RS          EQU P1.3
002E            150   ;LCD_RW         EQU PX.X ; Not used in this code, connect the pin to GND
002E            151   LCD_E           EQU P1.4
002E            152   LCD_D4          EQU P0.0
002E            153   LCD_D5          EQU P0.1
002E            154   LCD_D6          EQU P0.2
002E            155   LCD_D7          EQU P0.3
002E            156   
                158   	$LIST
00E2            160   
00E2            161   ; Flags that are used to control events 
0000            162   BSEG 
0000            163   mf              : dbit 1
0001            164   IN_MENU_FLAG    : dbit 1
0002            165   IN_OVEN_FLAG    : dbit 1
0003            166   REFLOW_FLAG     : dbit 1
0004            167   
                547   $LIST
                169   $LIST
0352            171   
0352            172   ; Messages to display on LCD when in Menu FSM
0352 5265666C   173   LCD_defaultTop  : db 'Reflow Oven: ', 0
     6F77204F
     76656E3A
     2000
0360 53746172   174   LCD_defaultBot  : db 'Start/Configure?', 0
     742F436F
     6E666967
     7572653F
     00
0371 536F616B   175   LCD_soakTime    : db 'Soak Time: ', 0
     2054696D
     653A2000
037D 536F616B   176   LCD_soakTemp    : db 'Soak Temp: ', 0
     2054656D
     703A2000
0389 5265666C   177   LCD_reflowTime  : db 'Refl Time: ', 0
     2054696D
     653A2000
0395 5265666C   178   LCD_reflowTemp  : db 'Refl Temp: ', 0
     2054656D
     703A2000
03A1 54455354   179   LCD_TEST        : db 'TEST MESSAGE ', 0
     204D4553
     53414745
     2000
03AF 20202020   180   LCD_clearLine   : db '                ', 0 ; put at end to clear line
     20202020
     20202020
     20202020
     00
03C0            181   
03C0 50726568   182   preheatMessage  : db 'Preheat', 0
     65617400
03C8 536F616B   183   soakMessage     : db 'Soak', 0
     00
03CD 5065616B   184   ramp2peakMessage: db 'Peak to Soak', 0
     20746F20
     536F616B
     00
03DA 5265666C   185   reflowMessage   : db 'Reflow', 0
     6F7700
03E1 436F6F6C   186   coolingMessage  : db 'Cooling', 0
     696E6700
03E9 46696E69   187   FinishedMessage : db 'Finished!', 0
     73686564
     2100
03F3 454D4552   188   stopMessage     : db 'EMERGENCY STOP', 0
     47454E43
     59205354
     4F5000
0402            189   
0402            190   ; Messages to display on LCD when in Oven Controller FSM
0402            191   
0402            192   ; Send a character using the serial port
0402            193   putchar:
0402 3099FD     194           jnb     TI, putchar
0405 C299       195           clr     TI
0407 F599       196           mov     SBUF, a
0409 22         197           ret
040A            198   
040A            199   ; Send a constant-zero-terminated string using the serial port
040A            200   SendString:
040A E4         201           clr     A
040B 93         202           movc    A, @A+DPTR
040C 6006       203           jz      SendStringDone
040E 120402     204           lcall   putchar
0411 A3         205           inc     DPTR
0412 80F6       206           sjmp    SendString
0414            207   SendStringDone:
0414 22         208           ret
0415            209   
0415            210   ; Eight bit number to display passed in ’a’.
0415            211   SendToLCD:
0415 75F064     212           mov     b, #100
0418 84         213           div     ab
0419 4430       214           orl     a, #0x30 ; Convert hundreds to ASCII
041B 12007D     215           lcall   ?WriteData ; Send to LCD
041E E5F0       216           mov     a, b ; Remainder is in register b
0420 75F00A     217           mov     b, #10
0423 84         218           div     ab
0424 4430       219           orl     a, #0x30 ; Convert tens to ASCII
0426 12007D     220           lcall   ?WriteData; Send to LCD
0429 E5F0       221           mov     a, b
042B 4430       222           orl     a, #0x30 ; Convert units to ASCII
042D 12007D     223           lcall   ?WriteData; Send to LCD
0430 22         224           ret
0431            225   
0431            226   ; Eight bit number to display passed in ’a’.
0431            227   SendToSerialPort:
0431 75F064     228           mov     b, #100
0434 84         229           div     ab
0435 4430       230           orl     a, #0x30 ; Convert hundreds to ASCII
0437 120402     231           lcall   putchar ; Send to PuTTY/Python/Matlab
043A E5F0       232           mov     a, b ; Remainder is in register b
043C 75F00A     233           mov     b, #10
043F 84         234           div     ab
0440 4430       235           orl     a, #0x30 ; Convert tens to ASCII
0442 120402     236           lcall   putchar ; Send to PuTTY/Python/Matlab
0445 E5F0       237           mov     a, b
0447 4430       238           orl     a, #0x30 ; Convert units to ASCII
0449 120402     239           lcall   putchar ; Send to PuTTY/Python/Matlab
044C 22         240           ret
044D            241   
044D            242   
044D            243   ;---------------------------------;
044D            244   ; Send a BCD number to PuTTY      ;
044D            245   ;---------------------------------;
                246   Send_BCD mac
                247   	push    ar0
                248   	mov     r0, %0
                249   	lcall   ?Send_BCD
                250   	pop     ar0
                251   	endmac
044D            252            ?Send_BCD:
044D C0E0       253                   push    acc
044F            254                   ; Write most significant digit
044F E8         255                   mov     a, r0
0450 C4         256                   swap    a
0451 540F       257                   anl     a, #0fh
0453 4430       258                   orl     a, #30h
0455 120402     259                   lcall   putchar
0458            260                   ; write least significant digit
0458 E8         261                   mov     a, r0
0459 540F       262                   anl     a, #0fh
045B 4430       263                   orl     a, #30h
045D 120402     264                   lcall   putchar
0460 D0E0       265                   pop     acc
0462 22         266   ret
0463            267   
0463            268   ;---------------------------------;
0463            269   ; Routine to initialize the ISR   ;
0463            270   ; for timer 0                     ;
0463            271   ;---------------------------------;
0463            272   Timer0_Init:
0463 438E08     273            orl     CKCON, #0b00001000 ; Input for timer 0 is sysclk/1 ; performs bit masking on CKON - Clock Control ; T0M = 1, timer 0 uses the system clock directly
0466 E589       274            mov     a, TMOD
0468 54F0       275            anl     a, #0xf0 ; 11110000 Clear the bits for timer 0
046A 4401       276            orl     a, #0x01 ; 00000001 Configure timer 0 as 16-timer (M1M0 = 01 -> Mode 1: 16-bit Timer/Counter)
046C F589       277            mov     TMOD, a
046E 758CF0     278            mov     TH0, #high(TIMER0_RELOAD) ; 8051 works with 8 bits so the oepration T0 = TIMER0_RELOAD  (16 bits) is done by setting high byte then low byte (8x2)
0471 758A2C     279            mov     TL0, #low (TIMER0_RELOAD)
0474            280            ; Enable the timer and interrupts
0474 D2A9       281           setb    ET0  ; Enable timer 0 interrupt
0476 D28C       282           setb    TR0  ; Start timer 0
0478 22         283            ret
0479            284   
0479            285   ;---------------------------------;
0479            286   ; Routine to initialize the ISR   ;
0479            287   ; for timer 2                     ;
0479            288   ;---------------------------------;
0479            289   Timer2_Init:
0479 75C800     290            mov     T2CON, #0 ; Stop timer/counter.  Autoreload mode.
047C 75CDBF     291            mov     TH2, #high(TIMER2_RELOAD)
047F 75CC28     292            mov     TL2, #low(TIMER2_RELOAD)
0482            293            ; Set the reload value
0482 43C980     294            orl     T2MOD, #0x80 ; Enable timer 2 autoreload
0485 75CBBF     295            mov     RCMP2H, #high(TIMER2_RELOAD)
0488 75CA28     296            mov     RCMP2L, #low(TIMER2_RELOAD)
048B            297            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
048B E4         298            clr     a
048C F54A       299            mov     Count1ms+0, a
048E F54B       300            mov     Count1ms+1, a
0490            301            ; Enable the timer and interrupts
0490 439B80     302            orl     EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0493 D2CA       303           setb    TR2  ; Enable timer 2
0495 22         304            ret
0496            305   
0496            306   Timer0_ISR:
0496 32         307           reti
0497            308   
0497            309   ;---------------------------------;
0497            310   ; ISR for timer 2                 ;
0497            311   ;---------------------------------;
0497            312   Timer2_ISR:
0497 C2CF       313           clr     TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0499 B284       314           cpl     P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
049B            315   
049B            316           ; The two registers used in the ISR must be saved in the stack
049B C0E0       317           push    acc
049D C0D0       318           push    psw
049F            319   
049F 054C       320           inc     Count1ms_PWM
04A1            321   
04A1            322           ; Increment the 16-bit one mili second counter
04A1 054A       323           inc     Count1ms+0    ; Increment the low 8-bits first
04A3 E54A       324           mov     a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
04A5 7002       325           jnz     Inc_done
04A7 054B       326           inc     Count1ms+1
04A9            327    
04A9            328           
04A9            329           Inc_done:
04A9 E54C       330           mov    a, Count1ms_PWM
04AB B40A15     331           cjne   a, #10, check1secondsPassed 
04AE            332   
04AE            333                   ;RK working on PWM
04AE 054F       334                   inc     pwm_counter
04B0 C3         335                   clr     c
04B1 E550       336                   mov     a, pwm
04B3 954F       337                   subb    a, pwm_counter ; If pwm_counter <= pwm then c=1
04B5 B3         338                   cpl     c
04B6 9291       339                   mov     PWM_OUT, c 
04B8 E54F       340                   mov     a, pwm_counter
04BA B46433     341                   cjne    a, #100, Timer2_ISR_done
04BD 754F00     342                   mov     pwm_counter, #0
04C0            343   
04C0 E4         344                   clr     a
04C1 F54C       345                   mov     Count1ms_PWM, a
04C3            346           
04C3            347           
04C3            348           check1secondsPassed:
04C3            349           ; Check if one second has passed
04C3 E54A       350            mov     a, Count1ms+0
04C5 B4E828     351            cjne    a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
04C8 E54B       352            mov     a, Count1ms+1
04CA B40323     353            cjne    a, #high(1000), Timer2_ISR_done         
04CD            354   
04CD            355           ; ---  1s has passed ----
04CD            356     
04CD            357           ; debugging
04CD E54F       358           mov a,  pwm_counter
04CF 120431     359           lcall   SendToSerialPort
04D2 740D       360           mov a,  #'\r' ; Return character
04D4 120402     361           lcall   putchar
04D7 740A       362           mov a,  #'\n' ; New-line character
04D9 120402     363           lcall   putchar
04DC            364   
04DC            365           ; mov a, OVEN_STATE
04DC            366           ; add A, #1
04DC            367           ; mov OVEN_STATE, a
04DC 300306     368           jnb     REFLOW_FLAG,  not_in_reflow ;Checks if we are in reflow state
04DF E54E       369           mov     a, exit_seconds
04E1 2401       370           add     a, #1
04E3 F54E       371           mov     exit_seconds, a
04E5            372           
04E5            373    not_in_reflow:
04E5 E54D       374           mov     a, seconds_elapsed
04E7 2401       375           add     A, #1
04E9 F54D       376           mov     seconds_elapsed, a
04EB            377   
04EB            378           ; reset seconds ms counter
04EB E4         379           clr     a
04EC F54A       380           mov     Count1ms+0, a
04EE F54B       381           mov     Count1ms+1, a
04F0            382   
04F0            383           Timer2_ISR_done:
04F0 D0D0       384           pop     psw
04F2 D0E0       385            pop     acc
04F4 32         386           reti
04F5            387   
04F5            388   Initilize_All:
04F5            389           ; Configure pins to be bi-directional
04F5 75AC00     390           mov      P3M1,#0x00
04F8 75AD00     391            mov     P3M2,#0x00
04FB 75B300     392            mov     P1M1,#0x00
04FE 75B400     393            mov     P1M2,#0x00
0501 75B100     394            mov     P0M1,#0x00
0504 75B200     395            mov     P0M2,#0x00
0507            396   
0507 D296       397           setb    CHANGE_MENU_PIN
0509 D295       398           setb    START_PIN
050B            399   
050B D2AF       400           setb    EA   ; Enable Global interrupts
050D            401   
050D            402   
050D            403           ; Since the reset button bounces, we need to wait a bit before
050D            404           ; sending messages, otherwise we risk displaying gibberish!
050D C002       405            push AR2
050F 7A32       405            mov R2, #50
0511 120038     405            lcall ?Wait_Milli_Seconds
0514 D002       405            pop AR2
0516            406   
0516            407           ; Now we can proceed with the configuration of the serial port
0516 438E10     408           orl      CKCON, #0x10 ; CLK is the input for timer 1
0519 438780     409           orl      PCON, #0x80  ; Bit SMOD=1, double baud rate
051C 759852     410           mov      SCON, #0x52
051F 53C4DF     411           anl      T3CON, #0b11011111
0522 53890F     412           anl      TMOD, #0x0F ; Clear the configuration bits for timer 1
0525 438920     413           orl      TMOD, #0x20 ; Timer 1 Mode 2
0528 758DF7     414           mov      TH1, #TIMER1_RELOAD
052B D28E       415           setb    TR1
052D            416   
052D            417           ; ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ SUS  ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓   
052D            418           ; works on its own from lab3, might interfere with other stuff though       ; NOTE TIMER ZERO HAS NOT YET BEEN TESTED       
052D            419           ; Using timer 0 for delay functions.  Initialize here:
052D C28C       420            clr     TR0         ; Stop timer 0
052F 438E08     421            orl     CKCON,#0x08 ; CLK is the input for timer 0
0532 5389F0     422            anl     TMOD,#0xF0  ; Clear the configuration bits for timer 0
0535 438901     423            orl     TMOD,#0x01  ; Timer 0 in Mode 1: 16-bit timer
0538            424           ; ^ ^ ^ ^ ^ ^ ^ ^^ ^ ^ ^ ^ ^^ ^ ^ ^ ^^ ^ ^ ^            
0538            425            
0538            426            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
0538 43B382     427            orl     P1M1, #0b10000010
053B 53B47D     428            anl     P1M2, #0b01111101
053E            429            
053E            430            ; Initialize and start the ADC:
053E 53E8F0     431            anl     ADCCON0, #0xF0
0541 43E807     432            orl     ADCCON0, #0x07 ; Select channel 7
0544            433            
0544            434           ; AINDIDS select if some pins are analog inputs or digital I/O:
0544 75F600     435            mov     AINDIDS, #0x00 ; Disable all analog inputs
0547 43F681     436            orl     AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
054A 43E101     437            orl     ADCCON1, #0x01 ; Enable ADC
054D            438   
054D            439           ; Menu Configuration
054D C201       440           clr     IN_MENU_FLAG
054F C202       441           clr     IN_OVEN_FLAG
0551 7400       442           mov     a, #0
0553 F545       443           mov     MENU_STATE, a ; set menu state to 0 
0555            444   
0555            445           ; mov     temp_soak, #0x250
0555 754696     446           mov     temp_soak, #150
0558 75470F     447           mov     time_soak, #MIN_TIME
055B 7548DC     448           mov     temp_refl, #220
055E 75490F     449           mov     time_refl, #MIN_TIME
0561            450           
0561            451           ; Oven configuration
0561 754400     452           mov     OVEN_STATE, #OVEN_STATE_PREHEAT
0564 754D00     453           mov     seconds_elapsed, #0
0567 754C00     454           mov     Count1ms_PWM, #0
056A 754E00     455           mov     exit_seconds, #0
056D C203       456           clr     REFLOW_FLAG
056F            457           
056F 22         458           ret
0570            459           
0570            460   ;Button nested logic -> we should be constantly checking in the main loop for a stop (i.e the stop should be instantaneous)
0570            461           ;->Buttons should allow for adjustment of soak temp, soak time, reflow temp, reflow time (Ui should be designed to make all these visible and clear)
0570            462           ;->Start button should either be used only for start or used for start/pause (different from a stop
0570            463           ;Try to use button logic given in lab 2 to stay consistent
0570            464           ; Menu Logic (will keep UI clean)
0570            465           ; Button to switch states - Changes a state variable (4 states -> 2 bits) (or two flags)
0570            466           ; Two buttons to go up or down a value
0570            467           ; One button to stop <---- safety feature make this button only STOP
0570            468           
0570            469           ; ;pseudo code lol
0570            470           ; jb [button], [branch]
0570            471           ; Wait_Milli_Seconds(#50)
0570            472           ; jb [button], [branch]
0570            473           ; jnb [button], $
0570            474           ; ljmp [display??]
0570            475   
0570            476   ; ; 3 values : current time elapsed in seconds, 
0570            477   ; FSM_transition_check MAC
0570            478   ;         jb %0, %2
0570            479   ;         Wait_Milli_Seconds(#50) ; de-bounce
0570            480   ;         jb %0, %2
0570            481   ;         jnb %0, $
0570            482   ;         ; successful press registered
0570            483   ;         inc %1 ; increment param #1
0570            484   ; ENDMAC
0570            485   
0570            486   
0570            487   STOP_PROCESS:
0570            488           ; Turn everything off
0570 C203       489           clr     REFLOW_FLAG
0572 C202       490           clr     IN_OVEN_FLAG
0574 754400     491           MOV     OVEN_STATE, #OVEN_STATE_PREHEAT
0577 754D00     492           MOV     seconds_elapsed, #0
057A 755000     493           MOV     pwm, #0
057D 02091E     494           ljmp    PROGRAM_ENTRY
0580            495   
0580            496   ; SSR_FSM: 
0580            497   
0580            498   
0580            499   ; Precondition: Has temperature stored in x
0580            500   OVEN_FSM:
0580 209012     501       jb STOP_PIN, enterOvenStateCheck
0583 C002       501            push AR2
0585 7A32       501            mov R2, #50
0587 120038     501            lcall ?Wait_Milli_Seconds
058A D002       501            pop AR2
058C 209006     501       jb STOP_PIN, enterOvenStateCheck
058F 3090FD     501       jnb STOP_PIN, $
0592 120570     502           lcall   STOP_PROCESS
0595            503   
0595            504           ; check oven state if stop button is not pressed
0595            505           enterOvenStateCheck:
0595 E544       506                   mov     a, OVEN_STATE
0597            507              
0597            508           ovenFSM_preheat:
0597            509                   ; long jump for relative offset
0597 B40002     510                   cjne    a, #OVEN_STATE_PREHEAT, ovenFSM_soak_jmp
059A 8003       511                   sjmp    oven_state_preheat_tasks
059C            512                   ovenFSM_soak_jmp:
059C 02061F     513                           ljmp    ovenFSM_soak
059F            514                   oven_state_preheat_tasks:
059F 75501E     515                           mov     pwm, #30
05A2 C0E0       516            push acc
05A4 7401       516            mov a, #1
05A6 14         516            dec a
05A7 1200C7     516            lcall ?Set_Cursor_1 ; Select column and row
05AA D0E0       516            pop acc
05AC C083       517            push dph
05AE C082       517            push dpl
05B0 C0E0       517            push acc
05B2 9003C0     517            mov dptr, #preheatMessage
05B5 1200BA     517            lcall ?Send_Constant_String
05B8 D0E0       517            pop acc
05BA D082       517            pop dpl
05BC D083       517            pop dph
05BE C083       518            push dph
05C0 C082       518            push dpl
05C2 C0E0       518            push acc
05C4 9003AF     518            mov dptr, #LCD_clearLine
05C7 1200BA     518            lcall ?Send_Constant_String
05CA D0E0       518            pop acc
05CC D082       518            pop dpl
05CE D083       518            pop dph
05D0 C0E0       519            push acc
05D2 7401       519            mov a, #1
05D4 14         519            dec a
05D5 1200C5     519            lcall ?Set_Cursor_2 ; Select column and row
05D8 D0E0       519            pop acc
05DA E54D       520                           mov     a, seconds_elapsed
05DC 120415     521                           lcall   SendToLCD
05DF            522   
05DF 75303C     523            mov x+0, #low (60 % 0x10000) 
05E2 753100     523            mov x+1, #high(60 % 0x10000) 
05E5 753200     523            mov x+2, #low (60 / 0x10000) 
05E8 753300     523            mov x+3, #high(60 / 0x10000)  ; Imagine this is the measured temp 
05EB            524   
05EB            525                   ;Emergency exit process; tested, works
05EB D203       526                   setb    REFLOW_FLAG
05ED E54E       527                   mov     a, exit_seconds
05EF B40A15     528                   cjne    a, #10, Skip_Emergency_exit
05F2 753432     529            mov y+0, #low (50 % 0x10000) 
05F5 753500     529            mov y+1, #high(50 % 0x10000) 
05F8 753600     529            mov y+2, #low (50 / 0x10000) 
05FB 753700     529            mov y+3, #high(50 / 0x10000) 
05FE 120248     530                   lcall   x_gteq_y
0601 200003     531                   jb      mf, Skip_Emergency_exit
0604            532                   
0604            533                   ; mov a, temp
0604            534                   ; lcall ;send temperature value to serial
0604 020570     535                   ljmp    STOP_PROCESS ; more then 60 seconds has elapse and we are below 50C ESCAPE
0607            536                   
0607            537           Skip_Emergency_exit:       
0607            538                   ; check temperature has reached configured value 
0607 753446     539            mov y+0, #low (temp_soak % 0x10000) 
060A 753500     539            mov y+1, #high(temp_soak % 0x10000) 
060D 753600     539            mov y+2, #low (temp_soak / 0x10000) 
0610 753700     539            mov y+3, #high(temp_soak / 0x10000)  ; this line is sus ; temp_soak is a BCD value
0613 120248     540                   lcall   x_gteq_y
0616 300003     541                   jnb     mf, noChange_preheatState
0619 754401     542                   mov     OVEN_STATE, #OVEN_STATE_SOAK
061C            543                   noChange_preheatState:
061C 0207B7     544                           ljmp    oven_FSM_done
061F            545   
061F            546           ovenFSM_soak:
061F B4014B     547                   cjne    a, #OVEN_STATE_SOAK, ovenFSM_Ramp2Peak
0622 755014     548                   mov     pwm, #20
0625 C0E0       549            push acc
0627 7401       549            mov a, #1
0629 14         549            dec a
062A 1200C7     549            lcall ?Set_Cursor_1 ; Select column and row
062D D0E0       549            pop acc
062F C083       550            push dph
0631 C082       550            push dpl
0633 C0E0       550            push acc
0635 9003C8     550            mov dptr, #soakMessage
0638 1200BA     550            lcall ?Send_Constant_String
063B D0E0       550            pop acc
063D D082       550            pop dpl
063F D083       550            pop dph
0641 C083       551            push dph
0643 C082       551            push dpl
0645 C0E0       551            push acc
0647 9003AF     551            mov dptr, #LCD_clearLine
064A 1200BA     551            lcall ?Send_Constant_String
064D D0E0       551            pop acc
064F D082       551            pop dpl
0651 D083       551            pop dph
0653 C0E0       552            push acc
0655 7401       552            mov a, #1
0657 14         552            dec a
0658 1200C5     552            lcall ?Set_Cursor_2 ; Select column and row
065B D0E0       552            pop acc
065D E54D       553                   mov     a, seconds_elapsed
065F 120415     554                   lcall   SendToLCD
0662            555   
0662            556                   ; check if seconds elapsed > soak time
0662 E54D       557                   mov     a, seconds_elapsed
0664 B54703     558                   cjne    a, time_soak, noChange_soakState
0667 754402     559                   mov     OVEN_STATE, #OVEN_STATE_RAMP2PEAK
066A            560                   ; mov seconds_elapsed, #0 ; reset
066A            561                   noChange_soakState:
066A 0207B7     562                           ljmp    oven_FSM_done
066D            563   
066D            564           ovenFSM_Ramp2Peak:
066D B4025B     565                   cjne    a, #OVEN_STATE_RAMP2PEAK, ovenFSM_reflow
0670 755064     566                   mov     pwm, #100
0673 C0E0       567            push acc
0675 7401       567            mov a, #1
0677 14         567            dec a
0678 1200C7     567            lcall ?Set_Cursor_1 ; Select column and row
067B D0E0       567            pop acc
067D C083       568            push dph
067F C082       568            push dpl
0681 C0E0       568            push acc
0683 9003CD     568            mov dptr, #ramp2peakMessage
0686 1200BA     568            lcall ?Send_Constant_String
0689 D0E0       568            pop acc
068B D082       568            pop dpl
068D D083       568            pop dph
068F C083       569            push dph
0691 C082       569            push dpl
0693 C0E0       569            push acc
0695 9003AF     569            mov dptr, #LCD_clearLine
0698 1200BA     569            lcall ?Send_Constant_String
069B D0E0       569            pop acc
069D D082       569            pop dpl
069F D083       569            pop dph
06A1 C0E0       570            push acc
06A3 7401       570            mov a, #1
06A5 14         570            dec a
06A6 1200C5     570            lcall ?Set_Cursor_2 ; Select column and row
06A9 D0E0       570            pop acc
06AB E54D       571                   mov     a, seconds_elapsed
06AD 120415     572                   lcall   SendToLCD
06B0 754D00     573                   mov     seconds_elapsed, #0 ; reset
06B3            574   
06B3            575                   ; check that temperature for reflow is reached, then exit                
06B3 753448     576            mov y+0, #low (temp_refl % 0x10000) 
06B6 753500     576            mov y+1, #high(temp_refl % 0x10000) 
06B9 753600     576            mov y+2, #low (temp_refl / 0x10000) 
06BC 753700     576            mov y+3, #high(temp_refl / 0x10000)  ; this line is sus ; temp_soak is a BCD value
06BF 120252     577                   lcall   x_lteq_y
06C2 300003     578                   jnb     mf, noChange_ramp2peak
06C5 754403     579                   mov     OVEN_STATE, #OVEN_STATE_REFLOW
06C8            580                   noChange_ramp2peak:
06C8 0207B7     581                           ljmp    oven_FSM_done
06CB            582                   
06CB            583           ovenFSM_reflow:
06CB B40344     584                   cjne    a, #OVEN_STATE_REFLOW, ovenFSM_cooling
06CE 755064     585                   mov     pwm, #100
06D1 C0E0       586            push acc
06D3 7401       586            mov a, #1
06D5 14         586            dec a
06D6 1200C7     586            lcall ?Set_Cursor_1 ; Select column and row
06D9 D0E0       586            pop acc
06DB C083       587            push dph
06DD C082       587            push dpl
06DF C0E0       587            push acc
06E1 9003DA     587            mov dptr, #reflowMessage
06E4 1200BA     587            lcall ?Send_Constant_String
06E7 D0E0       587            pop acc
06E9 D082       587            pop dpl
06EB D083       587            pop dph
06ED C083       588            push dph
06EF C082       588            push dpl
06F1 C0E0       588            push acc
06F3 9003AF     588            mov dptr, #LCD_clearLine
06F6 1200BA     588            lcall ?Send_Constant_String
06F9 D0E0       588            pop acc
06FB D082       588            pop dpl
06FD D083       588            pop dph
06FF E54D       589                   mov     a, seconds_elapsed
0701 120415     590                   lcall   SendToLCD
0704            591   
0704            592                   ; check if seconds elapsed > reflow time
0704 E54D       593                   mov     a, seconds_elapsed
0706 B54906     594                   cjne    a, time_refl, noChange_reflowState
0709 754404     595                   mov     OVEN_STATE, #OVEN_STATE_COOLING
070C 754D00     596                   mov     seconds_elapsed, #0 ; reset
070F            597                   noChange_reflowState:
070F 0207B7     598                           ljmp    oven_FSM_done
0712            599   
0712            600           ovenFSM_cooling:
0712 B4045B     601                   cjne    a, #OVEN_STATE_COOLING, ovenFSM_finished
0715 755000     602                   mov     pwm, #0
0718 C0E0       603            push acc
071A 7401       603            mov a, #1
071C 14         603            dec a
071D 1200C7     603            lcall ?Set_Cursor_1 ; Select column and row
0720 D0E0       603            pop acc
0722 C083       604            push dph
0724 C082       604            push dpl
0726 C0E0       604            push acc
0728 9003E1     604            mov dptr, #coolingMessage
072B 1200BA     604            lcall ?Send_Constant_String
072E D0E0       604            pop acc
0730 D082       604            pop dpl
0732 D083       604            pop dph
0734 C083       605            push dph
0736 C082       605            push dpl
0738 C0E0       605            push acc
073A 9003AF     605            mov dptr, #LCD_clearLine
073D 1200BA     605            lcall ?Send_Constant_String
0740 D0E0       605            pop acc
0742 D082       605            pop dpl
0744 D083       605            pop dph
0746 C0E0       606            push acc
0748 7401       606            mov a, #1
074A 14         606            dec a
074B 1200C5     606            lcall ?Set_Cursor_2 ; Select column and row
074E D0E0       606            pop acc
0750 E54D       607                   mov     a, seconds_elapsed
0752 120415     608                   lcall   SendToLCD
0755 754D00     609                   mov     seconds_elapsed, #0 ; reset
0758            610   
0758            611                   ; once temperature is low (compare with temp constant)
0758 753420     612            mov y+0, #low (COOLED_TEMP_LOAD_MATH % 0x10000) 
075B 7535A1     612            mov y+1, #high(COOLED_TEMP_LOAD_MATH % 0x10000) 
075E 753607     612            mov y+2, #low (COOLED_TEMP_LOAD_MATH / 0x10000) 
0761 753700     612            mov y+3, #high(COOLED_TEMP_LOAD_MATH / 0x10000)  ; this line is sus ; temp_soak is a BCD value
0764 120252     613                   lcall   x_lteq_y
0767 300003     614                   jnb     mf, noChange_cooling
076A 754405     615                   mov     OVEN_STATE, #OVEN_STATE_FINISHED
076D            616                   noChange_cooling:
076D 0207B7     617                           ljmp    oven_FSM_done
0770            618           
0770            619           ovenFSM_finished:
0770 B4053E     620                   cjne    a, #OVEN_STATE_FINISHED, ovenFSM_exit
0773 C0E0       621            push acc
0775 7401       621            mov a, #1
0777 14         621            dec a
0778 1200C7     621            lcall ?Set_Cursor_1 ; Select column and row
077B D0E0       621            pop acc
077D C083       622            push dph
077F C082       622            push dpl
0781 C0E0       622            push acc
0783 9003E9     622            mov dptr, #FinishedMessage
0786 1200BA     622            lcall ?Send_Constant_String
0789 D0E0       622            pop acc
078B D082       622            pop dpl
078D D083       622            pop dph
078F C083       623            push dph
0791 C082       623            push dpl
0793 C0E0       623            push acc
0795 9003AF     623            mov dptr, #LCD_clearLine
0798 1200BA     623            lcall ?Send_Constant_String
079B D0E0       623            pop acc
079D D082       623            pop dpl
079F D083       623            pop dph
07A1 E54D       624                   mov     a, seconds_elapsed
07A3 120415     625                   lcall   SendToLCD
07A6            626   
07A6            627                   ; go back to Start Screen after a certain number of seconds
07A6 E54D       628                   mov     a, seconds_elapsed
07A8 B40A03     629                   cjne    a, #FINISHED_SECONDS, noChange_finishedState
07AB 02091E     630                   ljmp    PROGRAM_ENTRY
07AE            631                   noChange_finishedState:
07AE 0207B7     632                           ljmp    oven_FSM_done
07B1            633   
07B1            634           ovenFSM_exit:
07B1 754400     635                   mov     OVEN_STATE, #OVEN_STATE_PREHEAT
07B4            636                   ; ljmp oven_FSM_done
07B4 120570     637                   lcall   STOP_PROCESS ; Exit oven FSM, turn power off, return to program entry
07B7            638                   
07B7            639           oven_FSM_done:
07B7 020580     640                   ljmp    OVEN_FSM ; return to start of oven FSM ; this is a blocking FSM
07BA            641           
07BA 22         642           ret ; technically unncessary
07BB            643   
07BB            644   MENU_FSM:        
07BB E545       645           mov     a, MENU_STATE 
07BD 209612     646       jb CHANGE_MENU_PIN, checkTimeInc
07C0 C002       646            push AR2
07C2 7A32       646            mov R2, #50
07C4 120038     646            lcall ?Wait_Milli_Seconds
07C7 D002       646            pop AR2
07C9 209606     646       jb CHANGE_MENU_PIN, checkTimeInc
07CC 3096FD     646       jnb CHANGE_MENU_PIN, $ ; increments menu state
07CF 04         647           inc     a
07D0 F545       648           mov     MENU_STATE, a 
07D2            649   
07D2            650           ; increment is checked with a seperate cascade that's outside the FSM
07D2            651           ; I wanted to keep FSM state outputs seperate from push button checks - George
07D2            652           checkTimeInc:
07D2 20842E     653       jb INC_TIME_PIN, checkTempInc
07D5 C002       653            push AR2
07D7 7A32       653            mov R2, #50
07D9 120038     653            lcall ?Wait_Milli_Seconds
07DC D002       653            pop AR2
07DE            653   
07DE 208422     653       jb INC_TIME_PIN, checkTempInc
07E1 3084FD     653       jnb INC_TIME_PIN, $
07E4 B4000F     654                   cjne a, #MENU_STATE_SOAK, incTimeReflow
07E7 E547       655                           mov     a, time_soak 
07E9 2405       656                           add     A, #5        
07EB F547       657                           mov     time_soak, a 
07ED            658   
07ED            659                           ; check if time_soak will need to reset - assumes multiples of 5
07ED            660                           ; +5 to constants so they display on LCD b/f reseting
07ED B45F13     661                           cjne a, #(MAX_TIME+5), checkTempInc 
07F0 740F       662                           mov a, #MIN_TIME
07F2 F547       663                           mov time_soak, a
07F4            664   
07F4 800D       665                           sjmp checkTempInc       
07F6            666                   incTimeReflow:
07F6 E549       667                           mov     a, time_refl
07F8 2405       668                           add     A, #5
07FA F549       669                           mov     time_refl, a
07FC            670   
07FC B45F04     671                           cjne a, #(MAX_TIME+5), checkTempInc
07FF 740F       672                           mov a, #MIN_TIME
0801 F549       673                           mov time_refl, a
0803            674   
0803            675   
0803            676            checkTempInc:
0803 20B02E     677       jb INC_TEMP_PIN, enterMenuStateCheck
0806 C002       677            push AR2
0808 7A32       677            mov R2, #50
080A 120038     677            lcall ?Wait_Milli_Seconds
080D D002       677            pop AR2
080F 20B022     677       jb INC_TEMP_PIN, enterMenuStateCheck
0812 30B0FD     677       jnb INC_TEMP_PIN, $
0815 B4000F     678                   cjne a, #MENU_STATE_SOAK, incTempReflow
0818 E546       679                           mov     a, temp_soak 
081A 2405       680                           add     A, #5        
081C F546       681                           mov     temp_soak, a 
081E            682   
081E B4FF13     683                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
0821 7464       684                           mov a, #MIN_TEMP
0823 F546       685                           mov temp_soak, a
0825            686   
0825 800D       687                           sjmp enterMenuStateCheck       
0827            688                   incTempReflow:
0827 E548       689                           mov     a, temp_refl
0829 2405       690                           add     A, #5
082B F548       691                           mov     temp_refl, a
082D            692   
082D B4FF04     693                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
0830 7464       694                           mov a, #MIN_TEMP
0832 F548       695                           mov temp_refl, a
0834            696   
0834            697           ; ---------------- FSM State Check ---------------- ;  
0834            698           enterMenuStateCheck:
0834 E545       699                   mov     a, MENU_STATE
0836            700   
0836            701           menuFSM_configSoak:
0836 B40069     702                   cjne    a, #MENU_STATE_SOAK, menuFSM_configReflow
0839            703                   ; display Soak Menu Options
0839 C0E0       704            push acc
083B 7401       704            mov a, #1
083D 14         704            dec a
083E 1200C7     704            lcall ?Set_Cursor_1 ; Select column and row
0841 D0E0       704            pop acc
0843 C083       705            push dph
0845 C082       705            push dpl
0847 C0E0       705            push acc
0849 90037D     705            mov dptr, #LCD_soakTemp
084C 1200BA     705            lcall ?Send_Constant_String
084F D0E0       705            pop acc
0851 D082       705            pop dpl
0853 D083       705            pop dph
0855 E546       706                   mov     a, temp_soak
0857 120415     707                   lcall   SendToLCD
085A C083       708            push dph
085C C082       708            push dpl
085E C0E0       708            push acc
0860 9003AF     708            mov dptr, #LCD_clearLine
0863 1200BA     708            lcall ?Send_Constant_String
0866 D0E0       708            pop acc
0868 D082       708            pop dpl
086A D083       708            pop dph
086C C0E0       709            push acc
086E 7401       709            mov a, #1
0870 14         709            dec a
0871 1200C5     709            lcall ?Set_Cursor_2 ; Select column and row
0874 D0E0       709            pop acc
0876 C083       710            push dph
0878 C082       710            push dpl
087A C0E0       710            push acc
087C 900371     710            mov dptr, #LCD_soakTime
087F 1200BA     710            lcall ?Send_Constant_String
0882 D0E0       710            pop acc
0884 D082       710            pop dpl
0886 D083       710            pop dph
0888 E547       711                   mov     a, time_soak
088A 120415     712                   lcall   SendToLCD
088D C083       713            push dph
088F C082       713            push dpl
0891 C0E0       713            push acc
0893 9003AF     713            mov dptr, #LCD_clearLine
0896 1200BA     713            lcall ?Send_Constant_String
0899 D0E0       713            pop acc
089B D082       713            pop dpl
089D D083       713            pop dph
089F 020914     714                   ljmp    menu_FSM_done
08A2            715   
08A2            716           menuFSM_configReflow:
08A2 B40169     717                   cjne    a, #MENU_STATE_REFLOW, reset_menu_state
08A5            718                   ; display Reflow Menu Options
08A5 C0E0       719            push acc
08A7 7401       719            mov a, #1
08A9 14         719            dec a
08AA 1200C7     719            lcall ?Set_Cursor_1 ; Select column and row
08AD D0E0       719            pop acc
08AF C083       720            push dph
08B1 C082       720            push dpl
08B3 C0E0       720            push acc
08B5 900395     720            mov dptr, #LCD_reflowTemp
08B8 1200BA     720            lcall ?Send_Constant_String
08BB D0E0       720            pop acc
08BD D082       720            pop dpl
08BF D083       720            pop dph
08C1 E548       721                   mov     a, temp_refl
08C3 120415     722                   lcall   SendToLCD
08C6 C083       723            push dph
08C8 C082       723            push dpl
08CA C0E0       723            push acc
08CC 9003AF     723            mov dptr, #LCD_clearLine
08CF 1200BA     723            lcall ?Send_Constant_String
08D2 D0E0       723            pop acc
08D4 D082       723            pop dpl
08D6 D083       723            pop dph
08D8 C0E0       724            push acc
08DA 7401       724            mov a, #1
08DC 14         724            dec a
08DD 1200C5     724            lcall ?Set_Cursor_2 ; Select column and row
08E0 D0E0       724            pop acc
08E2 C083       725            push dph
08E4 C082       725            push dpl
08E6 C0E0       725            push acc
08E8 900389     725            mov dptr, #LCD_reflowTime
08EB 1200BA     725            lcall ?Send_Constant_String
08EE D0E0       725            pop acc
08F0 D082       725            pop dpl
08F2 D083       725            pop dph
08F4 E549       726                   mov     a, time_refl
08F6 120415     727                   lcall   SendToLCD
08F9 C083       728            push dph
08FB C082       728            push dpl
08FD C0E0       728            push acc
08FF 9003AF     728            mov dptr, #LCD_clearLine
0902 1200BA     728            lcall ?Send_Constant_String
0905 D0E0       728            pop acc
0907 D082       728            pop dpl
0909 D083       728            pop dph
090B 020914     729                   ljmp    menu_FSM_done
090E            730   
090E            731           reset_menu_state: ; sets menu state variable to 0
090E 754500     732                   mov     MENU_STATE, #MENU_STATE_SOAK
0911 020914     733                   ljmp    menu_FSM_done
0914            734   
0914            735           menu_FSM_done:
0914 22         736                   ret
0915            737   
0915            738   main_program:
0915            739           ; George
0915 75817F     740           mov     sp, #0x7f
0918 1204F5     741           lcall   Initilize_All
091B 120087     742           lcall   LCD_4BIT
091E            743   
091E            744           ; Default display - 
091E            745           ; Reflow oven controller 
091E            746           ; (Start or Configure?)
091E            747           PROGRAM_ENTRY:
091E C0E0       748            push acc
0920 7401       748            mov a, #1
0922 14         748            dec a
0923 1200C7     748            lcall ?Set_Cursor_1 ; Select column and row
0926 D0E0       748            pop acc
0928 C083       749            push dph
092A C082       749            push dpl
092C C0E0       749            push acc
092E 900352     749            mov dptr, #LCD_defaultTop
0931 1200BA     749            lcall ?Send_Constant_String
0934 D0E0       749            pop acc
0936 D082       749            pop dpl
0938 D083       749            pop dph
093A C0E0       750            push acc
093C 7401       750            mov a, #1
093E 14         750            dec a
093F 1200C5     750            lcall ?Set_Cursor_2 ; Select column and row
0942 D0E0       750            pop acc
0944 C083       751            push dph
0946 C082       751            push dpl
0948 C0E0       751            push acc
094A 900360     751            mov dptr, #LCD_defaultBot
094D 1200BA     751            lcall ?Send_Constant_String
0950 D0E0       751            pop acc
0952 D082       751            pop dpl
0954 D083       751            pop dph
0956            752   
0956            753           checkStartButton: ; assumed negative logic - used a label for an easy ljmp in the future
0956 209512     754       jb START_PIN, noStartButtonPress
0959 C002       754            push AR2
095B 7A32       754            mov R2, #50
095D 120038     754            lcall ?Wait_Milli_Seconds
0960 D002       754            pop AR2
0962 209506     754       jb START_PIN, noStartButtonPress
0965 3095FD     754       jnb START_PIN, $
0968 02098C     755                   ljmp    enter_oven_fsm ; successful button press, enter oven FSM   
096B            756   
096B            757           noStartButtonPress:
096B            758                   ; if the 'IN_MENU' flag is set, always enter into the menu FSM, this is so that the menu FSM can always be entered
096B            759                   ; creates an infinite loop that will always display menu once entered - broken if START button pressed
096B 300106     760                   jnb     IN_MENU_FLAG, checkMenuButtonPress
096E 1207BB     761                   lcall   MENU_FSM 
0971 020956     762                   ljmp    checkStartButton
0974            763   
0974            764           checkMenuButtonPress:
0974            765                   ; check for enter menu button press (reusing increment menu pin)
0974 209612     766       jb CHANGE_MENU_PIN, noMenuButtonPress
0977 C002       766            push AR2
0979 7A32       766            mov R2, #50
097B 120038     766            lcall ?Wait_Milli_Seconds
097E D002       766            pop AR2
0980 209606     766       jb CHANGE_MENU_PIN, noMenuButtonPress
0983 3096FD     766       jnb CHANGE_MENU_PIN, $
0986            767                   ; setb IN_MENU_FLAG; successful button press, enter menu FSM loop ; - THIS LINE CAUSES THE BUG
0986 0209D1     768                   ljmp    setMenuFlag
0989            769                   
0989            770           noMenuButtonPress:
0989 020956     771                   ljmp    checkStartButton ; this line does not execute if ljmp setMenuFlag is there?!?!?
098C            772   
098C            773           enter_oven_fsm:
098C C201       774                   clr     IN_MENU_FLAG ; No longer in menu
098E D202       775                   setb    IN_OVEN_FLAG
0990 C0E0       776            push acc
0992 7401       776            mov a, #1
0994 14         776            dec a
0995 1200C7     776            lcall ?Set_Cursor_1 ; Select column and row
0998 D0E0       776            pop acc
099A C083       777            push dph
099C C082       777            push dpl
099E C0E0       777            push acc
09A0 9003AF     777            mov dptr, #LCD_clearLine
09A3 1200BA     777            lcall ?Send_Constant_String
09A6 D0E0       777            pop acc
09A8 D082       777            pop dpl
09AA D083       777            pop dph
09AC C0E0       778            push acc
09AE 7401       778            mov a, #1
09B0 14         778            dec a
09B1 1200C5     778            lcall ?Set_Cursor_2 ; Select column and row
09B4 D0E0       778            pop acc
09B6 C083       779            push dph
09B8 C082       779            push dpl
09BA C0E0       779            push acc
09BC 9003AF     779            mov dptr, #LCD_clearLine
09BF 1200BA     779            lcall ?Send_Constant_String
09C2 D0E0       779            pop acc
09C4 D082       779            pop dpl
09C6 D083       779            pop dph
09C8            780   
09C8 120479     781                   lcall   Timer2_Init  ; breaks things
09CB 120580     782                   lcall   OVEN_FSM     ; will call STOP_PROCESS which loops back to the entry point
09CE 120570     783                   lcall   STOP_PROCESS ; added for safety
09D1            784                   
09D1            785           setMenuFlag: 
09D1 D201       786                   setb    IN_MENU_FLAG
09D3 020956     787                   ljmp    checkStartButton
09D6            788   
09D6            789           program_end:
09D6 020915     790                   ljmp    main_program
09D9            791   EN
