0000              1   
0000              2   ; Main file. FSM implementing the following sequence:
0000              3   ;       State 0: Power = 0% (default state)
0000              4   ;               if start = NO, self loop; if start = YES, next state
0000              5   ;       State 1: Power = 100%; Sec = 0
0000              6   ;               if temp <= 150, self loop; temp > 150, next
0000              7   ;       State 2: Power = 20%
0000              8   ;               if sec <= 60s, self loop; sec>60s, next
0000              9   ;       State 3: Power = 100%; Sec = 0
0000             10   ;               if temp <= 220, self loop; temp>220, next
0000             11   ;       State 4: Power = 20%
0000             12   ;               if sec <= 45s, self loop; sec >45, next
0000             13   ;       State 5: Power = 0%
0000             14   ;               if temp >=60, self loop; temp <60, next
0000             15   ;       return to state 0
0000             16   
0000             17   
0000             18   ; MACROS ;
                 19   CLJNE mac
                 20       cjne %0, %1, $+3+2 ; Jump if no equal 2 bytes ahead since sjmp is a 2 byte instruction  
                 21       sjmp $+2+3 ; Jump 3 bytes after this instruction as ljmp takes 3 bytes to encode
                 22       ljmp %2 ; ljmp can access any part of the code space
                 23   endmac
0000             24   
0000             25   ; Push button macro - It does not work :( - check if it works now, moved location
                 26   check_Push_Button MAC
                 27       jb %0, %1
                 28       Wait_Milli_Seconds(#50)
                 29       jb %0, %1
                 30       jnb %0, $
                 31   ENDMAC
0000             32   
0000             33   
0000             34   
                 36   $LIST
0000             38   
0000             39   ;  N76E003 pinout:
0000             40   ;                               -------
0000             41   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             42   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             43   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             44   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             45   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             46   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             47   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             48   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             49   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             50   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             51   ;                               -------
0000             52   
0000             53   
0000             54   
0000             55   ;-------------------------------------------------------------------------------------------------------------------------------------
0000             56   
0000             57   ;                                                              STYLE GUIDE
0000             58   
0000             59   ; End flag names with _FLAG
0000             60   ; Use all upper case for constants (anything defined in equ or pin definitions), as it makes it easier to read quickly
0000             61   ; Before any jump or logic block comment purpose and try to comment throughout - code should be self explanatory, comment "why" it was implemented this way
0000             62   ; Before any block of code also comment who wrote it 
0000             63   ; Aim for variable names with 8-20 characters
0000             64   
0000             65   ; --------------------------------------------------------------------------------------------------------------------------
0000             66   
0000             67   
0000             68   ; Timer constants
0000             69   CLK                   EQU 16600000 ; Microcontroller system frequency in Hz
0000             70   BAUD                  EQU 115200   ; Baud rate of UART in bps 
0000             71   TIMER1_RELOAD         EQU (0x100-(CLK/(16*BAUD))) ; Serial ISR
0000             72   TIMER2_RELOAD         EQU (65536-(CLK/1000))    ; 1ms Delay ISR
0000             73   TIMER0_RELOAD         EQU (0x10000-(CLK/4096))    ; Sound ISR For 2kHz square wave
0000             74   
0000             75   ; Pin definitions + Hardware Wiring
0000             76   START_PIN             EQU P1.5 ; change to correct pin later
0000             77   STOP_PIN              EQU P1.0 ; change to correct pin later
0000             78   INC_TIME_PIN          EQU P3.0 ; change to correct pin later
0000             79   INC_TEMP_PIN          EQU P0.4 ; change to correct pin later
0000             80   CHANGE_MENU_PIN       EQU P1.6 ; change to correct pin later
0000             81   ; SSR_OUTPUT_PIN        EQU P3.0 ; change to correct pin later
0000             82   
0000             83   
0000             84   MENU_STATE_SOAK       EQU 0
0000             85   MENU_STATE_REFLOW     EQU 1
0000             86   MENU_STATE_TEST       EQU 2
0000             87   OVEN_STATE_PREHEAT    EQU 0
0000             88   OVEN_STATE_SOAK       EQU 1
0000             89   OVEN_STATE_REFLOW     EQU 2
0000             90   
0000             91   ; define vectors
0000             92   ORG 0x0000 ; Reset vector
0000 0207B0      93           ljmp main_program
0003             94   ORG 0x0003 ; External interrupt 0 vector
0003 32          95           reti
000B             96   ORG 0x000B ; Timer/Counter 0 overflow interrupt vector
000B 020430      97            ljmp Timer0_ISR
0013             98   ORG 0x0013 ; External interrupt 1 vector
0013 32          99            reti
001B            100   ORG 0x001B ; Timer/Counter 1 overflow interrupt vector 
001B 32         101            reti
0023            102   ORG 0x0023 ; Serial port receive/transmit interrupt vector 
0023 32         103            reti
002B            104   ORG 0x002B ; Timer/Counter 2 overflow interrupt vector
002B 020431     105            ljmp Timer2_ISR
002E            106   
002E            107   
002E            108   ; register definitions previously needed by 'math32.inc' - currently commented out for future changes
0030            109   DSEG at 0x30
0030            110   x               : ds 4
0034            111   y               : ds 4
0038            112   bcd             : ds 5
003D            113   bcdf            : ds 5
0042            114   VLED_ADC        : ds 2
0044            115   
0044            116   OVEN_STATE      : ds 1 ; stores oven FSM state
0045            117   MENU_STATE      : ds 1 ; stores menu FSM state
0046            118   temp_soak       : ds 2 
0048            119   ; temp_soak       : ds 2 
0048            120   time_soak       : ds 1
0049            121   temp_refl       : ds 2
004B            122   time_refl       : ds 1
004C            123   pwm             : ds 1 ; controls output power to SSR
004D            124   
004D            125   Count1ms        : ds 2 ; determines the number of 1ms increments that have passed 
004F            126   seconds_elapsed  : DS 1
0050            127   exit_seconds    : DS 1 ; if we dont reach 50 c before 60 S terminate
0051            128   
0051            129   
002E            130   CSEG ;starts the absolute segment from that address
002E            131   ; These 'EQU' must match the hardware wiring
002E            132   LCD_RS          EQU P1.3
002E            133   ;LCD_RW         EQU PX.X ; Not used in this code, connect the pin to GND
002E            134   LCD_E           EQU P1.4
002E            135   LCD_D4          EQU P0.0
002E            136   LCD_D5          EQU P0.1
002E            137   LCD_D6          EQU P0.2
002E            138   LCD_D7          EQU P0.3
002E            139   
                141   	$LIST
00E2            143   
00E2            144   ; Flags that are used to control events 
0000            145   BSEG 
0000            146   mf              : dbit 1
0001            147   IN_MENU_FLAG    : dbit 1
0002            148   IN_OVEN_FLAG    : dbit 1
0003            149   REFLOW_FLAG     : dbit 1
0004            150   
                547   $LIST
                152   $LIST
0352            154   
0352            155   ; Messages to display on LCD when in Menu FSM
0352 5265666C   156   LCD_defaultTop  : db 'Reflow Oven: ', 0
     6F77204F
     76656E3A
     2000
0360 53746172   157   LCD_defaultBot  : db 'Start/Configure?', 0
     742F436F
     6E666967
     7572653F
     00
0371 536F616B   158   LCD_soakTime    : db 'Soak Time: ', 0
     2054696D
     653A2000
037D 536F616B   159   LCD_soakTemp    : db 'Soak Temp: ', 0
     2054656D
     703A2000
0389 5265666C   160   LCD_reflowTime  : db 'Refl Time: ', 0
     2054696D
     653A2000
0395 5265666C   161   LCD_reflowTemp  : db 'Refl Temp: ', 0
     2054656D
     703A2000
03A1 54455354   162   LCD_TEST        : db 'TEST MESSAGE ', 0
     204D4553
     53414745
     2000
03AF 20202020   163   LCD_clearLine   : db '                ', 0 ; put at end to clear line
     20202020
     20202020
     20202020
     00
03C0            164   
03C0 50726568   165   preheatMessage  : db 'Preheat', 0
     65617400
03C8 536F616B   166   soakMessage     : db 'Soak', 0
     00
03CD 5265666C   167   reflowMessage   : db 'Reflow', 0
     6F7700
03D4            168   
03D4            169   ; Messages to display on LCD when in Oven Controller FSM
03D4            170   
03D4            171   
03D4            172   ; Send a character using the serial port
03D4            173   putchar:
03D4 3099FD     174       jnb TI, putchar
03D7 C299       175       clr TI
03D9 F599       176       mov SBUF, a
03DB 22         177       ret
03DC            178   
03DC            179   ; Send a constant-zero-terminated string using the serial port
03DC            180   SendString:
03DC E4         181       clr A
03DD 93         182       movc A, @A+DPTR
03DE 6006       183       jz SendStringDone
03E0 1203D4     184       lcall putchar
03E3 A3         185       inc DPTR
03E4 80F6       186       sjmp SendString
03E6            187   SendStringDone:
03E6 22         188       ret
03E7            189   
03E7            190   
03E7            191   ;---------------------------------;
03E7            192   ; Send a BCD number to PuTTY      ;
03E7            193   ;---------------------------------;
                194   Send_BCD mac
                195   	push ar0
                196   	mov r0, %0
                197   	lcall ?Send_BCD
                198   	pop ar0
                199   	endmac
03E7            200            ?Send_BCD:
03E7 C0E0       201            push acc
03E9            202            ; Write most significant digit
03E9 E8         203            mov a, r0
03EA C4         204            swap a
03EB 540F       205            anl a, #0fh
03ED 4430       206            orl a, #30h
03EF 1203D4     207            lcall putchar
03F2            208            ; write least significant digit
03F2 E8         209            mov a, r0
03F3 540F       210            anl a, #0fh
03F5 4430       211            orl a, #30h
03F7 1203D4     212            lcall putchar
03FA D0E0       213            pop acc
03FC 22         214   ret
03FD            215   
03FD            216   ;---------------------------------;
03FD            217   ; Routine to initialize the ISR   ;
03FD            218   ; for timer 0                     ;
03FD            219   ;---------------------------------;
03FD            220   Timer0_Init:
03FD 438E08     221            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1 ; performs bit masking on CKON - Clock Control ; T0M = 1, timer 0 uses the system clock directly
0400 E589       222            mov a, TMOD
0402 54F0       223            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
0404 4401       224            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer (M1M0 = 01 -> Mode 1: 16-bit Timer/Counter)
0406 F589       225            mov TMOD, a
0408 758CF0     226            mov TH0, #high(TIMER0_RELOAD) ; 8051 works with 8 bits so the oepration T0 = TIMER0_RELOAD  (16 bits) is done by setting high byte then low byte (8x2)
040B 758A2C     227            mov TL0, #low (TIMER0_RELOAD)
040E            228            ; Enable the timer and interrupts
040E D2A9       229       setb ET0  ; Enable timer 0 interrupt
0410 D28C       230       setb TR0  ; Start timer 0
0412 22         231            ret
0413            232   
0413            233   ;---------------------------------;
0413            234   ; Routine to initialize the ISR   ;
0413            235   ; for timer 2                     ;
0413            236   ;---------------------------------;
0413            237   Timer2_Init:
0413 75C800     238            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0416 75CDBF     239            mov TH2, #high(TIMER2_RELOAD)
0419 75CC28     240            mov TL2, #low(TIMER2_RELOAD)
041C            241            ; Set the reload value
041C 43C980     242            orl T2MOD, #0x80 ; Enable timer 2 autoreload
041F 75CBBF     243            mov RCMP2H, #high(TIMER2_RELOAD)
0422 75CA28     244            mov RCMP2L, #low(TIMER2_RELOAD)
0425            245            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0425 E4         246            clr a
0426 F54D       247            mov Count1ms+0, a
0428 F54E       248            mov Count1ms+1, a
042A            249            ; Enable the timer and interrupts
042A 439B80     250            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
042D D2CA       251           setb TR2  ; Enable timer 2
042F 22         252            ret
0430            253   
0430            254   Timer0_ISR:
0430 32         255   reti
0431            256   
0431            257   ;---------------------------------;
0431            258   ; ISR for timer 2                 ;
0431            259   ;---------------------------------;
0431            260   Timer2_ISR:
0431 C2CF       261           clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0433 B284       262           cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0435            263   
0435            264           ; The two registers used in the ISR must be saved in the stack
0435 C0E0       265           push acc
0437 C0D0       266           push psw
0439            267   
0439            268           
0439            269   
0439            270   
0439            271           ; Increment the 16-bit one mili second counter
0439 054D       272           inc Count1ms+0    ; Increment the low 8-bits first
043B E54D       273           mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
043D 7002       274           jnz Inc_done
043F 054E       275           inc Count1ms+1
0441            276   
0441            277           
0441            278           Inc_done:
0441            279           ; Check if one second has passed
0441 E54D       280            mov     a, Count1ms+0
0443 B4E843     281            cjne    a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0446 E54E       282            mov     a, Count1ms+1
0448 B4033E     283            cjne    a, #high(1000), Timer2_ISR_done         
044B            284   
044B            285           ; ---  1s has passed ----
044B            286           ; send serial data
044B            287   
044B            288           ; load_x(seconds_elapsed)
044B 854F30     289           mov x+0, seconds_elapsed
044E 753100     290           mov x+1, #0
0451 753200     291           mov x+2, #0
0454 753300     292           mov x+3, #0
0457            293           
0457            294           ;`    lcall hex2bcd
0457            295           ;Send_BCD (bcd+1)
0457 C000       296            push ar0
0459 A84F       296            mov r0, seconds_elapsed+0
045B 1203E7     296            lcall ?Send_BCD
045E D000       296            pop ar0
0460 C000       297            push ar0
0462 A84F       297            mov r0, seconds_elapsed
0464 1203E7     297            lcall ?Send_BCD
0467 D000       297            pop ar0
0469 740D       298           mov a, #'\r' ; Return character
046B 1203D4     299           lcall putchar
046E 740A       300           mov a, #'\n' ; New-line character
0470 1203D4     301           lcall putchar
0473            302   
0473            303           ; mov a, OVEN_STATE
0473            304           ; add A, #1
0473            305           ; mov OVEN_STATE, a
0473 300307     306           jnb REFLOW_FLAG,  not_in_reflow ;Checks if we are in reflow state
0476 E550       307           mov a, exit_seconds
0478 2401       308           add a, #1
047A D4         309           da A
047B F550       310           mov exit_seconds, a
047D            311           
047D            312    not_in_reflow:
047D E54F       313           mov a, seconds_elapsed
047F 2401       314           add A, #1
0481 D4         315           da A
0482 F54F       316           mov seconds_elapsed, a
0484            317   
0484            318           ; reset seconds ms counter
0484 E4         319           clr a
0485 F54D       320           mov Count1ms+0, a
0487 F54E       321           mov Count1ms+1, a
0489            322           
0489            323           Timer2_ISR_done:
0489 D0D0       324           pop psw
048B D0E0       325            pop acc
048D 32         326           reti
048E            327   
048E            328   Initilize_All:
048E            329           ; Configure pins to be bi-directional
048E 75AC00     330           mov      P3M1,#0x00
0491 75AD00     331            mov     P3M2,#0x00
0494 75B300     332            mov     P1M1,#0x00
0497 75B400     333            mov     P1M2,#0x00
049A 75B100     334            mov     P0M1,#0x00
049D 75B200     335            mov     P0M2,#0x00
04A0            336   
04A0 D296       337           setb    CHANGE_MENU_PIN
04A2 D295       338           setb    START_PIN
04A4            339   
04A4 D2AF       340           setb    EA   ; Enable Global interrupts
04A6            341   
04A6            342   
04A6            343           ; Since the reset button bounces, we need to wait a bit before
04A6            344           ; sending messages, otherwise we risk displaying gibberish!
04A6 C002       345            push AR2
04A8 7A32       345            mov R2, #50
04AA 120038     345            lcall ?Wait_Milli_Seconds
04AD D002       345            pop AR2
04AF            346   
04AF            347           ; Now we can proceed with the configuration of the serial port
04AF 438E10     348           orl      CKCON, #0x10 ; CLK is the input for timer 1
04B2 438780     349           orl      PCON, #0x80  ; Bit SMOD=1, double baud rate
04B5 759852     350           mov      SCON, #0x52
04B8 53C4DF     351           anl      T3CON, #0b11011111
04BB 53890F     352           anl      TMOD, #0x0F ; Clear the configuration bits for timer 1
04BE 438920     353           orl      TMOD, #0x20 ; Timer 1 Mode 2
04C1 758DF7     354           mov      TH1, #TIMER1_RELOAD
04C4 D28E       355           setb    TR1
04C6            356   
04C6            357           ; ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ SUS  ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓   
04C6            358           ; works on its own from lab3, might interfere with other stuff though             
04C6            359           ; Using timer 0 for delay functions.  Initialize here:
04C6 C28C       360            clr     TR0         ; Stop timer 0
04C8 438E08     361            orl     CKCON,#0x08 ; CLK is the input for timer 0
04CB 5389F0     362            anl     TMOD,#0xF0  ; Clear the configuration bits for timer 0
04CE 438901     363            orl     TMOD,#0x01  ; Timer 0 in Mode 1: 16-bit timer
04D1            364           ; ^ ^ ^ ^ ^ ^ ^ ^^ ^ ^ ^ ^ ^^ ^ ^ ^ ^^ ^ ^ ^            
04D1            365            
04D1            366            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
04D1 43B382     367            orl     P1M1, #0b10000010
04D4 53B47D     368            anl     P1M2, #0b01111101
04D7            369            
04D7            370            ; Initialize and start the ADC:
04D7 53E8F0     371            anl     ADCCON0, #0xF0
04DA 43E807     372            orl     ADCCON0, #0x07 ; Select channel 7
04DD            373            
04DD            374           ; AINDIDS select if some pins are analog inputs or digital I/O:
04DD 75F600     375            mov     AINDIDS, #0x00 ; Disable all analog inputs
04E0 43F681     376            orl     AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
04E3 43E101     377            orl     ADCCON1, #0x01 ; Enable ADC
04E6            378   
04E6            379           ; Menu Configuration
04E6 C201       380           clr     IN_MENU_FLAG
04E8 C202       381           clr     IN_OVEN_FLAG
04EA 7405       382           mov     a, #5
04EC F545       383           mov     MENU_STATE, a ; set menu state to 0 
04EE            384   
04EE            385           ; mov     temp_soak, #0x250
04EE 754650     386           mov     temp_soak+0, #low (0x250)
04F1 754702     387           mov     temp_soak+1, #high(0x250)
04F4 754805     388           mov     time_soak, #0x5
04F7 754990     389           mov     temp_refl+0, #low (0x90)
04FA 754A00     390           mov     temp_refl+1, #high(0x90)
04FD 754B01     391           mov     time_refl, #0x1
0500            392           
0500            393           ; Oven configuration
0500 754400     394           mov OVEN_STATE, #OVEN_STATE_PREHEAT
0503 754F00     395           mov seconds_elapsed, #0
0506 755000     396           mov exit_seconds, #0
0509 C203       397           clr REFLOW_FLAG
050B            398           
050B 22         399           ret
050C            400           
050C            401   ;Button nested logic -> we should be constantly checking in the main loop for a stop (i.e the stop should be instantaneous)
050C            402           ;->Buttons should allow for adjustment of soak temp, soak time, reflow temp, reflow time (Ui should be designed to make all these visible and clear)
050C            403           ;->Start button should either be used only for start or used for start/pause (different from a stop
050C            404           ;Try to use button logic given in lab 2 to stay consistent
050C            405           ; Menu Logic (will keep UI clean)
050C            406           ; Button to switch states - Changes a state variable (4 states -> 2 bits) (or two flags)
050C            407           ; Two buttons to go up or down a value
050C            408           ; One button to stop <---- safety feature make this button only STOP
050C            409           
050C            410           ; ;pseudo code lol
050C            411           ; jb [button], [branch]
050C            412           ; Wait_Milli_Seconds(#50)
050C            413           ; jb [button], [branch]
050C            414           ; jnb [button], $
050C            415           ; ljmp [display??]
050C            416   
050C            417   ; ; 3 values : current time elapsed in seconds, 
050C            418   ; FSM_transition_check MAC
050C            419   ;         jb %0, %2
050C            420   ;         Wait_Milli_Seconds(#50) ; de-bounce
050C            421   ;         jb %0, %2
050C            422   ;         jnb %0, $
050C            423   ;         ; successful press registered
050C            424   ;         inc %1 ; increment param #1
050C            425   ; ENDMAC
050C            426   
050C            427   ;hannah y~
050C            428   ; Send a character using the serial port
050C            429   ;putchar:
050C            430       ;jnb TI, putchar
050C            431       ;clr TI
050C            432       ;mov SBUF, a
050C            433       ;ret
050C            434   
050C            435   ; Send a constant-zero-terminated string using the serial port
050C            436   ;SendString:
050C            437       ;clr A
050C            438       ;movc A, @A+DPTR
050C            439       ;jz SendStringDone
050C            440       ;lcall putchar
050C            441       ;inc DPTR
050C            442       ;sjmp SendString
050C            443   ;SendStringDone:
050C            444       ;ret
050C            445   
050C            446   ; Macro for sending temperature value to the serial go-between (PuTTY)
050C            447   ;Send_BCD mac
050C            448            ;push ar0
050C            449            ;mov r0, %0
050C            450            ;lcall ?Send_BCD
050C            451            ;pop ar0
050C            452   ;endmac
050C            453   
050C            454   ; ;?Send_BCD:
050C            455   ;        push acc
050C            456   ;        ;Write most significant digit
050C            457   ;        mov a, r0
050C            458   ;        swap a
050C            459   ;        anl a, #0fh
050C            460   ;        orl a, #30h
050C            461   ;        lcall putchar
050C            462   ;        ;write least significant digit
050C            463   ;        mov a, r0
050C            464   ;        anl a, #0fh
050C            465   ;        orl a, #30h
050C            466   ;        lcall putchar
050C            467   ;        pop acc
050C            468   ;        ret
050C            469   ; Send_to_Putty:
050C            470   ;        Send_BCD(bcd+3)
050C            471   ;        Send_BCD(bcd+2) 
050C            472   ;        mov DPTR, #Dec_pt
050C            473   ;        lcall SendString
050C            474   ;        Send_BCD(bcd+1) 
050C            475   ;        ;Send_BCD(bcd+0) 
050C            476   ;        mov DPTR, #Enter
050C            477   ;        lcall SendString
050C            478   ;        ; ret
050C            479   
050C            480   STOP_PROCESS:
050C            481           ; Turn everything off
050C C203       482           clr REFLOW_FLAG
050E            483           ; MOV
050E 0207B9     484           ljmp PROGRAM_ENTRY
0511            485   
0511            486   ; Precondition: Has temperature stored in x
0511            487   OVEN_FSM:
0511 209012     488       jb STOP_PIN, enterOvenStateCheck
0514 C002       488            push AR2
0516 7A32       488            mov R2, #50
0518 120038     488            lcall ?Wait_Milli_Seconds
051B D002       488            pop AR2
051D 209006     488       jb STOP_PIN, enterOvenStateCheck
0520 3090FD     488       jnb STOP_PIN, $
0523 12050C     489           lcall STOP_PROCESS
0526            490   
0526            491           ; check oven state if stop button is not pressed
0526            492           enterOvenStateCheck:
0526 E544       493                   mov a, OVEN_STATE
0528            494                   
0528 753058     495                   mov x+0, #low(600)   ; current temperature              
052B 753102     496                   mov x+1, #high(600)  ; current temperature              
052E            497                   
052E            498           ovenFSM_preheat:
052E B40063     499                   cjne a, #OVEN_STATE_PREHEAT, ovenFSM_soak
0531 C0E0       500            push acc
0533 7401       500            mov a, #1
0535 14         500            dec a
0536 1200C7     500            lcall ?Set_Cursor_1 ; Select column and row
0539 D0E0       500            pop acc
053B C083       501            push dph
053D C082       501            push dpl
053F C0E0       501            push acc
0541 9003C0     501            mov dptr, #preheatMessage
0544 1200BA     501            lcall ?Send_Constant_String
0547 D0E0       501            pop acc
0549 D082       501            pop dpl
054B D083       501            pop dph
054D C083       502            push dph
054F C082       502            push dpl
0551 C0E0       502            push acc
0553 9003AF     502            mov dptr, #LCD_clearLine
0556 1200BA     502            lcall ?Send_Constant_String
0559 D0E0       502            pop acc
055B D082       502            pop dpl
055D D083       502            pop dph
055F C0E0       503            push acc
0561 7401       503            mov a, #1
0563 14         503            dec a
0564 1200C5     503            lcall ?Set_Cursor_2 ; Select column and row
0567 D0E0       503            pop acc
0569            504                   ; Set_Cursor(2, 1)
0569 C000       505            push ar0
056B A84F       505            mov r0, seconds_elapsed
056D 1200CC     505            lcall ?Display_BCD
0570 D000       505            pop ar0
0572            506   
0572            507                   ;ROHAN
0572            508                   ;Emergency exit process
0572 D203       509                   setb REFLOW_FLAG
0574 E550       510                   mov a, exit_seconds
0576 B43C03     511                   cjne a, #60, Skip_Emergency_exit
0579            512                   ;load_y(50)
0579            513                   ;lcall x_gteq_y
0579            514                   ;jb mf, Skip_Emergency_exit
0579            515   
0579            516                   ;lcall ;send temperature value to serial
0579 02050C     517                   ljmp STOP_PROCESS ; more then 60 seconds has elapse and we are below 50C ESCAPE
057C            518                   
057C            519           Skip_Emergency_exit:        
057C 753446     520            mov y+0, #low (temp_soak % 0x10000) 
057F 753500     520            mov y+1, #high(temp_soak % 0x10000) 
0582 753600     520            mov y+2, #low (temp_soak / 0x10000) 
0585 753700     520            mov y+3, #high(temp_soak / 0x10000)  ; this line is sus ; temp_soak is a BCD value
0588 120252     521                   lcall x_lteq_y
058B 300003     522                   jnb mf, noChange_preheatState
058E 754401     523                   mov OVEN_STATE, #OVEN_STATE_SOAK
0591            524                   noChange_preheatState:
0591 020636     525                   ljmp oven_FSM_done
0594            526   
0594            527           ovenFSM_soak:
0594 B4014F     528                   cjne a, #OVEN_STATE_SOAK, ovenFSM_reflow
0597 C0E0       529            push acc
0599 7401       529            mov a, #1
059B 14         529            dec a
059C 1200C7     529            lcall ?Set_Cursor_1 ; Select column and row
059F D0E0       529            pop acc
05A1 C083       530            push dph
05A3 C082       530            push dpl
05A5 C0E0       530            push acc
05A7 9003C8     530            mov dptr, #soakMessage
05AA 1200BA     530            lcall ?Send_Constant_String
05AD D0E0       530            pop acc
05AF D082       530            pop dpl
05B1 D083       530            pop dph
05B3 C083       531            push dph
05B5 C082       531            push dpl
05B7 C0E0       531            push acc
05B9 9003AF     531            mov dptr, #LCD_clearLine
05BC 1200BA     531            lcall ?Send_Constant_String
05BF D0E0       531            pop acc
05C1 D082       531            pop dpl
05C3 D083       531            pop dph
05C5 C0E0       532            push acc
05C7 7401       532            mov a, #1
05C9 14         532            dec a
05CA 1200C5     532            lcall ?Set_Cursor_2 ; Select column and row
05CD D0E0       532            pop acc
05CF C000       533            push ar0
05D1 A84F       533            mov r0, seconds_elapsed
05D3 1200CC     533            lcall ?Display_BCD
05D6 D000       533            pop ar0
05D8            534   
05D8            535                   ; check if seconds elapsed > soak time
05D8 E54F       536                   mov a, seconds_elapsed
05DA B54806     537                   cjne a, time_soak, noChange_soakState
05DD 754402     538                   mov OVEN_STATE, #OVEN_STATE_REFLOW
05E0 754F00     539                   mov seconds_elapsed, #0 ; reset
05E3            540                   noChange_soakState:
05E3 020636     541                   ljmp oven_FSM_done
05E6            542   
05E6            543           ovenFSM_reflow:
05E6 B40244     544                   cjne a, #OVEN_STATE_REFLOW, ovenFSM_exit
05E9 C0E0       545            push acc
05EB 7401       545            mov a, #1
05ED 14         545            dec a
05EE 1200C7     545            lcall ?Set_Cursor_1 ; Select column and row
05F1 D0E0       545            pop acc
05F3 C083       546            push dph
05F5 C082       546            push dpl
05F7 C0E0       546            push acc
05F9 9003CD     546            mov dptr, #reflowMessage
05FC 1200BA     546            lcall ?Send_Constant_String
05FF D0E0       546            pop acc
0601 D082       546            pop dpl
0603 D083       546            pop dph
0605 C083       547            push dph
0607 C082       547            push dpl
0609 C0E0       547            push acc
060B 9003AF     547            mov dptr, #LCD_clearLine
060E 1200BA     547            lcall ?Send_Constant_String
0611 D0E0       547            pop acc
0613 D082       547            pop dpl
0615 D083       547            pop dph
0617 C0E0       548            push acc
0619 7401       548            mov a, #1
061B 14         548            dec a
061C 1200C5     548            lcall ?Set_Cursor_2 ; Select column and row
061F D0E0       548            pop acc
0621 C000       549            push ar0
0623 A84F       549            mov r0, seconds_elapsed
0625 1200CC     549            lcall ?Display_BCD
0628 D000       549            pop ar0
062A 020636     550                   ljmp oven_FSM_done
062D            551   
062D            552           ovenFSM_exit:
062D 754400     553                   mov OVEN_STATE, #OVEN_STATE_PREHEAT
0630 020636     554                   ljmp oven_FSM_done
0633 12050C     555                   lcall STOP_PROCESS ; Exit oven FSM, turn power off, return to program entry
0636            556                   
0636            557           oven_FSM_done:
0636 020511     558                   ljmp OVEN_FSM ; return to start
0639            559           
0639 22         560           ret ; technically unncessary
063A            561   
063A            562   MENU_FSM:        
063A 209614     563       jb CHANGE_MENU_PIN, checkTimeInc
063D C002       563            push AR2
063F 7A32       563            mov R2, #50
0641 120038     563            lcall ?Wait_Milli_Seconds
0644 D002       563            pop AR2
0646 209608     563       jb CHANGE_MENU_PIN, checkTimeInc
0649 3096FD     563       jnb CHANGE_MENU_PIN, $
064C E545       564           mov a, MENU_STATE 
064E 04         565           inc a
064F F545       566           mov MENU_STATE, a 
0651            567   
0651            568           ; increment is checked with a seperate cascade that's outside the FSM
0651            569           ; I wanted to keep FSM state outputs seperate from push button checks - George
0651            570           checkTimeInc:
0651 20B022     571       jb INC_TIME_PIN, checkTempInc
0654 C002       571            push AR2
0656 7A32       571            mov R2, #50
0658 120038     571            lcall ?Wait_Milli_Seconds
065B D002       571            pop AR2
065D            571   
065D 20B016     571       jb INC_TIME_PIN, checkTempInc
0660 30B0FD     571       jnb INC_TIME_PIN, $
0663 B40009     572                   cjne a, #MENU_STATE_SOAK, incTimeReflow
0666 E548       573                           mov a, time_soak
0668 2405       574                           add A, #5
066A D4         575                           DA A
066B F548       576                           mov time_soak, a       
066D 8007       577                           sjmp checkTempInc       
066F            578                   incTimeReflow:
066F E54B       579                           mov a, time_refl
0671 2405       580                           add A, #5
0673 D4         581                           DA A
0674 F54B       582                           mov time_refl, a
0676            583   
0676            584           checkTempInc:
0676 208434     585       jb INC_TEMP_PIN, enterMenuStateCheck
0679 C002       585            push AR2
067B 7A32       585            mov R2, #50
067D 120038     585            lcall ?Wait_Milli_Seconds
0680 D002       585            pop AR2
0682 208428     585       jb INC_TEMP_PIN, enterMenuStateCheck
0685 3084FD     585       jnb INC_TEMP_PIN, $      
0688 B40012     586                   cjne a, #MENU_STATE_SOAK, incTempReflow  ; issues 295 -> 700
068B E546       587                           mov a, temp_soak+0
068D 2405       588                           add a, #0x5
068F D4         589                           DA a
0690 F546       590                           mov temp_soak+0, a
0692 7007       591                           jnz tempSoakIncDone
0694 E547       592                           mov a, temp_soak+1 ; +1 refers to most significant digit
0696 2401       593                           add a, #0x1 ; hundreds/thousands place BCD is +1 instead of +5
0698 D4         594                           DA a
0699 F547       595                           mov temp_soak+1, a
069B            596                   tempSoakIncDone:
069B 8010       597                           sjmp enterMenuStateCheck       
069D            598                   incTempReflow:
069D E549       599                           mov a, temp_refl+0
069F 2405       600                           add a, #0x5
06A1 D4         601                           DA a
06A2 F549       602                           mov temp_refl+0, a
06A4 7007       603                           jnz tempReflIncDone
06A6 E54A       604                           mov a, temp_refl+1
06A8 2401       605                           add a, #0x1
06AA D4         606                           DA a
06AB F54A       607                           mov temp_refl+1, a
06AD            608           tempReflIncDone:
06AD            609                   
06AD            610           enterMenuStateCheck:
06AD E545       611                   mov a, MENU_STATE
06AF            612   
06AF            613           menuFSM_configSoak:
06AF B4007A     614                   cjne a, #MENU_STATE_SOAK, menuFSM_configReflow
06B2            615                   ; display Soak Menu Options
06B2 C0E0       616            push acc
06B4 7401       616            mov a, #1
06B6 14         616            dec a
06B7 1200C7     616            lcall ?Set_Cursor_1 ; Select column and row
06BA D0E0       616            pop acc
06BC C083       617            push dph
06BE C082       617            push dpl
06C0 C0E0       617            push acc
06C2 90037D     617            mov dptr, #LCD_soakTemp
06C5 1200BA     617            lcall ?Send_Constant_String
06C8 D0E0       617            pop acc
06CA D082       617            pop dpl
06CC D083       617            pop dph
06CE C000       618            push ar0
06D0 A847       618            mov r0, temp_soak+1
06D2 1200CC     618            lcall ?Display_BCD
06D5 D000       618            pop ar0
06D7 C000       619            push ar0
06D9 A846       619            mov r0, temp_soak+0
06DB 1200CC     619            lcall ?Display_BCD
06DE D000       619            pop ar0
06E0 C083       620            push dph
06E2 C082       620            push dpl
06E4 C0E0       620            push acc
06E6 9003AF     620            mov dptr, #LCD_clearLine
06E9 1200BA     620            lcall ?Send_Constant_String
06EC D0E0       620            pop acc
06EE D082       620            pop dpl
06F0 D083       620            pop dph
06F2 C0E0       621            push acc
06F4 7401       621            mov a, #1
06F6 14         621            dec a
06F7 1200C5     621            lcall ?Set_Cursor_2 ; Select column and row
06FA D0E0       621            pop acc
06FC C083       622            push dph
06FE C082       622            push dpl
0700 C0E0       622            push acc
0702 900371     622            mov dptr, #LCD_soakTime
0705 1200BA     622            lcall ?Send_Constant_String
0708 D0E0       622            pop acc
070A D082       622            pop dpl
070C D083       622            pop dph
070E C000       623            push ar0
0710 A848       623            mov r0, time_soak
0712 1200CC     623            lcall ?Display_BCD
0715 D000       623            pop ar0
0717 C083       624            push dph
0719 C082       624            push dpl
071B C0E0       624            push acc
071D 9003AF     624            mov dptr, #LCD_clearLine
0720 1200BA     624            lcall ?Send_Constant_String
0723 D0E0       624            pop acc
0725 D082       624            pop dpl
0727 D083       624            pop dph
0729 0207AF     625                   ljmp menu_FSM_done
072C            626   
072C            627           menuFSM_configReflow:
072C B4017A     628                   cjne a, #MENU_STATE_REFLOW, reset_menu_state
072F            629                   ; display Reflow Menu Options
072F C0E0       630            push acc
0731 7401       630            mov a, #1
0733 14         630            dec a
0734 1200C7     630            lcall ?Set_Cursor_1 ; Select column and row
0737 D0E0       630            pop acc
0739 C083       631            push dph
073B C082       631            push dpl
073D C0E0       631            push acc
073F 900395     631            mov dptr, #LCD_reflowTemp
0742 1200BA     631            lcall ?Send_Constant_String
0745 D0E0       631            pop acc
0747 D082       631            pop dpl
0749 D083       631            pop dph
074B C000       632            push ar0
074D A84A       632            mov r0, temp_refl+1
074F 1200CC     632            lcall ?Display_BCD
0752 D000       632            pop ar0
0754 C000       633            push ar0
0756 A849       633            mov r0, temp_refl+0
0758 1200CC     633            lcall ?Display_BCD
075B D000       633            pop ar0
075D C083       634            push dph
075F C082       634            push dpl
0761 C0E0       634            push acc
0763 9003AF     634            mov dptr, #LCD_clearLine
0766 1200BA     634            lcall ?Send_Constant_String
0769 D0E0       634            pop acc
076B D082       634            pop dpl
076D D083       634            pop dph
076F C0E0       635            push acc
0771 7401       635            mov a, #1
0773 14         635            dec a
0774 1200C5     635            lcall ?Set_Cursor_2 ; Select column and row
0777 D0E0       635            pop acc
0779 C083       636            push dph
077B C082       636            push dpl
077D C0E0       636            push acc
077F 900389     636            mov dptr, #LCD_reflowTime
0782 1200BA     636            lcall ?Send_Constant_String
0785 D0E0       636            pop acc
0787 D082       636            pop dpl
0789 D083       636            pop dph
078B C000       637            push ar0
078D A84B       637            mov r0, time_refl
078F 1200CC     637            lcall ?Display_BCD
0792 D000       637            pop ar0
0794 C083       638            push dph
0796 C082       638            push dpl
0798 C0E0       638            push acc
079A 9003AF     638            mov dptr, #LCD_clearLine
079D 1200BA     638            lcall ?Send_Constant_String
07A0 D0E0       638            pop acc
07A2 D082       638            pop dpl
07A4 D083       638            pop dph
07A6 0207AF     639                   ljmp menu_FSM_done
07A9            640   
07A9            641           reset_menu_state: ; sets menu state variable to 0
07A9 754500     642                   mov MENU_STATE, #MENU_STATE_SOAK
07AC 0207AF     643                   ljmp menu_FSM_done
07AF            644   
07AF            645           menu_FSM_done:
07AF 22         646                   ret
07B0            647   
07B0            648   main_program:
07B0            649           ; George
07B0 75817F     650           mov sp, #0x7f
07B3 12048E     651           lcall Initilize_All
07B6 120087     652           lcall LCD_4BIT
07B9            653   
07B9            654           ; Default display - 
07B9            655           ; Reflow oven controller 
07B9            656           ; (Start or Configure?)
07B9            657           PROGRAM_ENTRY:
07B9 C0E0       658            push acc
07BB 7401       658            mov a, #1
07BD 14         658            dec a
07BE 1200C7     658            lcall ?Set_Cursor_1 ; Select column and row
07C1 D0E0       658            pop acc
07C3 C083       659            push dph
07C5 C082       659            push dpl
07C7 C0E0       659            push acc
07C9 900352     659            mov dptr, #LCD_defaultTop
07CC 1200BA     659            lcall ?Send_Constant_String
07CF D0E0       659            pop acc
07D1 D082       659            pop dpl
07D3 D083       659            pop dph
07D5 C0E0       660            push acc
07D7 7401       660            mov a, #1
07D9 14         660            dec a
07DA 1200C5     660            lcall ?Set_Cursor_2 ; Select column and row
07DD D0E0       660            pop acc
07DF C083       661            push dph
07E1 C082       661            push dpl
07E3 C0E0       661            push acc
07E5 900360     661            mov dptr, #LCD_defaultBot
07E8 1200BA     661            lcall ?Send_Constant_String
07EB D0E0       661            pop acc
07ED D082       661            pop dpl
07EF D083       661            pop dph
07F1            662   
07F1            663           checkStartButton: ; assumed negative logic - used a label for an easy ljmp in the future
07F1 209512     664       jb START_PIN, noStartButtonPress
07F4 C002       664            push AR2
07F6 7A32       664            mov R2, #50
07F8 120038     664            lcall ?Wait_Milli_Seconds
07FB D002       664            pop AR2
07FD 209506     664       jb START_PIN, noStartButtonPress
0800 3095FD     664       jnb START_PIN, $
0803 020827     665                   ljmp enter_oven_fsm ; successful button press, enter oven FSM   
0806            666   
0806            667           noStartButtonPress:
0806            668                   ; if the 'IN_MENU' flag is set, always enter into the menu FSM, this is so that the menu FSM can always be entered
0806            669                   ; creates an infinite loop that will always display menu once entered - broken if START button pressed
0806 300106     670                   jnb IN_MENU_FLAG, checkMenuButtonPress
0809 12063A     671                   lcall MENU_FSM 
080C 0207F1     672                   ljmp checkStartButton
080F            673   
080F            674           checkMenuButtonPress:
080F            675                   ; check for enter menu button press (reusing increment menu pin)
080F 209612     676       jb CHANGE_MENU_PIN, noMenuButtonPress
0812 C002       676            push AR2
0814 7A32       676            mov R2, #50
0816 120038     676            lcall ?Wait_Milli_Seconds
0819 D002       676            pop AR2
081B 209606     676       jb CHANGE_MENU_PIN, noMenuButtonPress
081E 3096FD     676       jnb CHANGE_MENU_PIN, $
0821            677                   ; setb IN_MENU_FLAG; successful button press, enter menu FSM loop ; - THIS LINE CAUSES THE BUG
0821 02086C     678                   ljmp setMenuFlag
0824            679                   
0824            680           noMenuButtonPress:
0824 0207F1     681                   ljmp checkStartButton ; this line does not execute if ljmp setMenuFlag is there?!?!?
0827            682   
0827            683           enter_oven_fsm:
0827 C201       684                   clr IN_MENU_FLAG ; No longer in menu
0829 D202       685                   setb IN_OVEN_FLAG
082B C0E0       686            push acc
082D 7401       686            mov a, #1
082F 14         686            dec a
0830 1200C7     686            lcall ?Set_Cursor_1 ; Select column and row
0833 D0E0       686            pop acc
0835 C083       687            push dph
0837 C082       687            push dpl
0839 C0E0       687            push acc
083B 9003AF     687            mov dptr, #LCD_clearLine
083E 1200BA     687            lcall ?Send_Constant_String
0841 D0E0       687            pop acc
0843 D082       687            pop dpl
0845 D083       687            pop dph
0847 C0E0       688            push acc
0849 7401       688            mov a, #1
084B 14         688            dec a
084C 1200C5     688            lcall ?Set_Cursor_2 ; Select column and row
084F D0E0       688            pop acc
0851 C083       689            push dph
0853 C082       689            push dpl
0855 C0E0       689            push acc
0857 9003AF     689            mov dptr, #LCD_clearLine
085A 1200BA     689            lcall ?Send_Constant_String
085D D0E0       689            pop acc
085F D082       689            pop dpl
0861 D083       689            pop dph
0863            690   
0863 120413     691                   lcall Timer2_Init  ; breaks things
0866 120511     692                   lcall OVEN_FSM     ; will call STOP_PROCESS which loops back to the entry point
0869 12050C     693                   lcall STOP_PROCESS ; added for safety
086C            694                   
086C            695           setMenuFlag: 
086C D201       696                   setb IN_MENU_FLAG
086E 0207F1     697                   ljmp checkStartButton
0871            698   
0871            699           program_end:
0871 0207B0     700                   ljmp main_program
0874            701   EN
