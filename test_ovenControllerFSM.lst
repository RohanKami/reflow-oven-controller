0000              1   
0000              2   ; Main file. FSM implementing the following sequence:
0000              3   ;       State 0: Power = 0% (default state)
0000              4   ;               if start = NO, self loop; if start = YES, next state
0000              5   ;       State 1: Power = 100%; Sec = 0
0000              6   ;               if temp <= 150, self loop; temp > 150, next
0000              7   ;       State 2: Power = 20%
0000              8   ;               if sec <= 60s, self loop; sec>60s, next
0000              9   ;       State 3: Power = 100%; Sec = 0
0000             10   ;               if temp <= 220, self loop; temp>220, next
0000             11   ;       State 4: Power = 20%
0000             12   ;               if sec <= 45s, self loop; sec >45, next
0000             13   ;       State 5: Power = 0%
0000             14   ;               if temp >=60, self loop; temp <60, next
0000             15   ;       return to state 0
0000             16   
0000             17   
0000             18   ; MACROS ;
                 19   CLJNE mac
                 20       cjne %0, %1, $+3+2 ; Jump if no equal 2 bytes ahead since sjmp is a 2 byte instruction  
                 21       sjmp $+2+3 ; Jump 3 bytes after this instruction as ljmp takes 3 bytes to encode
                 22       ljmp %2 ; ljmp can access any part of the code space
                 23   endmac
0000             24   
0000             25   ; Push button macro - It does not work :( - check if it works now, moved location
0000             26   ; check_Push_Button MAC
0000             27   ;     jb %0, %1
0000             28   ;     Wait_Milli_Seconds(#50)
0000             29   ;     jb %0, %1
0000             30   ;     jnb %0, $
0000             31   ; ENDMAC
0000             32   
0000             33   ; check_Push_Button MAC ; new one with multiplexed buttons
0000             34   ;     clr  %0
0000             35   ;     jb SHARED_PIN, %1
0000             36   ;     Wait_Milli_Seconds(#50)
0000             37   ;     jb SHARED_PIN, %1
0000             38   ;     jnb SHARED_PIN, $
0000             39   ;     Wait_Milli_Seconds(#50)
0000             40   ; ENDMAC
0000             41   
0000             42   ; check_Push_Button(variable_flag, dest_label)
0000             43   ; Params
0000             44   ; variable_flag - variable we are checking in place of the pin e.g. PB_START_PIN
0000             45   ; dest_label - where to jump if a push button is not pressed
                 46   check_Push_Button MAC ; new one with multiplexed buttons
                 47           setb PB_START_PIN
                 48           setb PB_CHANGE_MENU_PIN
                 49           setb PB_INC_TEMP_PIN
                 50           setb PB_INC_TIME_PIN
                 51           setb PB_STOP_PIN
                 52           
                 53           setb SHARED_PIN
                 54           ; check if any push buttons are pressed
                 55           clr START_PIN             
                 56           clr CHANGE_MENU_PIN       
                 57           clr INC_TEMP_PIN          
                 58           clr INC_TIME_PIN          
                 59           clr STOP_PIN
                 60   
                 61           ; debounce
                 62           jb SHARED_PIN, %1 ; use helper label to jump to the end
                 63           Wait_Milli_Seconds(#50)
                 64           jb SHARED_PIN, %1
                 65   
                 66           ; Set the LCD data pins to logic 1
                 67           setb START_PIN
                 68           setb CHANGE_MENU_PIN
                 69           setb INC_TEMP_PIN
                 70           setb INC_TIME_PIN
                 71           setb STOP_PIN
                 72   
                 73           ; check push buttons 1 by one
                 74           clr START_PIN
                 75           mov c, SHARED_PIN
                 76           mov PB_START_PIN, c
                 77           setb START_PIN
                 78   
                 79           clr CHANGE_MENU_PIN
                 80           mov c, SHARED_PIN
                 81           mov PB_CHANGE_MENU_PIN, c
                 82           setb CHANGE_MENU_PIN
                 83   
                 84           clr INC_TEMP_PIN
                 85           mov c, SHARED_PIN
                 86           mov PB_INC_TEMP_PIN, c
                 87           setb INC_TEMP_PIN
                 88   
                 89           clr INC_TIME_PIN
                 90           mov c, SHARED_PIN
                 91           mov PB_INC_TIME_PIN, c
                 92           setb INC_TIME_PIN
                 93   
                 94           clr STOP_PIN
                 95           mov c, SHARED_PIN
                 96           mov PB_STOP_PIN, c
                 97           setb STOP_PIN
                 98   
                 99           jb %0, %1 ; check that the variable flag is not 1, otherwise jmp
                100   
                101   ENDMAC
0000            102   
                104   $LIST
0000            106   
0000            107   ;  N76E003 pinout:
0000            108   ;                               -------
0000            109   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000            110   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000            111   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000            112   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000            113   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000            114   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000            115   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000            116   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000            117   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000            118   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000            119   ;                               -------
0000            120   
0000            121   
0000            122   
0000            123   ;-------------------------------------------------------------------------------------------------------------------------------------
0000            124   
0000            125   ;                                                              STYLE GUIDE
0000            126   
0000            127   ; End flag names with _FLAG
0000            128   ; Use all upper case for constants (anything defined in equ or pin definitions), as it makes it easier to read quickly
0000            129   ; Before any jump or logic block comment purpose and try to comment throughout - code should be self explanatory, comment "why" it was implemented this way
0000            130   ; Before any block of code also comment who wrote it 
0000            131   ; Aim for variable names with 8-20 characters
0000            132   
0000            133   ; --------------------------------------------------------------------------------------------------------------------------
0000            134   
0000            135   
0000            136   ; Timer constants
0000            137   CLK                   EQU 16600000 ; Microcontroller system frequency in Hz
0000            138   BAUD                  EQU 115200   ; Baud rate of UART in bps 
0000            139   TIMER1_RELOAD         EQU (0x100-(CLK/(16*BAUD))) ; Serial ISR
0000            140   TIMER2_RELOAD         EQU (65536-(CLK/1000))    ; 1ms Delay ISR
0000            141   TIMER0_RELOAD         EQU (0x10000-(CLK/4096))    ; Sound ISR For 2kHz square wave
0000            142   
0000            143   ; Pin definitions + Hardware Wiring 
0000            144   ; Layout
0000            145   ; {Start} {Stop} {Change Menu} {Inc Temp} {Inc Time}
0000            146   START_PIN             EQU P1.3 
0000            147   CHANGE_MENU_PIN       EQU P0.1 
0000            148   INC_TEMP_PIN          EQU P0.2  
0000            149   INC_TIME_PIN          EQU P0.3  
0000            150   STOP_PIN              EQU P0.0  
0000            151   SHARED_PIN            EQU P1.5 
0000            152   
0000            153   PWM_OUT               EQU P1.2 ; Pin 13
0000            154   
0000            155   
0000            156   ; Menu states
0000            157   MENU_STATE_SOAK       EQU 0
0000            158   MENU_STATE_REFLOW     EQU 1
0000            159   MENU_STATE_TEST       EQU 2
0000            160   
0000            161   ; oven states
0000            162   OVEN_STATE_PREHEAT    EQU 0
0000            163   OVEN_STATE_SOAK       EQU 1
0000            164   OVEN_STATE_RAMP2PEAK  EQU 2
0000            165   OVEN_STATE_REFLOW     EQU 3
0000            166   OVEN_STATE_COOLING    EQU 4
0000            167   OVEN_STATE_FINISHED   EQU 5
0000            168   
0000            169   ; things to keep track of
0000            170   COOLED_TEMP           EQU 50 ; once cooled to this temperature, the reflow is now "finished"
0000            171   COOLED_TEMP_LOAD_MATH EQU COOLED_TEMP*10000 ; use to load up the math
0000            172   FINISHED_SECONDS      EQU 10
0000            173   MAX_TIME              EQU 90
0000            174   MIN_TIME              EQU 15
0000            175   MAX_TEMP              EQU 250
0000            176   MIN_TEMP              EQU 100
0000            177   
0000            178   ; define vectors
0000            179   ORG 0x0000 ; Reset vector
0000 020A3D     180           ljmp main_program
0003            181   ORG 0x0003 ; External interrupt 0 vector
0003 32         182           reti
000B            183   ORG 0x000B ; Timer/Counter 0 overflow interrupt vector
000B 020496     184            ljmp Timer0_ISR
0013            185   ORG 0x0013 ; External interrupt 1 vector
0013 32         186            reti
001B            187   ORG 0x001B ; Timer/Counter 1 overflow interrupt vector 
001B 32         188            reti
0023            189   ORG 0x0023 ; Serial port receive/transmit interrupt vector 
0023 32         190            reti
002B            191   ORG 0x002B ; Timer/Counter 2 overflow interrupt vector
002B 020497     192            ljmp Timer2_ISR
002E            193   
002E            194   
002E            195   ; register definitions previously needed by 'math32.inc' - currently commented out for future changes
0030            196   DSEG at 0x30
0030            197   x               : ds 4
0034            198   y               : ds 4
0038            199   bcd             : ds 5
003D            200   bcdf            : ds 5
0042            201   VLED_ADC        : ds 2
0044            202   
0044            203   OVEN_STATE      : ds 1 ; stores oven FSM state
0045            204   MENU_STATE      : ds 1 ; stores menu FSM state
0046            205   temp_soak       : ds 1 
0047            206   time_soak       : ds 1
0048            207   temp_refl       : ds 1
0049            208   time_refl       : ds 1
004A            209   ; pwm             : ds 1 ; controls output power to SSR
004A            210   ; pwm_counter     : ds 1 
004A            211   
004A            212   Count1ms        : ds 2 ; determines the number of 1ms increments that have passed 
004C            213   Count1ms_PWM    : ds 1
004D            214   seconds_elapsed  : ds 1
004E            215   exit_seconds    : ds 1 ; if we dont reach 50 c before 60 S terminate
004F            216   
004F            217   pwm_counter: ds 1 ; Free running counter 0, 1, 2, ..., 100, 0
0050            218   pwm: ds 1 ; pwm percentage
0051            219   
0051            220   
002E            221   CSEG ;starts the absolute segment from that address
002E            222   ; These 'EQU' must match the hardware wiring
002E            223   LCD_RS          EQU P1.3
002E            224   ;LCD_RW         EQU PX.X ; Not used in this code, connect the pin to GND
002E            225   LCD_E           EQU P1.4
002E            226   LCD_D4          EQU P0.0
002E            227   LCD_D5          EQU P0.1
002E            228   LCD_D6          EQU P0.2
002E            229   LCD_D7          EQU P0.3
002E            230   
                232   	$LIST
00E2            234   
00E2            235   ; Flags that are used to control events 
0000            236   BSEG 
0000            237   mf              : dbit 1
0001            238   IN_MENU_FLAG    : dbit 1
0002            239   IN_OVEN_FLAG    : dbit 1
0003            240   REFLOW_FLAG     : dbit 1
0004            241   
0004            242   ; Variables used for push button mux
0004            243   PB_START_PIN        : dbit 1
0005            244   PB_CHANGE_MENU_PIN  : dbit 1
0006            245   PB_INC_TEMP_PIN     : dbit 1
0007            246   PB_INC_TIME_PIN     : dbit 1
0008            247   PB_STOP_PIN         : dbit 1
0009            248   
                547   $LIST
                250   $LIST
0352            252   
0352            253   ; Messages to display on LCD when in Menu FSM
0352 5265666C   254   LCD_defaultTop  : db 'Reflow Oven: ', 0
     6F77204F
     76656E3A
     2000
0360 53746172   255   LCD_defaultBot  : db 'Start/Configure?', 0
     742F436F
     6E666967
     7572653F
     00
0371 536F616B   256   LCD_soakTime    : db 'Soak Time: ', 0
     2054696D
     653A2000
037D 536F616B   257   LCD_soakTemp    : db 'Soak Temp: ', 0
     2054656D
     703A2000
0389 5265666C   258   LCD_reflowTime  : db 'Refl Time: ', 0
     2054696D
     653A2000
0395 5265666C   259   LCD_reflowTemp  : db 'Refl Temp: ', 0
     2054656D
     703A2000
03A1 54455354   260   LCD_TEST        : db 'TEST MESSAGE ', 0
     204D4553
     53414745
     2000
03AF 20202020   261   LCD_clearLine   : db '                ', 0 ; put at end to clear line
     20202020
     20202020
     20202020
     00
03C0            262   
03C0 50726568   263   preheatMessage  : db 'Preheat', 0
     65617400
03C8 536F616B   264   soakMessage     : db 'Soak', 0
     00
03CD 5065616B   265   ramp2peakMessage: db 'Peak to Soak', 0
     20746F20
     536F616B
     00
03DA 5265666C   266   reflowMessage   : db 'Reflow', 0
     6F7700
03E1 436F6F6C   267   coolingMessage  : db 'Cooling', 0
     696E6700
03E9 46696E69   268   FinishedMessage : db 'Finished!', 0
     73686564
     2100
03F3 454D4552   269   stopMessage     : db 'EMERGENCY STOP', 0
     47454E43
     59205354
     4F5000
0402            270   
0402            271   ; Messages to display on LCD when in Oven Controller FSM
0402            272   
0402            273   ; Send a character using the serial port
0402            274   putchar:
0402 3099FD     275           jnb     TI, putchar
0405 C299       276           clr     TI
0407 F599       277           mov     SBUF, a
0409 22         278           ret
040A            279   
040A            280   ; Send a constant-zero-terminated string using the serial port
040A            281   SendString:
040A E4         282           clr     A
040B 93         283           movc    A, @A+DPTR
040C 6006       284           jz      SendStringDone
040E 120402     285           lcall   putchar
0411 A3         286           inc     DPTR
0412 80F6       287           sjmp    SendString
0414            288   SendStringDone:
0414 22         289           ret
0415            290   
0415            291   ; Eight bit number to display passed in ’a’.
0415            292   SendToLCD:
0415 75F064     293           mov     b, #100
0418 84         294           div     ab
0419 4430       295           orl     a, #0x30 ; Convert hundreds to ASCII
041B 12007D     296           lcall   ?WriteData ; Send to LCD
041E E5F0       297           mov     a, b ; Remainder is in register b
0420 75F00A     298           mov     b, #10
0423 84         299           div     ab
0424 4430       300           orl     a, #0x30 ; Convert tens to ASCII
0426 12007D     301           lcall   ?WriteData; Send to LCD
0429 E5F0       302           mov     a, b
042B 4430       303           orl     a, #0x30 ; Convert units to ASCII
042D 12007D     304           lcall   ?WriteData; Send to LCD
0430 22         305           ret
0431            306   
0431            307   ; Eight bit number to display passed in ’a’.
0431            308   SendToSerialPort:
0431 75F064     309           mov     b, #100
0434 84         310           div     ab
0435 4430       311           orl     a, #0x30 ; Convert hundreds to ASCII
0437 120402     312           lcall   putchar ; Send to PuTTY/Python/Matlab
043A E5F0       313           mov     a, b ; Remainder is in register b
043C 75F00A     314           mov     b, #10
043F 84         315           div     ab
0440 4430       316           orl     a, #0x30 ; Convert tens to ASCII
0442 120402     317           lcall   putchar ; Send to PuTTY/Python/Matlab
0445 E5F0       318           mov     a, b
0447 4430       319           orl     a, #0x30 ; Convert units to ASCII
0449 120402     320           lcall   putchar ; Send to PuTTY/Python/Matlab
044C 22         321           ret
044D            322   
044D            323   
044D            324   ;---------------------------------;
044D            325   ; Send a BCD number to PuTTY      ;
044D            326   ;---------------------------------;
                327   Send_BCD mac
                328   	push    ar0
                329   	mov     r0, %0
                330   	lcall   ?Send_BCD
                331   	pop     ar0
                332   	endmac
044D            333            ?Send_BCD:
044D C0E0       334                   push    acc
044F            335                   ; Write most significant digit
044F E8         336                   mov     a, r0
0450 C4         337                   swap    a
0451 540F       338                   anl     a, #0fh
0453 4430       339                   orl     a, #30h
0455 120402     340                   lcall   putchar
0458            341                   ; write least significant digit
0458 E8         342                   mov     a, r0
0459 540F       343                   anl     a, #0fh
045B 4430       344                   orl     a, #30h
045D 120402     345                   lcall   putchar
0460 D0E0       346                   pop     acc
0462 22         347   ret
0463            348   
0463            349   ;---------------------------------;
0463            350   ; Routine to initialize the ISR   ;
0463            351   ; for timer 0                     ;
0463            352   ;---------------------------------;
0463            353   Timer0_Init:
0463 438E08     354            orl     CKCON, #0b00001000 ; Input for timer 0 is sysclk/1 ; performs bit masking on CKON - Clock Control ; T0M = 1, timer 0 uses the system clock directly
0466 E589       355            mov     a, TMOD
0468 54F0       356            anl     a, #0xf0 ; 11110000 Clear the bits for timer 0
046A 4401       357            orl     a, #0x01 ; 00000001 Configure timer 0 as 16-timer (M1M0 = 01 -> Mode 1: 16-bit Timer/Counter)
046C F589       358            mov     TMOD, a
046E 758CF0     359            mov     TH0, #high(TIMER0_RELOAD) ; 8051 works with 8 bits so the oepration T0 = TIMER0_RELOAD  (16 bits) is done by setting high byte then low byte (8x2)
0471 758A2C     360            mov     TL0, #low (TIMER0_RELOAD)
0474            361            ; Enable the timer and interrupts
0474 D2A9       362           setb    ET0  ; Enable timer 0 interrupt
0476 D28C       363           setb    TR0  ; Start timer 0
0478 22         364            ret
0479            365   
0479            366   ;---------------------------------;
0479            367   ; Routine to initialize the ISR   ;
0479            368   ; for timer 2                     ;
0479            369   ;---------------------------------;
0479            370   Timer2_Init:
0479 75C800     371            mov     T2CON, #0 ; Stop timer/counter.  Autoreload mode.
047C 75CDBF     372            mov     TH2, #high(TIMER2_RELOAD)
047F 75CC28     373            mov     TL2, #low(TIMER2_RELOAD)
0482            374            ; Set the reload value
0482 43C980     375            orl     T2MOD, #0x80 ; Enable timer 2 autoreload
0485 75CBBF     376            mov     RCMP2H, #high(TIMER2_RELOAD)
0488 75CA28     377            mov     RCMP2L, #low(TIMER2_RELOAD)
048B            378            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
048B E4         379            clr     a
048C F54A       380            mov     Count1ms+0, a
048E F54B       381            mov     Count1ms+1, a
0490            382            ; Enable the timer and interrupts
0490 439B80     383            orl     EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0493 D2CA       384           setb    TR2  ; Enable timer 2
0495 22         385            ret
0496            386   
0496            387   Timer0_ISR:
0496 32         388           reti
0497            389   
0497            390   ;---------------------------------;
0497            391   ; ISR for timer 2                 ;
0497            392   ;---------------------------------;
0497            393   Timer2_ISR:
0497 C2CF       394           clr     TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0499 B284       395           cpl     P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
049B            396   
049B            397           ; The two registers used in the ISR must be saved in the stack
049B C0E0       398           push    acc
049D C0D0       399           push    psw
049F            400   
049F 054C       401           inc     Count1ms_PWM
04A1            402   
04A1            403           ; Increment the 16-bit one mili second counter
04A1 054A       404           inc     Count1ms+0    ; Increment the low 8-bits first
04A3 E54A       405           mov     a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
04A5 7002       406           jnz     Inc_done
04A7 054B       407           inc     Count1ms+1
04A9            408    
04A9            409           
04A9            410           Inc_done:
04A9 E54C       411           mov    a, Count1ms_PWM
04AB B40A15     412           cjne   a, #10, check1secondsPassed 
04AE            413   
04AE            414                   ;RK working on PWM
04AE 054F       415                   inc     pwm_counter
04B0 C3         416                   clr     c
04B1 E550       417                   mov     a, pwm
04B3 954F       418                   subb    a, pwm_counter ; If pwm_counter <= pwm then c=1
04B5 B3         419                   cpl     c
04B6 9292       420                   mov     PWM_OUT, c 
04B8 E54F       421                   mov     a, pwm_counter
04BA B46433     422                   cjne    a, #100, Timer2_ISR_done
04BD 754F00     423                   mov     pwm_counter, #0
04C0            424   
04C0 E4         425                   clr     a
04C1 F54C       426                   mov     Count1ms_PWM, a
04C3            427           
04C3            428           
04C3            429           check1secondsPassed:
04C3            430           ; Check if one second has passed
04C3 E54A       431            mov     a, Count1ms+0
04C5 B4E828     432            cjne    a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
04C8 E54B       433            mov     a, Count1ms+1
04CA B40323     434            cjne    a, #high(1000), Timer2_ISR_done         
04CD            435   
04CD            436           ; ---  1s has passed ----
04CD            437     
04CD            438           ; debugging
04CD E54F       439           mov a,  pwm_counter
04CF 120431     440           lcall   SendToSerialPort
04D2 740D       441           mov a,  #'\r' ; Return character
04D4 120402     442           lcall   putchar
04D7 740A       443           mov a,  #'\n' ; New-line character
04D9 120402     444           lcall   putchar
04DC            445   
04DC            446           ; mov a, OVEN_STATE
04DC            447           ; add A, #1
04DC            448           ; mov OVEN_STATE, a
04DC 300306     449           jnb     REFLOW_FLAG,  not_in_reflow ;Checks if we are in reflow state
04DF E54E       450           mov     a, exit_seconds             ;Increments the early exit seconds counter
04E1 2401       451           add     a, #1
04E3 F54E       452           mov     exit_seconds, a
04E5            453           
04E5            454    not_in_reflow:
04E5 E54D       455           mov     a, seconds_elapsed
04E7 2401       456           add     A, #1
04E9 F54D       457           mov     seconds_elapsed, a
04EB            458   
04EB            459           ; reset seconds ms counter
04EB E4         460           clr     a
04EC F54A       461           mov     Count1ms+0, a
04EE F54B       462           mov     Count1ms+1, a
04F0            463   
04F0            464           Timer2_ISR_done:
04F0 D0D0       465           pop     psw
04F2 D0E0       466            pop     acc
04F4 32         467           reti
04F5            468   
04F5            469   Initilize_All:
04F5            470           ; Configure pins to be bi-directional
04F5 75AC00     471           mov      P3M1,#0x00
04F8 75AD00     472            mov     P3M2,#0x00
04FB 75B300     473            mov     P1M1,#0x00
04FE 75B400     474            mov     P1M2,#0x00
0501 75B100     475            mov     P0M1,#0x00
0504 75B200     476            mov     P0M2,#0x00
0507            477   
0507 D281       478           setb    CHANGE_MENU_PIN
0509 D293       479           setb    START_PIN
050B            480   
050B D2AF       481           setb    EA   ; Enable Global interrupts
050D            482   
050D            483   
050D            484           ; Since the reset button bounces, we need to wait a bit before
050D            485           ; sending messages, otherwise we risk displaying gibberish!
050D C002       486            push AR2
050F 7A32       486            mov R2, #50
0511 120038     486            lcall ?Wait_Milli_Seconds
0514 D002       486            pop AR2
0516            487   
0516            488           ; Now we can proceed with the configuration of the serial port
0516 438E10     489           orl      CKCON, #0x10 ; CLK is the input for timer 1
0519 438780     490           orl      PCON, #0x80  ; Bit SMOD=1, double baud rate
051C 759852     491           mov      SCON, #0x52
051F 53C4DF     492           anl      T3CON, #0b11011111
0522 53890F     493           anl      TMOD, #0x0F ; Clear the configuration bits for timer 1
0525 438920     494           orl      TMOD, #0x20 ; Timer 1 Mode 2
0528 758DF7     495           mov      TH1, #TIMER1_RELOAD
052B D28E       496           setb    TR1
052D            497   
052D            498           ; ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ SUS  ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓   
052D            499           ; works on its own from lab3, might interfere with other stuff though       ; NOTE TIMER ZERO HAS NOT YET BEEN TESTED       
052D            500           ; Using timer 0 for delay functions.  Initialize here:
052D C28C       501            clr     TR0         ; Stop timer 0
052F 438E08     502            orl     CKCON,#0x08 ; CLK is the input for timer 0
0532 5389F0     503            anl     TMOD,#0xF0  ; Clear the configuration bits for timer 0
0535 438901     504            orl     TMOD,#0x01  ; Timer 0 in Mode 1: 16-bit timer
0538            505           ; ^ ^ ^ ^ ^ ^ ^ ^^ ^ ^ ^ ^ ^^ ^ ^ ^ ^^ ^ ^ ^            
0538            506            
0538            507            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
0538 43B382     508            orl     P1M1, #0b10000010
053B 53B47D     509            anl     P1M2, #0b01111101
053E            510            
053E            511            ; Initialize and start the ADC:
053E 53E8F0     512            anl     ADCCON0, #0xF0
0541 43E807     513            orl     ADCCON0, #0x07 ; Select channel 7
0544            514            
0544            515           ; AINDIDS select if some pins are analog inputs or digital I/O:
0544 75F600     516            mov     AINDIDS, #0x00 ; Disable all analog inputs
0547 43F681     517            orl     AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
054A 43E101     518            orl     ADCCON1, #0x01 ; Enable ADC
054D            519   
054D            520           ; Menu Configuration
054D C201       521           clr     IN_MENU_FLAG
054F C202       522           clr     IN_OVEN_FLAG
0551 7400       523           mov     a, #0
0553 F545       524           mov     MENU_STATE, a ; set menu state to 0 
0555            525   
0555            526           ; mov     temp_soak, #0x250
0555 754696     527           mov     temp_soak, #150
0558 75470F     528           mov     time_soak, #MIN_TIME
055B 7548DC     529           mov     temp_refl, #220
055E 75490F     530           mov     time_refl, #MIN_TIME
0561            531           
0561            532           ; Oven configuration
0561 754400     533           mov     OVEN_STATE, #OVEN_STATE_PREHEAT
0564 754D00     534           mov     seconds_elapsed, #0
0567 754C00     535           mov     Count1ms_PWM, #0
056A 754E00     536           mov     exit_seconds, #0
056D C203       537           clr     REFLOW_FLAG
056F            538           
056F 22         539           ret
0570            540           
0570            541   ;Button nested logic -> we should be constantly checking in the main loop for a stop (i.e the stop should be instantaneous)
0570            542           ;->Buttons should allow for adjustment of soak temp, soak time, reflow temp, reflow time (Ui should be designed to make all these visible and clear)
0570            543           ;->Start button should either be used only for start or used for start/pause (different from a stop
0570            544           ;Try to use button logic given in lab 2 to stay consistent
0570            545           ; Menu Logic (will keep UI clean)
0570            546           ; Button to switch states - Changes a state variable (4 states -> 2 bits) (or two flags)
0570            547           ; Two buttons to go up or down a value
0570            548           ; One button to stop <---- safety feature make this button only STOP
0570            549           
0570            550           ; ;pseudo code lol
0570            551           ; jb [button], [branch]
0570            552           ; Wait_Milli_Seconds(#50)
0570            553           ; jb [button], [branch]
0570            554           ; jnb [button], $
0570            555           ; ljmp [display??]
0570            556   
0570            557   ; ; 3 values : current time elapsed in seconds, 
0570            558   ; FSM_transition_check MAC
0570            559   ;         jb %0, %2
0570            560   ;         Wait_Milli_Seconds(#50) ; de-bounce
0570            561   ;         jb %0, %2
0570            562   ;         jnb %0, $
0570            563   ;         ; successful press registered
0570            564   ;         inc %1 ; increment param #1
0570            565   ; ENDMAC
0570            566   
0570            567   
0570            568   STOP_PROCESS:
0570            569           ; Turn everything off
0570 C203       570           clr     REFLOW_FLAG
0572 C202       571           clr     IN_OVEN_FLAG
0574 754400     572           MOV     OVEN_STATE, #OVEN_STATE_PREHEAT
0577 754D00     573           MOV     seconds_elapsed, #0
057A 755000     574           MOV     pwm, #0
057D            575   
057D C2CA       576           clr     TR2
057F 020A46     577           ljmp    PROGRAM_ENTRY
0582            578   
0582            579   ; configure_LCD_multiplexing: 
0582            580   ;         setb SHARED_PIN
0582            581   
0582            582   ;         ; check if any push buttons are pressed
0582            583   ;         clr START_PIN             
0582            584   ;         clr CHANGE_MENU_PIN       
0582            585   ;         clr INC_TEMP_PIN          
0582            586   ;         clr INC_TIME_PIN          
0582            587   ;         clr STOP_PIN
0582            588   
0582            589   ;         ; debounce
0582            590   ;         jb SHARED_PIN, enterOvenStateCheck
0582            591   ;         Wait_Milli_Seconds(#50)
0582            592   ;         jb SHARED_PIN, enterOvenStateCheck
0582            593   
0582            594   ;         ; Set the LCD data pins to logic 1
0582            595   ;         setb START_PIN
0582            596   ;         setb CHANGE_MENU_PIN
0582            597   ;         setb INC_TEMP_PIN
0582            598   ;         setb INC_TIME_PIN
0582            599   ;         setb STOP_PIN
0582            600   
0582            601   ;         ; Wait_Milli_Seconds(#50)
0582            602   
0582            603   ;         ret
0582            604   
0582            605   ; Precondition: Has temperature stored in x
0582            606   OVEN_FSM:
0582 D204       607           setb PB_START_PIN
0584 D205       607           setb PB_CHANGE_MENU_PIN
0586 D206       607           setb PB_INC_TEMP_PIN
0588 D207       607           setb PB_INC_TIME_PIN
058A D208       607           setb PB_STOP_PIN
058C            607           
058C D295       607           setb SHARED_PIN
058E            607           ; check if any push buttons are pressed
058E C293       607           clr START_PIN             
0590 C281       607           clr CHANGE_MENU_PIN       
0592 C282       607           clr INC_TEMP_PIN          
0594 C283       607           clr INC_TIME_PIN          
0596 C280       607           clr STOP_PIN
0598            607   
0598            607           ; debounce
0598 209544     607           jb SHARED_PIN, enterOvenStateCheck ; use helper label to jump to the end
059B C002       607            push AR2
059D 7A32       607            mov R2, #50
059F 120038     607            lcall ?Wait_Milli_Seconds
05A2 D002       607            pop AR2
05A4 209538     607           jb SHARED_PIN, enterOvenStateCheck
05A7            607   
05A7            607           ; Set the LCD data pins to logic 1
05A7 D293       607           setb START_PIN
05A9 D281       607           setb CHANGE_MENU_PIN
05AB D282       607           setb INC_TEMP_PIN
05AD D283       607           setb INC_TIME_PIN
05AF D280       607           setb STOP_PIN
05B1            607   
05B1            607           ; check push buttons 1 by one
05B1 C293       607           clr START_PIN
05B3 A295       607           mov c, SHARED_PIN
05B5 9204       607           mov PB_START_PIN, c
05B7 D293       607           setb START_PIN
05B9            607   
05B9 C281       607           clr CHANGE_MENU_PIN
05BB A295       607           mov c, SHARED_PIN
05BD 9205       607           mov PB_CHANGE_MENU_PIN, c
05BF D281       607           setb CHANGE_MENU_PIN
05C1            607   
05C1 C282       607           clr INC_TEMP_PIN
05C3 A295       607           mov c, SHARED_PIN
05C5 9206       607           mov PB_INC_TEMP_PIN, c
05C7 D282       607           setb INC_TEMP_PIN
05C9            607   
05C9 C283       607           clr INC_TIME_PIN
05CB A295       607           mov c, SHARED_PIN
05CD 9207       607           mov PB_INC_TIME_PIN, c
05CF D283       607           setb INC_TIME_PIN
05D1            607   
05D1 C280       607           clr STOP_PIN
05D3 A295       607           mov c, SHARED_PIN
05D5 9208       607           mov PB_STOP_PIN, c
05D7 D280       607           setb STOP_PIN
05D9            607   
05D9 200803     607           jb PB_STOP_PIN, enterOvenStateCheck ; check that the variable flag is not 1, otherwise jmp
05DC            607   
05DC            607   
05DC 120570     608           lcall   STOP_PROCESS
05DF            609   
05DF            610           ; check oven state if stop button is not pressed
05DF            611           enterOvenStateCheck:
05DF E544       612                   mov     a, OVEN_STATE
05E1 D280       613                   setb STOP_PIN
05E3            614              
05E3            615           ovenFSM_preheat:
05E3            616                   ; long jump for relative offset
05E3 B40002     617                   cjne    a, #OVEN_STATE_PREHEAT, ovenFSM_soak_jmp
05E6 8003       618                   sjmp    oven_state_preheat_tasks
05E8            619                   ovenFSM_soak_jmp:
05E8 02066B     620                           ljmp    ovenFSM_soak
05EB            621                   oven_state_preheat_tasks:
05EB 75501E     622                           mov     pwm, #30
05EE C0E0       623            push acc
05F0 7401       623            mov a, #1
05F2 14         623            dec a
05F3 1200C7     623            lcall ?Set_Cursor_1 ; Select column and row
05F6 D0E0       623            pop acc
05F8 C083       624            push dph
05FA C082       624            push dpl
05FC C0E0       624            push acc
05FE 9003C0     624            mov dptr, #preheatMessage
0601 1200BA     624            lcall ?Send_Constant_String
0604 D0E0       624            pop acc
0606 D082       624            pop dpl
0608 D083       624            pop dph
060A C083       625            push dph
060C C082       625            push dpl
060E C0E0       625            push acc
0610 9003AF     625            mov dptr, #LCD_clearLine
0613 1200BA     625            lcall ?Send_Constant_String
0616 D0E0       625            pop acc
0618 D082       625            pop dpl
061A D083       625            pop dph
061C C0E0       626            push acc
061E 7401       626            mov a, #1
0620 14         626            dec a
0621 1200C5     626            lcall ?Set_Cursor_2 ; Select column and row
0624 D0E0       626            pop acc
0626 E54D       627                           mov     a, seconds_elapsed
0628 120415     628                           lcall   SendToLCD
062B            629   
062B 75303C     630            mov x+0, #low (60 % 0x10000) 
062E 753100     630            mov x+1, #high(60 % 0x10000) 
0631 753200     630            mov x+2, #low (60 / 0x10000) 
0634 753300     630            mov x+3, #high(60 / 0x10000)  ; Imagine this is the measured temp 
0637            631   
0637            632                   ;Emergency exit process; tested, works
0637 D203       633                   setb    REFLOW_FLAG
0639 E54E       634                   mov     a, exit_seconds
063B B43C15     635                   cjne    a, #60, Skip_Emergency_exit
063E 753432     636            mov y+0, #low (50 % 0x10000) 
0641 753500     636            mov y+1, #high(50 % 0x10000) 
0644 753600     636            mov y+2, #low (50 / 0x10000) 
0647 753700     636            mov y+3, #high(50 / 0x10000) 
064A 120248     637                   lcall   x_gteq_y
064D 200003     638                   jb      mf, Skip_Emergency_exit
0650            639                   
0650            640                   ; mov a, temp
0650            641                   ; lcall ;send temperature value to serial
0650 020570     642                   ljmp    STOP_PROCESS ; more then 60 seconds has elapse and we are below 50C ESCAPE
0653            643                   
0653            644           Skip_Emergency_exit:       
0653            645                   ; check temperature has reached configured value 
0653 753446     646            mov y+0, #low (temp_soak % 0x10000) 
0656 753500     646            mov y+1, #high(temp_soak % 0x10000) 
0659 753600     646            mov y+2, #low (temp_soak / 0x10000) 
065C 753700     646            mov y+3, #high(temp_soak / 0x10000)  ; this line is sus ; temp_soak is a BCD value
065F 120248     647                   lcall   x_gteq_y
0662 300003     648                   jnb     mf, noChange_preheatState
0665 754401     649                   mov     OVEN_STATE, #OVEN_STATE_SOAK
0668            650                   noChange_preheatState:
0668 020803     651                           ljmp    oven_FSM_done
066B            652   
066B            653           ovenFSM_soak:
066B B4014B     654                   cjne    a, #OVEN_STATE_SOAK, ovenFSM_Ramp2Peak
066E 755014     655                   mov     pwm, #20
0671 C0E0       656            push acc
0673 7401       656            mov a, #1
0675 14         656            dec a
0676 1200C7     656            lcall ?Set_Cursor_1 ; Select column and row
0679 D0E0       656            pop acc
067B C083       657            push dph
067D C082       657            push dpl
067F C0E0       657            push acc
0681 9003C8     657            mov dptr, #soakMessage
0684 1200BA     657            lcall ?Send_Constant_String
0687 D0E0       657            pop acc
0689 D082       657            pop dpl
068B D083       657            pop dph
068D C083       658            push dph
068F C082       658            push dpl
0691 C0E0       658            push acc
0693 9003AF     658            mov dptr, #LCD_clearLine
0696 1200BA     658            lcall ?Send_Constant_String
0699 D0E0       658            pop acc
069B D082       658            pop dpl
069D D083       658            pop dph
069F C0E0       659            push acc
06A1 7401       659            mov a, #1
06A3 14         659            dec a
06A4 1200C5     659            lcall ?Set_Cursor_2 ; Select column and row
06A7 D0E0       659            pop acc
06A9 E54D       660                   mov     a, seconds_elapsed
06AB 120415     661                   lcall   SendToLCD
06AE            662   
06AE            663                   ; check if seconds elapsed > soak time
06AE E54D       664                   mov     a, seconds_elapsed
06B0 B54703     665                   cjne    a, time_soak, noChange_soakState
06B3 754402     666                   mov     OVEN_STATE, #OVEN_STATE_RAMP2PEAK
06B6            667                   ; mov seconds_elapsed, #0 ; reset
06B6            668                   noChange_soakState:
06B6 020803     669                           ljmp    oven_FSM_done
06B9            670   
06B9            671           ovenFSM_Ramp2Peak:
06B9 B4025B     672                   cjne    a, #OVEN_STATE_RAMP2PEAK, ovenFSM_reflow
06BC 755064     673                   mov     pwm, #100
06BF C0E0       674            push acc
06C1 7401       674            mov a, #1
06C3 14         674            dec a
06C4 1200C7     674            lcall ?Set_Cursor_1 ; Select column and row
06C7 D0E0       674            pop acc
06C9 C083       675            push dph
06CB C082       675            push dpl
06CD C0E0       675            push acc
06CF 9003CD     675            mov dptr, #ramp2peakMessage
06D2 1200BA     675            lcall ?Send_Constant_String
06D5 D0E0       675            pop acc
06D7 D082       675            pop dpl
06D9 D083       675            pop dph
06DB C083       676            push dph
06DD C082       676            push dpl
06DF C0E0       676            push acc
06E1 9003AF     676            mov dptr, #LCD_clearLine
06E4 1200BA     676            lcall ?Send_Constant_String
06E7 D0E0       676            pop acc
06E9 D082       676            pop dpl
06EB D083       676            pop dph
06ED C0E0       677            push acc
06EF 7401       677            mov a, #1
06F1 14         677            dec a
06F2 1200C5     677            lcall ?Set_Cursor_2 ; Select column and row
06F5 D0E0       677            pop acc
06F7 E54D       678                   mov     a, seconds_elapsed
06F9 120415     679                   lcall   SendToLCD
06FC 754D00     680                   mov     seconds_elapsed, #0 ; reset
06FF            681   
06FF            682                   ; check that temperature for reflow is reached, then exit                
06FF 753448     683            mov y+0, #low (temp_refl % 0x10000) 
0702 753500     683            mov y+1, #high(temp_refl % 0x10000) 
0705 753600     683            mov y+2, #low (temp_refl / 0x10000) 
0708 753700     683            mov y+3, #high(temp_refl / 0x10000)  ; this line is sus ; temp_soak is a BCD value
070B 120252     684                   lcall   x_lteq_y
070E 300003     685                   jnb     mf, noChange_ramp2peak
0711 754403     686                   mov     OVEN_STATE, #OVEN_STATE_REFLOW
0714            687                   noChange_ramp2peak:
0714 020803     688                           ljmp    oven_FSM_done
0717            689                   
0717            690           ovenFSM_reflow:
0717 B40344     691                   cjne    a, #OVEN_STATE_REFLOW, ovenFSM_cooling
071A 755064     692                   mov     pwm, #100
071D C0E0       693            push acc
071F 7401       693            mov a, #1
0721 14         693            dec a
0722 1200C7     693            lcall ?Set_Cursor_1 ; Select column and row
0725 D0E0       693            pop acc
0727 C083       694            push dph
0729 C082       694            push dpl
072B C0E0       694            push acc
072D 9003DA     694            mov dptr, #reflowMessage
0730 1200BA     694            lcall ?Send_Constant_String
0733 D0E0       694            pop acc
0735 D082       694            pop dpl
0737 D083       694            pop dph
0739 C083       695            push dph
073B C082       695            push dpl
073D C0E0       695            push acc
073F 9003AF     695            mov dptr, #LCD_clearLine
0742 1200BA     695            lcall ?Send_Constant_String
0745 D0E0       695            pop acc
0747 D082       695            pop dpl
0749 D083       695            pop dph
074B E54D       696                   mov     a, seconds_elapsed
074D 120415     697                   lcall   SendToLCD
0750            698   
0750            699                   ; check if seconds elapsed > reflow time
0750 E54D       700                   mov     a, seconds_elapsed
0752 B54906     701                   cjne    a, time_refl, noChange_reflowState
0755 754404     702                   mov     OVEN_STATE, #OVEN_STATE_COOLING
0758 754D00     703                   mov     seconds_elapsed, #0 ; reset
075B            704                   noChange_reflowState:
075B 020803     705                           ljmp    oven_FSM_done
075E            706   
075E            707           ovenFSM_cooling:
075E B4045B     708                   cjne    a, #OVEN_STATE_COOLING, ovenFSM_finished
0761 755000     709                   mov     pwm, #0
0764 C0E0       710            push acc
0766 7401       710            mov a, #1
0768 14         710            dec a
0769 1200C7     710            lcall ?Set_Cursor_1 ; Select column and row
076C D0E0       710            pop acc
076E C083       711            push dph
0770 C082       711            push dpl
0772 C0E0       711            push acc
0774 9003E1     711            mov dptr, #coolingMessage
0777 1200BA     711            lcall ?Send_Constant_String
077A D0E0       711            pop acc
077C D082       711            pop dpl
077E D083       711            pop dph
0780 C083       712            push dph
0782 C082       712            push dpl
0784 C0E0       712            push acc
0786 9003AF     712            mov dptr, #LCD_clearLine
0789 1200BA     712            lcall ?Send_Constant_String
078C D0E0       712            pop acc
078E D082       712            pop dpl
0790 D083       712            pop dph
0792 C0E0       713            push acc
0794 7401       713            mov a, #1
0796 14         713            dec a
0797 1200C5     713            lcall ?Set_Cursor_2 ; Select column and row
079A D0E0       713            pop acc
079C E54D       714                   mov     a, seconds_elapsed
079E 120415     715                   lcall   SendToLCD
07A1 754D00     716                   mov     seconds_elapsed, #0 ; reset
07A4            717   
07A4            718                   ; once temperature is low (compare with temp constant)
07A4 753420     719            mov y+0, #low (COOLED_TEMP_LOAD_MATH % 0x10000) 
07A7 7535A1     719            mov y+1, #high(COOLED_TEMP_LOAD_MATH % 0x10000) 
07AA 753607     719            mov y+2, #low (COOLED_TEMP_LOAD_MATH / 0x10000) 
07AD 753700     719            mov y+3, #high(COOLED_TEMP_LOAD_MATH / 0x10000)  ; this line is sus ; temp_soak is a BCD value
07B0 120252     720                   lcall   x_lteq_y
07B3 300003     721                   jnb     mf, noChange_cooling
07B6 754405     722                   mov     OVEN_STATE, #OVEN_STATE_FINISHED
07B9            723                   noChange_cooling:
07B9 020803     724                           ljmp    oven_FSM_done
07BC            725           
07BC            726           ovenFSM_finished:
07BC B4053E     727                   cjne    a, #OVEN_STATE_FINISHED, ovenFSM_exit
07BF C0E0       728            push acc
07C1 7401       728            mov a, #1
07C3 14         728            dec a
07C4 1200C7     728            lcall ?Set_Cursor_1 ; Select column and row
07C7 D0E0       728            pop acc
07C9 C083       729            push dph
07CB C082       729            push dpl
07CD C0E0       729            push acc
07CF 9003E9     729            mov dptr, #FinishedMessage
07D2 1200BA     729            lcall ?Send_Constant_String
07D5 D0E0       729            pop acc
07D7 D082       729            pop dpl
07D9 D083       729            pop dph
07DB C083       730            push dph
07DD C082       730            push dpl
07DF C0E0       730            push acc
07E1 9003AF     730            mov dptr, #LCD_clearLine
07E4 1200BA     730            lcall ?Send_Constant_String
07E7 D0E0       730            pop acc
07E9 D082       730            pop dpl
07EB D083       730            pop dph
07ED E54D       731                   mov     a, seconds_elapsed
07EF 120415     732                   lcall   SendToLCD
07F2            733   
07F2            734                   ; go back to Start Screen after a certain number of seconds
07F2 E54D       735                   mov     a, seconds_elapsed
07F4 B40A03     736                   cjne    a, #FINISHED_SECONDS, noChange_finishedState
07F7 020A46     737                   ljmp    PROGRAM_ENTRY
07FA            738                   noChange_finishedState:
07FA 020803     739                           ljmp    oven_FSM_done
07FD            740   
07FD            741           ovenFSM_exit:
07FD 754400     742                   mov     OVEN_STATE, #OVEN_STATE_PREHEAT
0800            743                   ; ljmp oven_FSM_done
0800 120570     744                   lcall   STOP_PROCESS ; Exit oven FSM, turn power off, return to program entry
0803            745                   
0803            746           oven_FSM_done:
0803 020582     747                   ljmp    OVEN_FSM ; return to start of oven FSM ; this is a blocking FSM
0806            748           
0806 22         749           ret ; technically unncessary
0807            750   
0807            751   MENU_FSM: 
0807            752           ; lcall configure_LCD_multiplexing  
0807            753   
0807 E545       754           mov     a, MENU_STATE 
0809 D204       755           setb PB_START_PIN
080B D205       755           setb PB_CHANGE_MENU_PIN
080D D206       755           setb PB_INC_TEMP_PIN
080F D207       755           setb PB_INC_TIME_PIN
0811 D208       755           setb PB_STOP_PIN
0813            755           
0813 D295       755           setb SHARED_PIN
0815            755           ; check if any push buttons are pressed
0815 C293       755           clr START_PIN             
0817 C281       755           clr CHANGE_MENU_PIN       
0819 C282       755           clr INC_TEMP_PIN          
081B C283       755           clr INC_TIME_PIN          
081D C280       755           clr STOP_PIN
081F            755   
081F            755           ; debounce
081F 209546     755           jb SHARED_PIN, checkTimeInc ; use helper label to jump to the end
0822 C002       755            push AR2
0824 7A32       755            mov R2, #50
0826 120038     755            lcall ?Wait_Milli_Seconds
0829 D002       755            pop AR2
082B 20953A     755           jb SHARED_PIN, checkTimeInc
082E            755   
082E            755           ; Set the LCD data pins to logic 1
082E D293       755           setb START_PIN
0830 D281       755           setb CHANGE_MENU_PIN
0832 D282       755           setb INC_TEMP_PIN
0834 D283       755           setb INC_TIME_PIN
0836 D280       755           setb STOP_PIN
0838            755   
0838            755           ; check push buttons 1 by one
0838 C293       755           clr START_PIN
083A A295       755           mov c, SHARED_PIN
083C 9204       755           mov PB_START_PIN, c
083E D293       755           setb START_PIN
0840            755   
0840 C281       755           clr CHANGE_MENU_PIN
0842 A295       755           mov c, SHARED_PIN
0844 9205       755           mov PB_CHANGE_MENU_PIN, c
0846 D281       755           setb CHANGE_MENU_PIN
0848            755   
0848 C282       755           clr INC_TEMP_PIN
084A A295       755           mov c, SHARED_PIN
084C 9206       755           mov PB_INC_TEMP_PIN, c
084E D282       755           setb INC_TEMP_PIN
0850            755   
0850 C283       755           clr INC_TIME_PIN
0852 A295       755           mov c, SHARED_PIN
0854 9207       755           mov PB_INC_TIME_PIN, c
0856 D283       755           setb INC_TIME_PIN
0858            755   
0858 C280       755           clr STOP_PIN
085A A295       755           mov c, SHARED_PIN
085C 9208       755           mov PB_STOP_PIN, c
085E D280       755           setb STOP_PIN
0860            755   
0860 200505     755           jb PB_CHANGE_MENU_PIN, checkTimeInc ; check that the variable flag is not 1, otherwise jmp
0863            755    ; increments menu state
0863 04         756           inc     a
0864 F545       757           mov     MENU_STATE, a 
0866 D281       758           setb    CHANGE_MENU_PIN
0868            759   
0868            760           ; increment is checked with a seperate cascade that's outside the FSM
0868            761           ; I wanted to keep FSM state outputs seperate from push button checks - George
0868            762           checkTimeInc:
0868 D204       763           setb PB_START_PIN
086A D205       763           setb PB_CHANGE_MENU_PIN
086C D206       763           setb PB_INC_TEMP_PIN
086E D207       763           setb PB_INC_TIME_PIN
0870 D208       763           setb PB_STOP_PIN
0872            763           
0872 D295       763           setb SHARED_PIN
0874            763           ; check if any push buttons are pressed
0874 C293       763           clr START_PIN             
0876 C281       763           clr CHANGE_MENU_PIN       
0878 C282       763           clr INC_TEMP_PIN          
087A C283       763           clr INC_TIME_PIN          
087C C280       763           clr STOP_PIN
087E            763   
087E            763           ; debounce
087E 209560     763           jb SHARED_PIN, checkTempInc ; use helper label to jump to the end
0881 C002       763            push AR2
0883 7A32       763            mov R2, #50
0885 120038     763            lcall ?Wait_Milli_Seconds
0888 D002       763            pop AR2
088A 209554     763           jb SHARED_PIN, checkTempInc
088D            763   
088D            763           ; Set the LCD data pins to logic 1
088D D293       763           setb START_PIN
088F D281       763           setb CHANGE_MENU_PIN
0891 D282       763           setb INC_TEMP_PIN
0893 D283       763           setb INC_TIME_PIN
0895 D280       763           setb STOP_PIN
0897            763   
0897            763           ; check push buttons 1 by one
0897 C293       763           clr START_PIN
0899 A295       763           mov c, SHARED_PIN
089B 9204       763           mov PB_START_PIN, c
089D D293       763           setb START_PIN
089F            763   
089F C281       763           clr CHANGE_MENU_PIN
08A1 A295       763           mov c, SHARED_PIN
08A3 9205       763           mov PB_CHANGE_MENU_PIN, c
08A5 D281       763           setb CHANGE_MENU_PIN
08A7            763   
08A7 C282       763           clr INC_TEMP_PIN
08A9 A295       763           mov c, SHARED_PIN
08AB 9206       763           mov PB_INC_TEMP_PIN, c
08AD D282       763           setb INC_TEMP_PIN
08AF            763   
08AF C283       763           clr INC_TIME_PIN
08B1 A295       763           mov c, SHARED_PIN
08B3 9207       763           mov PB_INC_TIME_PIN, c
08B5 D283       763           setb INC_TIME_PIN
08B7            763   
08B7 C280       763           clr STOP_PIN
08B9 A295       763           mov c, SHARED_PIN
08BB 9208       763           mov PB_STOP_PIN, c
08BD D280       763           setb STOP_PIN
08BF            763   
08BF 20071F     763           jb PB_INC_TIME_PIN, checkTempInc ; check that the variable flag is not 1, otherwise jmp
08C2            763   
08C2            763   
08C2 B4000F     764                   cjne a, #MENU_STATE_SOAK, incTimeReflow
08C5 E547       765                           mov     a, time_soak 
08C7 2405       766                           add     A, #5        
08C9 F547       767                           mov     time_soak, a 
08CB            768   
08CB            769                           ; check if time_soak will need to reset - assumes multiples of 5
08CB            770                           ; +5 to constants so they display on LCD b/f reseting
08CB B45F13     771                           cjne a, #(MAX_TIME+5), checkTempInc 
08CE 740F       772                           mov a, #MIN_TIME
08D0 F547       773                           mov time_soak, a
08D2            774   
08D2 800D       775                           sjmp checkTempInc       
08D4            776                   incTimeReflow:
08D4 E549       777                           mov     a, time_refl
08D6 2405       778                           add     A, #5
08D8 F549       779                           mov     time_refl, a
08DA            780   
08DA B45F04     781                           cjne a, #(MAX_TIME+5), checkTempInc
08DD 740F       782                           mov a, #MIN_TIME
08DF F549       783                           mov time_refl, a
08E1            784   
08E1            785   
08E1            786            checkTempInc:
08E1 D204       787           setb PB_START_PIN
08E3 D205       787           setb PB_CHANGE_MENU_PIN
08E5 D206       787           setb PB_INC_TEMP_PIN
08E7 D207       787           setb PB_INC_TIME_PIN
08E9 D208       787           setb PB_STOP_PIN
08EB            787           
08EB D295       787           setb SHARED_PIN
08ED            787           ; check if any push buttons are pressed
08ED C293       787           clr START_PIN             
08EF C281       787           clr CHANGE_MENU_PIN       
08F1 C282       787           clr INC_TEMP_PIN          
08F3 C283       787           clr INC_TIME_PIN          
08F5 C280       787           clr STOP_PIN
08F7            787   
08F7            787           ; debounce
08F7 209560     787           jb SHARED_PIN, enterMenuStateCheck ; use helper label to jump to the end
08FA C002       787            push AR2
08FC 7A32       787            mov R2, #50
08FE 120038     787            lcall ?Wait_Milli_Seconds
0901 D002       787            pop AR2
0903 209554     787           jb SHARED_PIN, enterMenuStateCheck
0906            787   
0906            787           ; Set the LCD data pins to logic 1
0906 D293       787           setb START_PIN
0908 D281       787           setb CHANGE_MENU_PIN
090A D282       787           setb INC_TEMP_PIN
090C D283       787           setb INC_TIME_PIN
090E D280       787           setb STOP_PIN
0910            787   
0910            787           ; check push buttons 1 by one
0910 C293       787           clr START_PIN
0912 A295       787           mov c, SHARED_PIN
0914 9204       787           mov PB_START_PIN, c
0916 D293       787           setb START_PIN
0918            787   
0918 C281       787           clr CHANGE_MENU_PIN
091A A295       787           mov c, SHARED_PIN
091C 9205       787           mov PB_CHANGE_MENU_PIN, c
091E D281       787           setb CHANGE_MENU_PIN
0920            787   
0920 C282       787           clr INC_TEMP_PIN
0922 A295       787           mov c, SHARED_PIN
0924 9206       787           mov PB_INC_TEMP_PIN, c
0926 D282       787           setb INC_TEMP_PIN
0928            787   
0928 C283       787           clr INC_TIME_PIN
092A A295       787           mov c, SHARED_PIN
092C 9207       787           mov PB_INC_TIME_PIN, c
092E D283       787           setb INC_TIME_PIN
0930            787   
0930 C280       787           clr STOP_PIN
0932 A295       787           mov c, SHARED_PIN
0934 9208       787           mov PB_STOP_PIN, c
0936 D280       787           setb STOP_PIN
0938            787   
0938 20061F     787           jb PB_INC_TEMP_PIN, enterMenuStateCheck ; check that the variable flag is not 1, otherwise jmp
093B            787   
093B B4000F     788                   cjne a, #MENU_STATE_SOAK, incTempReflow
093E E546       789                           mov     a, temp_soak 
0940 2405       790                           add     A, #5        
0942 F546       791                           mov     temp_soak, a 
0944            792   
0944 B4FF13     793                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
0947 7464       794                           mov a, #MIN_TEMP
0949 F546       795                           mov temp_soak, a
094B            796   
094B 800D       797                           sjmp enterMenuStateCheck       
094D            798                   incTempReflow:
094D E548       799                           mov     a, temp_refl
094F 2405       800                           add     A, #5
0951 F548       801                           mov     temp_refl, a
0953            802   
0953 B4FF04     803                           cjne a, #(MAX_TEMP+5), enterMenuStateCheck
0956 7464       804                           mov a, #MIN_TEMP
0958 F548       805                           mov temp_refl, a
095A            806   
095A            807           ; ---------------- FSM State Check ---------------- ;  
095A            808           enterMenuStateCheck:
095A D282       809                   setb INC_TEMP_PIN
095C E545       810                   mov     a, MENU_STATE
095E            811   
095E            812           menuFSM_configSoak:
095E B40069     813                   cjne    a, #MENU_STATE_SOAK, menuFSM_configReflow
0961            814                   ; display Soak Menu Options
0961 C0E0       815            push acc
0963 7401       815            mov a, #1
0965 14         815            dec a
0966 1200C7     815            lcall ?Set_Cursor_1 ; Select column and row
0969 D0E0       815            pop acc
096B C083       816            push dph
096D C082       816            push dpl
096F C0E0       816            push acc
0971 90037D     816            mov dptr, #LCD_soakTemp
0974 1200BA     816            lcall ?Send_Constant_String
0977 D0E0       816            pop acc
0979 D082       816            pop dpl
097B D083       816            pop dph
097D            816   
097D E546       817                   mov     a, temp_soak
097F 120415     818                   lcall   SendToLCD
0982 C083       819            push dph
0984 C082       819            push dpl
0986 C0E0       819            push acc
0988 9003AF     819            mov dptr, #LCD_clearLine
098B 1200BA     819            lcall ?Send_Constant_String
098E D0E0       819            pop acc
0990 D082       819            pop dpl
0992 D083       819            pop dph
0994 C0E0       820            push acc
0996 7401       820            mov a, #1
0998 14         820            dec a
0999 1200C5     820            lcall ?Set_Cursor_2 ; Select column and row
099C D0E0       820            pop acc
099E C083       821            push dph
09A0 C082       821            push dpl
09A2 C0E0       821            push acc
09A4 900371     821            mov dptr, #LCD_soakTime
09A7 1200BA     821            lcall ?Send_Constant_String
09AA D0E0       821            pop acc
09AC D082       821            pop dpl
09AE D083       821            pop dph
09B0 E547       822                   mov     a, time_soak
09B2 120415     823                   lcall   SendToLCD
09B5 C083       824            push dph
09B7 C082       824            push dpl
09B9 C0E0       824            push acc
09BB 9003AF     824            mov dptr, #LCD_clearLine
09BE 1200BA     824            lcall ?Send_Constant_String
09C1 D0E0       824            pop acc
09C3 D082       824            pop dpl
09C5 D083       824            pop dph
09C7 020A3C     825                   ljmp    menu_FSM_done
09CA            826   
09CA            827           menuFSM_configReflow:
09CA B40169     828                   cjne    a, #MENU_STATE_REFLOW, reset_menu_state
09CD            829                   ; display Reflow Menu Options
09CD C0E0       830            push acc
09CF 7401       830            mov a, #1
09D1 14         830            dec a
09D2 1200C7     830            lcall ?Set_Cursor_1 ; Select column and row
09D5 D0E0       830            pop acc
09D7 C083       831            push dph
09D9 C082       831            push dpl
09DB C0E0       831            push acc
09DD 900395     831            mov dptr, #LCD_reflowTemp
09E0 1200BA     831            lcall ?Send_Constant_String
09E3 D0E0       831            pop acc
09E5 D082       831            pop dpl
09E7 D083       831            pop dph
09E9 E548       832                   mov     a, temp_refl
09EB 120415     833                   lcall   SendToLCD
09EE C083       834            push dph
09F0 C082       834            push dpl
09F2 C0E0       834            push acc
09F4 9003AF     834            mov dptr, #LCD_clearLine
09F7 1200BA     834            lcall ?Send_Constant_String
09FA D0E0       834            pop acc
09FC D082       834            pop dpl
09FE D083       834            pop dph
0A00 C0E0       835            push acc
0A02 7401       835            mov a, #1
0A04 14         835            dec a
0A05 1200C5     835            lcall ?Set_Cursor_2 ; Select column and row
0A08 D0E0       835            pop acc
0A0A C083       836            push dph
0A0C C082       836            push dpl
0A0E C0E0       836            push acc
0A10 900389     836            mov dptr, #LCD_reflowTime
0A13 1200BA     836            lcall ?Send_Constant_String
0A16 D0E0       836            pop acc
0A18 D082       836            pop dpl
0A1A D083       836            pop dph
0A1C E549       837                   mov     a, time_refl
0A1E 120415     838                   lcall   SendToLCD
0A21 C083       839            push dph
0A23 C082       839            push dpl
0A25 C0E0       839            push acc
0A27 9003AF     839            mov dptr, #LCD_clearLine
0A2A 1200BA     839            lcall ?Send_Constant_String
0A2D D0E0       839            pop acc
0A2F D082       839            pop dpl
0A31 D083       839            pop dph
0A33 020A3C     840                   ljmp    menu_FSM_done
0A36            841   
0A36            842           reset_menu_state: ; sets menu state variable to 0
0A36 754500     843                   mov     MENU_STATE, #MENU_STATE_SOAK
0A39 020A3C     844                   ljmp    menu_FSM_done
0A3C            845   
0A3C            846           menu_FSM_done:
0A3C 22         847                   ret
0A3D            848   
0A3D            849   main_program:
0A3D            850           ; George
0A3D 75817F     851           mov     sp, #0x7f
0A40 1204F5     852           lcall   Initilize_All
0A43 120087     853           lcall   LCD_4BIT
0A46            854           ; lcall   configure_LCD_multiplexing
0A46            855   
0A46            856           ; Default display - 
0A46            857           ; Reflow oven controller 
0A46            858           ; (Start or Configure?)
0A46            859           PROGRAM_ENTRY:
0A46 C0E0       860            push acc
0A48 7401       860            mov a, #1
0A4A 14         860            dec a
0A4B 1200C7     860            lcall ?Set_Cursor_1 ; Select column and row
0A4E D0E0       860            pop acc
0A50 C083       861            push dph
0A52 C082       861            push dpl
0A54 C0E0       861            push acc
0A56 900352     861            mov dptr, #LCD_defaultTop
0A59 1200BA     861            lcall ?Send_Constant_String
0A5C D0E0       861            pop acc
0A5E D082       861            pop dpl
0A60 D083       861            pop dph
0A62 C0E0       862            push acc
0A64 7401       862            mov a, #1
0A66 14         862            dec a
0A67 1200C5     862            lcall ?Set_Cursor_2 ; Select column and row
0A6A D0E0       862            pop acc
0A6C C083       863            push dph
0A6E C082       863            push dpl
0A70 C0E0       863            push acc
0A72 900360     863            mov dptr, #LCD_defaultBot
0A75 1200BA     863            lcall ?Send_Constant_String
0A78 D0E0       863            pop acc
0A7A D082       863            pop dpl
0A7C D083       863            pop dph
0A7E            864   
0A7E            865           checkStartButton: ; assumed negative logic - used a label for an easy ljmp in the future
0A7E D204       866           setb PB_START_PIN
0A80 D205       866           setb PB_CHANGE_MENU_PIN
0A82 D206       866           setb PB_INC_TEMP_PIN
0A84 D207       866           setb PB_INC_TIME_PIN
0A86 D208       866           setb PB_STOP_PIN
0A88            866           
0A88 D295       866           setb SHARED_PIN
0A8A            866           ; check if any push buttons are pressed
0A8A C293       866           clr START_PIN             
0A8C C281       866           clr CHANGE_MENU_PIN       
0A8E C282       866           clr INC_TEMP_PIN          
0A90 C283       866           clr INC_TIME_PIN          
0A92 C280       866           clr STOP_PIN
0A94            866   
0A94            866           ; debounce
0A94 209544     866           jb SHARED_PIN, noStartButtonPress ; use helper label to jump to the end
0A97 C002       866            push AR2
0A99 7A32       866            mov R2, #50
0A9B 120038     866            lcall ?Wait_Milli_Seconds
0A9E D002       866            pop AR2
0AA0 209538     866           jb SHARED_PIN, noStartButtonPress
0AA3            866   
0AA3            866           ; Set the LCD data pins to logic 1
0AA3 D293       866           setb START_PIN
0AA5 D281       866           setb CHANGE_MENU_PIN
0AA7 D282       866           setb INC_TEMP_PIN
0AA9 D283       866           setb INC_TIME_PIN
0AAB D280       866           setb STOP_PIN
0AAD            866   
0AAD            866           ; check push buttons 1 by one
0AAD C293       866           clr START_PIN
0AAF A295       866           mov c, SHARED_PIN
0AB1 9204       866           mov PB_START_PIN, c
0AB3 D293       866           setb START_PIN
0AB5            866   
0AB5 C281       866           clr CHANGE_MENU_PIN
0AB7 A295       866           mov c, SHARED_PIN
0AB9 9205       866           mov PB_CHANGE_MENU_PIN, c
0ABB D281       866           setb CHANGE_MENU_PIN
0ABD            866   
0ABD C282       866           clr INC_TEMP_PIN
0ABF A295       866           mov c, SHARED_PIN
0AC1 9206       866           mov PB_INC_TEMP_PIN, c
0AC3 D282       866           setb INC_TEMP_PIN
0AC5            866   
0AC5 C283       866           clr INC_TIME_PIN
0AC7 A295       866           mov c, SHARED_PIN
0AC9 9207       866           mov PB_INC_TIME_PIN, c
0ACB D283       866           setb INC_TIME_PIN
0ACD            866   
0ACD C280       866           clr STOP_PIN
0ACF A295       866           mov c, SHARED_PIN
0AD1 9208       866           mov PB_STOP_PIN, c
0AD3 D280       866           setb STOP_PIN
0AD5            866   
0AD5 200403     866           jb PB_START_PIN, noStartButtonPress ; check that the variable flag is not 1, otherwise jmp
0AD8            866   
0AD8 020B48     867                   ljmp    enter_oven_fsm ; successful button press, enter oven FSM   
0ADB            868   
0ADB            869           noStartButtonPress:
0ADB D293       870                   setb    START_PIN
0ADD            871                   ; if the 'IN_MENU' flag is set, always enter into the menu FSM, this is so that the menu FSM can always be entered
0ADD            872                   ; creates an infinite loop that will always display menu once entered - broken if START button pressed
0ADD 300106     873                   jnb     IN_MENU_FLAG, checkMenuButtonPress
0AE0 120807     874                   lcall   MENU_FSM 
0AE3 020A7E     875                   ljmp    checkStartButton
0AE6            876   
0AE6            877           checkMenuButtonPress:
0AE6            878                   ; check for enter menu button press (reusing increment menu pin)
0AE6 D204       879           setb PB_START_PIN
0AE8 D205       879           setb PB_CHANGE_MENU_PIN
0AEA D206       879           setb PB_INC_TEMP_PIN
0AEC D207       879           setb PB_INC_TIME_PIN
0AEE D208       879           setb PB_STOP_PIN
0AF0            879           
0AF0 D295       879           setb SHARED_PIN
0AF2            879           ; check if any push buttons are pressed
0AF2 C293       879           clr START_PIN             
0AF4 C281       879           clr CHANGE_MENU_PIN       
0AF6 C282       879           clr INC_TEMP_PIN          
0AF8 C283       879           clr INC_TIME_PIN          
0AFA C280       879           clr STOP_PIN
0AFC            879   
0AFC            879           ; debounce
0AFC 209544     879           jb SHARED_PIN, noMenuButtonPress ; use helper label to jump to the end
0AFF C002       879            push AR2
0B01 7A32       879            mov R2, #50
0B03 120038     879            lcall ?Wait_Milli_Seconds
0B06 D002       879            pop AR2
0B08 209538     879           jb SHARED_PIN, noMenuButtonPress
0B0B            879   
0B0B            879           ; Set the LCD data pins to logic 1
0B0B D293       879           setb START_PIN
0B0D D281       879           setb CHANGE_MENU_PIN
0B0F D282       879           setb INC_TEMP_PIN
0B11 D283       879           setb INC_TIME_PIN
0B13 D280       879           setb STOP_PIN
0B15            879   
0B15            879           ; check push buttons 1 by one
0B15 C293       879           clr START_PIN
0B17 A295       879           mov c, SHARED_PIN
0B19 9204       879           mov PB_START_PIN, c
0B1B D293       879           setb START_PIN
0B1D            879   
0B1D C281       879           clr CHANGE_MENU_PIN
0B1F A295       879           mov c, SHARED_PIN
0B21 9205       879           mov PB_CHANGE_MENU_PIN, c
0B23 D281       879           setb CHANGE_MENU_PIN
0B25            879   
0B25 C282       879           clr INC_TEMP_PIN
0B27 A295       879           mov c, SHARED_PIN
0B29 9206       879           mov PB_INC_TEMP_PIN, c
0B2B D282       879           setb INC_TEMP_PIN
0B2D            879   
0B2D C283       879           clr INC_TIME_PIN
0B2F A295       879           mov c, SHARED_PIN
0B31 9207       879           mov PB_INC_TIME_PIN, c
0B33 D283       879           setb INC_TIME_PIN
0B35            879   
0B35 C280       879           clr STOP_PIN
0B37 A295       879           mov c, SHARED_PIN
0B39 9208       879           mov PB_STOP_PIN, c
0B3B D280       879           setb STOP_PIN
0B3D            879   
0B3D 200503     879           jb PB_CHANGE_MENU_PIN, noMenuButtonPress ; check that the variable flag is not 1, otherwise jmp
0B40            879   
0B40            879   
0B40            880                   ; setb IN_MENU_FLAG; successful button press, enter menu FSM loop ; - THIS LINE CAUSES THE BUG
0B40 020B8D     881                   ljmp    setMenuFlag
0B43            882                   
0B43            883           noMenuButtonPress:
0B43 D281       884                   setb CHANGE_MENU_PIN
0B45 020A7E     885                   ljmp    checkStartButton ; this line does not execute if ljmp setMenuFlag is there?!?!?
0B48            886   
0B48            887           enter_oven_fsm:
0B48 C201       888                   clr     IN_MENU_FLAG ; No longer in menu
0B4A D202       889                   setb    IN_OVEN_FLAG
0B4C C0E0       890            push acc
0B4E 7401       890            mov a, #1
0B50 14         890            dec a
0B51 1200C7     890            lcall ?Set_Cursor_1 ; Select column and row
0B54 D0E0       890            pop acc
0B56 C083       891            push dph
0B58 C082       891            push dpl
0B5A C0E0       891            push acc
0B5C 9003AF     891            mov dptr, #LCD_clearLine
0B5F 1200BA     891            lcall ?Send_Constant_String
0B62 D0E0       891            pop acc
0B64 D082       891            pop dpl
0B66 D083       891            pop dph
0B68 C0E0       892            push acc
0B6A 7401       892            mov a, #1
0B6C 14         892            dec a
0B6D 1200C5     892            lcall ?Set_Cursor_2 ; Select column and row
0B70 D0E0       892            pop acc
0B72 C083       893            push dph
0B74 C082       893            push dpl
0B76 C0E0       893            push acc
0B78 9003AF     893            mov dptr, #LCD_clearLine
0B7B 1200BA     893            lcall ?Send_Constant_String
0B7E D0E0       893            pop acc
0B80 D082       893            pop dpl
0B82 D083       893            pop dph
0B84            894   
0B84 120479     895                   lcall   Timer2_Init  ; breaks things
0B87 120582     896                   lcall   OVEN_FSM     ; will call STOP_PROCESS which loops back to the entry point
0B8A 120570     897                   lcall   STOP_PROCESS ; added for safety
0B8D            898                   
0B8D            899           setMenuFlag: 
0B8D D201       900                   setb    IN_MENU_FLAG
0B8F 020A7E     901                   ljmp    checkStartButton
0B92            902   
0B92            903           program_end:
0B92 020A3D     904                   ljmp    main_program
0B95            905   EN
